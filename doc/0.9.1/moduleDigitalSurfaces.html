<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>DGtal: Digital surfaces</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">0.9.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Digital surfaces </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#dgtal_digsurf_sec1">Introduction to digital surfaces</a><ul><li class="level2"><a href="#dgtal_digsurf_sec1_1">Possible definitions for digital surfaces</a></li>
<li class="level2"><a href="#dgtal_digsurf_sec1_2">Digital surface as a set of n-1-cells</a></li>
<li class="level2"><a href="#dgtal_digsurf_sec1_3">Digital surface as a graph: adding adjacencies between surfels</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtal_digsurf_sec2">Tracking digital surfaces</a><ul><li class="level2"><a href="#dgtal_digsurf_sec2_1">Constructing digital surfaces by scanning</a></li>
<li class="level2"><a href="#dgtal_digsurf_sec2_2">Constructing digital surfaces by tracking</a></li>
<li class="level2"><a href="#dgtal_digsurf_sec2_3">Other constructions by tracking: 2D contours, surface connected components, 2D slices in 3D surface</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtal_digsurf_sec3">High-level classes for digital surfaces</a><ul><li class="level2"><a href="#dgtal_digsurf_sec3_1">A common architecture for digital surfaces</a></li>
<li class="level2"><a href="#dgtal_digsurf_sec3_2">Models of digital surface containers</a></li>
<li class="level2"><a href="#dgtal_digsurf_sec3_3">Relating a digital surface to some container</a></li>
<li class="level2"><a href="#dgtal_digsurf_sec3_4">A digital surface is a graph, example of breadth-first traversal</a></li>
<li class="level2"><a href="#dgtal_digsurf_sec3_5">Boundary and frontiers  examples of digital surface</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtal_digsurf_sec4">The digital surface graph is a combinatorial manifold</a><ul><li class="level2"><a href="#dgtal_digsurf_sec4_1">Umbrellas and faces</a></li>
<li class="level2"><a href="#dgtal_digsurf_sec4_2">Vertices, arcs and faces on a digital surface</a></li>
<li class="level2"><a href="#dgtal_digsurf_sec4_3">Application to export surface in OFF format</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation:</dt><dd>Jacques-Olivier Lachaud</dd></dl>
<p>Part of the <a class="el" href="packageTopology.html">Topology package</a>.</p>
<p>This part of the manual describes how to define digital surfaces, closed or open. A lot of the ideas, concepts, algorithms, documentation and code is a backport from <a href="https://gforge.liris.cnrs.fr/projects/imagene">ImaGene</a>. <a class="el" href="citelist.html#CITEREF_ImaGene">[34]</a></p>
<p>The following programs are related to this documentation: <a class="el" href="volToOFF_8cpp_source.html">volToOFF.cpp</a>, <a class="el" href="volMarchingCubes_8cpp_source.html">volMarchingCubes.cpp</a>, <a class="el" href="volScanBoundary_8cpp_source.html">volScanBoundary.cpp</a>, <a class="el" href="volTrackBoundary_8cpp_source.html">volTrackBoundary.cpp</a>, <a class="el" href="frontierAndBoundary_8cpp_source.html">frontierAndBoundary.cpp</a>, <a class="el" href="volBreadthFirstTraversal_8cpp_source.html">volBreadthFirstTraversal.cpp</a>, trackImplicitPolynomialSurfaceToOFF</p>
<h1><a class="anchor" id="dgtal_digsurf_sec1"></a>
Introduction to digital surfaces</h1>
<h2><a class="anchor" id="dgtal_digsurf_sec1_1"></a>
Possible definitions for digital surfaces</h2>
<p>Although continuous surfaces are well defined as n-manifolds, a digital or discrete analog of surface is more tricky to define. Several methods have been explored to define consistent digital surfaces. We mention three approaches here.</p>
<ul>
<li>Surface as specific subsets of \( Z^n \), i.e. as sets of pixels in 2D, voxels in 3D, etc, with specific properties. This approach was proposed by Rosenfeld in the 70s. The set \( S \subset Z^n \) is a digital surface iff \( Z^n \setminus S \) is composed of two \( \alpha \)-connected components and if <em>S</em> is thin (i.e. if any point of <em>S</em> is removed, the preceding property does not hold). This approach is not too bad in 2D, becomes more complex in 3D (see the work of Morgenthaler and Rosenfeld or Malgouyres) and is unusable in practice. For instance the border of any digital object is generally not a surface.</li>
<li>Surface as \( n-1 \)-dimensional cubical complexes. For example, if a digital object is a pure \( n \)-dimensional cubical complex, its boundary is naturally a \( n-1 \)-dimensional cubical complex. This seems at first sight a good approach, and it works well with well-composed pictures and images (see the work of Latecki et al.). The obtain complex is indeed a \( n-1 \)-manifold when realized in the Euclidean space. However, if the object contains any <em>cross</em> configuration (like two voxels connected by their edge, and the other two voxels adjacent to them are not in the object) then the preceding property does not hold anymore. Cubical complexes are thus interesting for representing objects, but not so interesting when one is interested by the geometry of its boundary.</li>
<li>Surface as set of n-1-cells with some specific adjacencies. This approach is more or less the approach of Herman, Udupa and others, which was designed originally for tracking surfaces in a digital space. In 2D, this correspond to an interpixel approach. You choose first if you wish an interior adjacency (4-connectedness) or an exterior adjacency (8-adjacency). Two linels (or edges) are connected if they are point-connected and in case of a cross configuration they border the same interior (resp. exterior) pixel. The principle is the same in 3D, where a 2-cell (surfel) has edge-connected surfels with a preference in case of cross configuration.</li>
</ul>
<p>We focus here on the last method to define digital surfaces.</p>
<h2><a class="anchor" id="dgtal_digsurf_sec1_2"></a>
Digital surface as a set of n-1-cells</h2>
<p>Formally, the elements of the digital space \( Z^n \) are called <em>spels</em>, and often <em>pixels</em> in 2D and <em>voxels</em> in 3D. A <em>surfel</em> is a couple (u,v) of face-adjacent voxels. A <em>digital</em> <em>surface</em> is a set of surfels. It is obvious that a spel is a n-cell in the cellular grid decomposition of the space, while a surfel is clearly some oriented n-1-cell which is incident to the two n-cells u and v (see <a class="el" href="moduleCellularTopology.html">Cellular grid space and topology, unoriented and oriented cells, incidence</a>).</p>
<p>Let <em>s</em> be some surfel. It is incident to two oriented voxels. By convention, its <em>interior</em> pixel is the one that is <b>positively</b> oriented.</p>
<p>We assume from now on that you have instantiated some cellular space <em>K</em> of type <em>KSpace</em> (see dgtal_ctopo_sec4), for instance with the following lines:</p>
<div class="fragment"><div class="line">KSpace K;</div><div class="line">Point low( -10, -10, -10 );</div><div class="line">Point high( 10, 10, 10 );</div><div class="line"><span class="keywordtype">bool</span> space_ok = K.init( low, high, <span class="keyword">true</span> );</div></div><!-- fragment --><p>A surfel is an oriented \(n-1\)-cell, i.e. some SCell. Surfel may be obtained from spels by incidence relation. Reciprocally, you can use incidence to get spels.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> KSpace::SCell Surfel; <span class="comment">// or typedef KSpace::Surfel Surfel;</span></div><div class="line"><span class="keyword">typedef</span> KSpace::SCell Spel; <span class="comment">// or typedef KSpace::Surfel Surfel;</span></div><div class="line">Spel v = K.sSpel( Point( 0, 0, 0 ), POS ); <span class="comment">// +v</span></div><div class="line">Surfel sx = K.sIncident( v, 0, <span class="keyword">true</span> ); <span class="comment">// surfel further along x</span></div><div class="line">Surfel sy = K.sIncident( v, 1, <span class="keyword">true</span> ); <span class="comment">// surfel further along y</span></div><div class="line">Surfel sz = K.sIncident( v, 2, <span class="keyword">true</span> ); <span class="comment">// surfel further along z</span></div><div class="line">Spel qx = K.sDirectIncident( s, 0 ); <span class="comment">// positive coboundary of s</span></div><div class="line">Spel qy = K.sDirectIncident( s, 1 ); <span class="comment">// positive coboundary of s</span></div><div class="line">Spel qz = K.sDirectIncident( s, 2 ); <span class="comment">// positive coboundary of s</span></div><div class="line">ASSERT( v == qx &amp;&amp; v == qy &amp;&amp; v == qz ); <span class="comment">// same as qx, qy, qz</span></div></div><!-- fragment --><p>The direct orientation to some cell <em>s</em> is the one that gives a positively oriented cell in the boundary or coboundary of <em>s</em>.</p>
<p>You may now for instance define the digital surface that lies in the boundary of some digital shape \( S \subset Z^n \) as the set of oriented surfels between spels of <em>S</em> and spels not in <em>S</em>. Algebraically, <em>S</em> is the formal of its positively oriented spels, and its <em>boundary</em> is obtained by applying the boundary operator on <em>S</em>.</p>
<div class="image">
<img src="digital-surface-BdryOp-1s.png" alt="digital-surface-BdryOp-1s.png"/>
<div class="caption">
Using the boundary operator to compute the boundary of a digital shape S.</div></div>
  <div class="image">
<img src="digital-surface-BdryOp-2s.png" alt="digital-surface-BdryOp-2s.png"/>
<div class="caption">
The boundary operator is linear with cells, thus we compute spel by spel.</div></div>
  <div class="image">
<img src="digital-surface-BdryOp-3s.png" alt="digital-surface-BdryOp-3s.png"/>
<div class="caption">
The boundary operator is linear with cells, thus we compute spel by spel.</div></div>
  <div class="image">
<img src="digital-surface-BdryOp-4s.png" alt="digital-surface-BdryOp-4s.png"/>
<div class="caption">
Opposite cells cancel each other.</div></div>
 <div class="image">
<img src="digital-surface-BdryOp-5s.png" alt="digital-surface-BdryOp-5s.png"/>
<div class="caption">
This is the resulting set of surfels (in blue and magenta.</div></div>
<p>Defining a digital surface as a set of surfels is not enough for geometry. Indeed we need to relate surfels together so as to have a topology on the digital surface. The first step is to transform the digital surface into a graph.</p>
<h2><a class="anchor" id="dgtal_digsurf_sec1_3"></a>
Digital surface as a graph: adding adjacencies between surfels</h2>
<p>The idea here is to connect surfels that share some \(n-2\)-cells. The obtained adjacency relations are called <em>bel</em> <em>adjacencies</em> in the terminology of Herman, Udupa and others. Generally an \(n-2\)-cell is shared by at most two \(n-1\)-cells, except in "cross
configuration", symbolized below:</p>
<pre class="fragment">   O | X    X: interior spels               O a X
   - + -    O: exterior spels               b + c
   X | O    - and |: surfels a,b,c,d        X d O
            +: n-2-cell 
</pre><p>A bel adjacency makes a deterministic choice to connect b to d and a to c when interior, and b to a and c to d when exterior. This choice has to be made along each possible pair of directions when going nD. In <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types. ">DGtal</a>, this is encoded with the class <a class="el" href="classDGtal_1_1SurfelAdjacency.html" title="Aim: Represent adjacencies between surfel elements, telling if it follows an interior to exterior ord...">SurfelAdjacency</a>.</p>
<div class="image">
<img src="digital-surface-IntAdjacency.png" alt="digital-surface-IntAdjacency.png"/>
<div class="caption">
Interior adjacency on digital surfaces in 2D</div></div>
 <p>The following snippet shows the interior surfel adjacency (i.e. (6,18)-surfaces).</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> SurfelAdjacency&lt;KSpace::dimension&gt; MySurfelAdjacency;</div><div class="line">  MySurfelAdjacency surfAdj( intAdjacency ); <span class="comment">// interior in all directions.</span></div></div><!-- fragment --><p> Once the adjacency has been chosen, it is possible to determine what are the adjacent surfels to a given surfel. More precisely, any surfel (or \(n-1\)-cell) has exactly \(2n-2\) adjacent surfels (for closed surfaces). More precisely, it has exactly 2 adjacent surfels along directions different from the orthogonal direction of the surfel.</p>
<div class="image">
<img src="digital-surface-SurfaceTracking2.png" alt="digital-surface-SurfaceTracking2.png"/>
<div class="caption">
Any surfel in 3D has 4 adjacent surfels.</div></div>
 <p>In fact, we can be even more precise. We can use orientation to orient the adjacencies consistently. Given two surfels sharing an \(n-2\)-cell, this cell is positively oriented in the boundary of one surfel and negatively oriented in the boundary of the other. We have thus that there are \(n-1\) adjacent cells in the direct orientation (positive) and \(n-1\) adjacent cells in the indirect orientation (negative). The direct adjacent surfels look like:</p>
<div class="image">
<img src="digital-surface-SurfaceTracking.png" alt="digital-surface-SurfaceTracking.png"/>
<div class="caption">
Any surfel in 3D has 2 adjacent surfels in the direct orientation.</div></div>
 <p>The class <a class="el" href="classDGtal_1_1SurfelNeighborhood.html" title="Aim: This helper class is useful to compute the neighboring surfels of a given surfel, especially over a digital surface or over an object boundary. Two signed surfels are incident if they share a common n-2 cell. This class uses a SurfelAdjacency so as to determine adjacent surfels (either looking for them from interior to exterior or inversely). ">SurfelNeighborhood</a> is the base class for computing adjacent surfels. You may use it as follow, but generally this class is hidden for you since you will have more high-level classes to move on surfaces.</p>
<div class="fragment"><div class="line"><span class="comment">// K is a KSpace, surfAdj is a SurfelAdjacency, surfel is some SCell.</span></div><div class="line">SurfelNeighborhood&lt;KSpace&gt; sNeigh;</div><div class="line">sNeigh.init( &amp;K, &amp;SAdj, surfel );</div><div class="line"><a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;surfel=&quot;</span> &lt;&lt; surfel &lt;&lt; endl;</div><div class="line"><a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;follower1(+)=&quot;</span> &lt;&lt; sNeigh.follower1( 1, <span class="keyword">true</span> ) &lt;&lt; endl;</div><div class="line"><a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;follower2(+)=&quot;</span> &lt;&lt; sNeigh.follower2( 1, <span class="keyword">true</span> ) &lt;&lt; endl;</div><div class="line"><a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;follower3(+)=&quot;</span> &lt;&lt; sNeigh.follower3( 1, <span class="keyword">true</span> ) &lt;&lt; endl;</div><div class="line"><a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;follower1(-)=&quot;</span> &lt;&lt; sNeigh.follower1( 1, <span class="keyword">false</span> ) &lt;&lt; endl;</div><div class="line"><a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;follower2(-)=&quot;</span> &lt;&lt; sNeigh.follower2( 1, <span class="keyword">false</span> ) &lt;&lt; endl;</div><div class="line"><a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;follower3(-)=&quot;</span> &lt;&lt; sNeigh.follower3( 1, <span class="keyword">false</span> ) &lt;&lt; endl;</div><div class="line"><a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">endBlock</a>();</div></div><!-- fragment --><p>Generally, methods <a class="el" href="classDGtal_1_1SurfelNeighborhood.html#ae8e4b81f9d7fbdde3b4aa1125862fc57">SurfelNeighborhood::getAdjacentOnSpelSet</a>, <a class="el" href="classDGtal_1_1SurfelNeighborhood.html#a904cf1b04a96d3a5682d91ce054eb297">SurfelNeighborhood::getAdjacentOnDigitalSet</a>, <a class="el" href="classDGtal_1_1SurfelNeighborhood.html#a635ea93c00eede9eaf8d85e9fd035e2f">SurfelNeighborhood::getAdjacentOnPointPredicate</a>, <a class="el" href="classDGtal_1_1SurfelNeighborhood.html#a32f584693393aaa95c6ca3329dc4e3a7">SurfelNeighborhood::getAdjacentOnSurfelPredicate</a> are used to find adjacent surfels.</p>
<p>Since we have defined adjacencies between surfels on a digital surface, the digital surface forms a graph (at least in theory).</p>
<h1><a class="anchor" id="dgtal_digsurf_sec2"></a>
Tracking digital surfaces</h1>
<p>This section shows how to extract the boundary of a digital set, given some predicate telling whether we are inside or outside the surface.</p>
<h2><a class="anchor" id="dgtal_digsurf_sec2_1"></a>
Constructing digital surfaces by scanning</h2>
<p>Given a domain and a predicate telling whether we are inside or outside the object of interest, it is easy to determine the set of surfels by a simple scanning of the space. This is done for you by static methods <a class="el" href="classDGtal_1_1Surfaces.html#a7c4c49a163650eaaff8759504d7891f7">Surfaces::uMakeBoundary</a> and <a class="el" href="classDGtal_1_1Surfaces.html#af61619b3dbd948aea387202369bddd6f">Surfaces::sMakeBoundary</a>.</p>
<p>The following snippet shows how to get a set of surfels that is the boundary of some predicate on point by a simple scan of the whole domain (see <a class="el" href="volScanBoundary_8cpp_source.html">volScanBoundary.cpp</a>).</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a>( <span class="stringliteral">&quot;Extracting boundary by scanning the space. &quot;</span> );</div><div class="line">  KSpace::SCellSet boundary;</div><div class="line">  <a class="code" href="classDGtal_1_1Surfaces.html#af61619b3dbd948aea387202369bddd6f">Surfaces&lt;KSpace&gt;::sMakeBoundary</a>( boundary, ks, set3d,</div><div class="line">                                   image.domain().lowerBound(),</div><div class="line">                                   image.domain().upperBound() );</div><div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">endBlock</a>();</div></div><!-- fragment --> <h2><a class="anchor" id="dgtal_digsurf_sec2_2"></a>
Constructing digital surfaces by tracking</h2>
<p>In many circumstances, it is better to use the above mentioned graph structure of digital surfaces. For instance it may be used to find the surface just by searching it by adjacencies. This process is called <b>tracking</b>. This is done for you by static method <a class="el" href="classDGtal_1_1Surfaces.html#a274dbb659f269382154035ae61d7e7b3">Surfaces::trackBoundary</a>.</p>
<p>The following snippet shows how to get a set of surfels that is the boundary of some predicate on point given only a starting surfel and by tracking (see <a class="el" href="volTrackBoundary_8cpp_source.html">volTrackBoundary.cpp</a>).</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a>( <span class="stringliteral">&quot;Extracting boundary by tracking from an initial bel.&quot;</span> );</div><div class="line">  KSpace::SCellSet boundary;</div><div class="line">  SCell bel = <a class="code" href="classDGtal_1_1Surfaces.html#a48e3a0e7c4728f6a6f23ec6f468a41b8">Surfaces&lt;KSpace&gt;::findABel</a>( ks, set3d, 100000 );</div><div class="line">  <a class="code" href="classDGtal_1_1Surfaces.html#a274dbb659f269382154035ae61d7e7b3">Surfaces&lt;KSpace&gt;::trackBoundary</a>( boundary, ks, </div><div class="line">                                   surfAdj,</div><div class="line">                                   set3d, bel );</div><div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">endBlock</a>();</div></div><!-- fragment --><p> On the lobser.vol volume, <a class="el" href="volScanBoundary_8cpp_source.html">volScanBoundary.cpp</a> extracts 155068 surfels in 3866ms, while <a class="el" href="volTrackBoundary_8cpp_source.html">volTrackBoundary.cpp</a> extracts 148364 surfels in 351ms.</p>
<pre class="fragment"># Commands
$ ./examples/topology/volScanBoundary ../examples/samples/lobster.vol 50 255
$ ./examples/topology/volTrackBoundary ../examples/samples/lobster.vol 50 255
</pre><div class="image">
<img src="volTrackBoundary-lobster.png" alt="volTrackBoundary-lobster.png"/>
<div class="caption">
Digital surface that is the boundary of a (6,18)-connected component in image lobster.vol, extracted by tracking from an initial surfel in 351ms.</div></div>
<p>In the case you know <b>beforehands</b> that your surface is closed (i.e. without boundary), you should use preferentially <a class="el" href="classDGtal_1_1Surfaces.html#a1d3cf3c5f54d0b556630f9dde154968d">Surfaces::trackClosedBoundary</a>. This technique only follows direct adjacent surfels and extracts the whole surface when it is closed. This process can be illustrated as follows:</p>
<div class="image">
<img src="suivi-parcours-largeur.png" alt="suivi-parcours-largeur.png"/>
<div class="caption">
Tracking a digital surface by following adjacencies.</div></div>
 <div class="image">
<img src="suivi-artzy.png" alt="suivi-artzy.png"/>
<div class="caption">
Tracking a digital surface by following only direct adjacencies.</div></div>
<h2><a class="anchor" id="dgtal_digsurf_sec2_3"></a>
Other constructions by tracking: 2D contours, surface connected components, 2D slices in 3D surface</h2>
<p>You can have a look at page <a class="el" href="moduleDigitalSurfaceHelpers.html">Helpers for digital surfaces</a> to see how to construct directly a 2D contour in \( Z^2 \), how to get the set of surface components, how to get 2D contours as slices onto a 3D surface.</p>
<p>You may also use the template class <a class="el" href="classDGtal_1_1DigitalSurface2DSlice.html" title="Aim: Represents a 2-dimensional slice in a DigitalSurface. In a sense, it is a 4-connected contour...">DigitalSurface2DSlice</a>, which, given a tracker on a digital surface, computes and store a 2d slice on the associated surface. You may after visit the slice with iterators or circulators. </p><div class="fragment"><div class="line"><span class="comment">// Tracker is a type of tracker on some digital surface.</span></div><div class="line"><span class="keyword">typedef</span> DigitalSurface2DSlice&lt;Tracker&gt; MySlice;</div><div class="line">Tracker* ptrTracker = ... ; <span class="comment">// some pointer on a tracker.</span></div><div class="line">MySlice slicex( ptrTracker, 0 ); <span class="comment">// slice containing x-axis</span></div><div class="line">MySlice slicey( ptrTracker, 1 ); <span class="comment">// slice containing y-axis</span></div><div class="line">MySlice slicez( ptrTracker, 2 ); <span class="comment">// slice containing z-axis</span></div><div class="line"><span class="comment">// One of them is invalid in 3D.</span></div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="digitalSurfaceSlice_8cpp_source.html">digitalSurfaceSlice.cpp</a></dd></dl>
<h1><a class="anchor" id="dgtal_digsurf_sec3"></a>
High-level classes for digital surfaces</h1>
<p>Digital surfaces arise in many different contexts:</p>
<ul>
<li>an explicit set of oriented surfels</li>
<li>the boundary of an explicit set of spels</li>
<li>the boundary of an explicit set of digital points</li>
<li>the boundary of a set of digital points, defined implicitly by a predicate: Point -&gt; bool</li>
<li>a set of oriented surfels, defined implicitly by a predicate: Surfel -&gt; bool</li>
<li>a set of oriented surfels, implicitly by a predicate: Oriented Surfel -&gt; bool</li>
<li>the boundary of a region in a labelled image</li>
<li>the frontier between two regions in a labelled image</li>
<li>...</li>
</ul>
<p>Since there are so many digital surfaces, it is necessary to provide a mechanism to handle them generically. The class <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a> will be the common proxy to hide models of <a class="el" href="structDGtal_1_1concepts_1_1CDigitalSurfaceContainer.html" title="Aim: The digital surface container concept describes a minimal set of inner types and methods so as t...">concepts::CDigitalSurfaceContainer</a>.</p>
<h2><a class="anchor" id="dgtal_digsurf_sec3_1"></a>
A common architecture for digital surfaces</h2>
<p>Since there may be several types of digital surfaces, there are several container classes for them. All of them follow the concept <a class="el" href="structDGtal_1_1concepts_1_1CDigitalSurfaceContainer.html" title="Aim: The digital surface container concept describes a minimal set of inner types and methods so as t...">concepts::CDigitalSurfaceContainer</a>. Essentially, a model of this class should provide methods begin() and end() to visit all the surfels, and a <em>Tracker</em> which allows to move by adjacencies on the surface. A Tracker should be a model of <a class="el" href="structDGtal_1_1concepts_1_1CDigitalSurfaceTracker.html" title="Aim: ">concepts::CDigitalSurfaceTracker</a>. The architecture is sumed up below:</p>
<div class="image">
<img src="diag-digital-surface-1.png" alt="diag-digital-surface-1.png"/>
<div class="caption">
Class architecture of digital surfaces.</div></div>
<h2><a class="anchor" id="dgtal_digsurf_sec3_2"></a>
Models of digital surface containers</h2>
<p>For now, the implemented digital surface container are (realization of <a class="el" href="structDGtal_1_1concepts_1_1CDigitalSurfaceContainer.html" title="Aim: The digital surface container concept describes a minimal set of inner types and methods so as t...">concepts::CDigitalSurfaceContainer</a>):</p>
<ul>
<li>model <a class="el" href="classDGtal_1_1DigitalSetBoundary.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of a given...">DigitalSetBoundary</a>, parameterized by a cellular space and a digital set. Represents the boundary of a digital set (a set of digital points, considered as the set of pixels/voxels/spels of the space).</li>
<li>model <a class="el" href="classDGtal_1_1ImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">ImplicitDigitalSurface</a>, parameterized by a cellular space and a predicate Point-&gt;bool. Represents the (connected) boundary of shape defined implicitly by a predicate. Computes at instanciation the set of surfels by a tracking algorithm.</li>
<li>model <a class="el" href="classDGtal_1_1LightImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">LightImplicitDigitalSurface</a>, parameterized by a cellular space and a predicate Point-&gt;bool. Represents the (connected) boundary of shape defined implicitly by a predicate. Do not compute at instanciation the set of surfels, but rather visits the surface on demand.</li>
<li>model <a class="el" href="classDGtal_1_1SetOfSurfels.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">SetOfSurfels</a>, parameterized by a cellular space and a set storing surfels. Represents an arbitrary set of surfels stored explicitly.</li>
<li>model <a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">ExplicitDigitalSurface</a>, parameterized by a cellular space and a predicate Surfel-&gt;bool. Represents a (connected) set of surfels defined implicitly by a predicate. Computes at instanciation the set of surfels by a tracking algorithm.</li>
<li>model <a class="el" href="classDGtal_1_1LightExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">LightExplicitDigitalSurface</a>, parameterized by a cellular space and a predicate Surfel-&gt;bool. Represents a (connected) set of surfels defined implicitly by a predicate. Do not compute at instanciation the set of surfels, but rather visits the surface on demand.</li>
</ul>
<p>Depending of what is your digital surface, you should choose your container accordingly:</p><ul>
<li>an explicit set of oriented surfels: model <a class="el" href="classDGtal_1_1SetOfSurfels.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">SetOfSurfels</a>, or if you wish to keep only one connected component, the model <a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">ExplicitDigitalSurface</a> together with a model of <a class="el" href="structDGtal_1_1concepts_1_1CSurfelPredicate.html" title="Aim: Defines a predicate on a surfel. ">concepts::CSurfelPredicate</a> on your set.</li>
<li>the boundary of an explicit set of spels: either convert it to a DigitalSet and use model <a class="el" href="classDGtal_1_1DigitalSetBoundary.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of a given...">DigitalSetBoundary</a>, or use model <a class="el" href="classDGtal_1_1ImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">ImplicitDigitalSurface</a> and a <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point. ">concepts::CPointPredicate</a> on your set of spels (require connectedness).</li>
<li>the boundary of an explicit set of digital points: model <a class="el" href="classDGtal_1_1DigitalSetBoundary.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of a given...">DigitalSetBoundary</a> directly</li>
<li>the boundary of a set of digital points, defined implicitly by a predicate Point -&gt; bool: model <a class="el" href="classDGtal_1_1ImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">ImplicitDigitalSurface</a> and a start surfel</li>
<li>a set of oriented surfels, defined implicitly by a predicate Surfel -&gt; bool: model <a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">ExplicitDigitalSurface</a> and a start surfel.</li>
<li>the boundary of a region in a labelled image: model <a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">ExplicitDigitalSurface</a> and a start surfel, and the class <a class="el" href="classDGtal_1_1functors_1_1BoundaryPredicate.html" title="Aim: The predicate on surfels that represents the frontier between a region and its complementary in ...">functors::BoundaryPredicate</a>, which is model of <a class="el" href="structDGtal_1_1concepts_1_1CSurfelPredicate.html" title="Aim: Defines a predicate on a surfel. ">concepts::CSurfelPredicate</a>.</li>
<li>the frontier between two regions in a labelled image: model <a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">ExplicitDigitalSurface</a> and a start surfel, and the class <a class="el" href="classDGtal_1_1functors_1_1FrontierPredicate.html" title="Aim: The predicate on surfels that represents the frontier between two regions in an image...">functors::FrontierPredicate</a>, which is model of <a class="el" href="structDGtal_1_1concepts_1_1CSurfelPredicate.html" title="Aim: Defines a predicate on a surfel. ">concepts::CSurfelPredicate</a>.</li>
</ul>
<p>Light versions of containers should be preferred in mostly two cases:</p>
<ol type="1">
<li>The digital surface is big and you do not wish to keep it in memory. This is probably the case when tracking some implicit function and outputing it in some stream.</li>
<li>The digital surface is likely to evolve (i.e. the predicate do not give the same response at a point/surfel depending on when it is called).</li>
</ol>
<h2><a class="anchor" id="dgtal_digsurf_sec3_3"></a>
Relating a digital surface to some container</h2>
<p>The following snippet shows how to create a digital surface associated to a <a class="el" href="classDGtal_1_1LightImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">LightImplicitDigitalSurface</a>. The <a class="el" href="classDGtal_1_1LightImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">LightImplicitDigitalSurface</a> is connected to a shape described by a predicate on point (a simple digital set). The full code is in <a class="el" href="volBreadthFirstTraversal_8cpp_source.html">volBreadthFirstTraversal.cpp</a>.</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a>( <span class="stringliteral">&quot;Set up digital surface.&quot;</span> );</div><div class="line">  <span class="keyword">typedef</span> LightImplicitDigitalSurface&lt;KSpace, DigitalSet &gt;</div><div class="line">    MyDigitalSurfaceContainer;</div><div class="line">  <span class="keyword">typedef</span> DigitalSurface&lt;MyDigitalSurfaceContainer&gt; MyDigitalSurface;</div><div class="line">  SCell bel = <a class="code" href="classDGtal_1_1Surfaces.html#a48e3a0e7c4728f6a6f23ec6f468a41b8">Surfaces&lt;KSpace&gt;::findABel</a>( ks, set3d, 100000 );</div><div class="line">  MyDigitalSurfaceContainer* ptrSurfContainer =</div><div class="line">    <span class="keyword">new</span> MyDigitalSurfaceContainer( ks, set3d, surfAdj, bel );</div><div class="line">  MyDigitalSurface digSurf( ptrSurfContainer ); <span class="comment">// acquired</span></div><div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">endBlock</a>();</div></div><!-- fragment --><p> Once this is done, the object <code>digSurf</code> is a proxy to your container. Here the dynamically allocated object is acquired by the digital surface, which will take care of its deletion.</p>
<dl class="section note"><dt>Note</dt><dd>This creation of the container and the connection to a digital surface takes almost no time, since the chosen container (Light...) is lazy: the whole surface has not been extracted yet.</dd></dl>
<h2><a class="anchor" id="dgtal_digsurf_sec3_4"></a>
A digital surface is a graph, example of breadth-first traversal</h2>
<p>Any <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a> is a model of <a class="el" href="structDGtal_1_1concepts_1_1CUndirectedSimpleGraph.html" title="Aim: Represents the concept of local graph: each vertex has neighboring vertices, but we do not neces...">concepts::CUndirectedSimpleGraph</a> (a refinement of <a class="el" href="structDGtal_1_1concepts_1_1CUndirectedSimpleLocalGraph.html" title="Aim: Represents the concept of local graph: each vertex has neighboring vertices, but we do not neces...">concepts::CUndirectedSimpleLocalGraph</a>). Essentially, you have methods <a class="el" href="classDGtal_1_1DigitalSurface.html#a49b0a08eb04ed843d3e2c9ac7112a913">DigitalSurface::begin()</a> and <a class="el" href="classDGtal_1_1DigitalSurface.html#a00e29d43b6f9d0313c7134aec8c4f4ee">DigitalSurface::end()</a> to visit all the vertices, and for each vertex, you obtain its neighbors with <a class="el" href="classDGtal_1_1DigitalSurface.html#ac45efcabe133596dd17895188bf9ee13">DigitalSurface::writeNeighbors</a>. You may thus for instance use the class <a class="el" href="classDGtal_1_1BreadthFirstVisitor.html" title="Aim: This class is useful to perform a breadth-first exploration of a graph given a starting point or...">BreadthFirstVisitor</a> to do a breadth-first traversal of the digital surface.</p>
<p>We may extract the whole surface by doing a breadth-first traversal on the graph. The snippet below shows how to do it on any kind of digital surface, whatever the container.</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a>( <span class="stringliteral">&quot;Extracting boundary by tracking from an initial bel.&quot;</span> );</div><div class="line">  <span class="keyword">typedef</span> BreadthFirstVisitor&lt;MyDigitalSurface&gt; MyBreadthFirstVisitor;</div><div class="line">  <span class="keyword">typedef</span> MyBreadthFirstVisitor::Node MyNode;</div><div class="line">  <span class="keyword">typedef</span> MyBreadthFirstVisitor::Size MySize;</div><div class="line">  MyBreadthFirstVisitor visitor( digSurf, bel );</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> nbSurfels = 0;</div><div class="line">  MyNode node;</div><div class="line">  <span class="keywordflow">while</span> ( ! visitor.finished() )</div><div class="line">    {</div><div class="line">      node = visitor.current();</div><div class="line">      ++nbSurfels;</div><div class="line">      visitor.expand();</div><div class="line">    }</div><div class="line">  MySize maxDist = node.second;</div><div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">endBlock</a>();</div></div><!-- fragment --><p> Here, we only use it to get the maximal distance to the starting bel. A second pass could be done to display cells with a color that depends on the distance to the starting surfel.</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a>( <span class="stringliteral">&quot;Displaying surface in Viewer3D.&quot;</span> );</div><div class="line">  QApplication application(argc,argv);</div><div class="line">  Viewer3D&lt;&gt; viewer;</div><div class="line">  viewer.show();</div><div class="line">  HueShadeColorMap&lt;MySize,1&gt; hueShade( 0, maxDist );</div><div class="line">  MyBreadthFirstVisitor visitor2( digSurf, bel );</div><div class="line">  viewer &lt;&lt; CustomColors3D( <a class="code" href="classDGtal_1_1Color.html#ac26d8585885e7a354893b7e93c6a9dda">Color::Black</a>, <a class="code" href="classDGtal_1_1Color.html#ab7b17778033da4f2ce2825d385e53d90">Color::White</a> )</div><div class="line">         &lt;&lt; ks.unsigns( bel );</div><div class="line">  visitor2.expand();</div><div class="line">  <span class="keywordflow">while</span> ( ! visitor2.finished() )</div><div class="line">    {</div><div class="line">      node = visitor2.current();</div><div class="line">      Color c = hueShade( node.second );</div><div class="line">      viewer &lt;&lt; CustomColors3D( <a class="code" href="classDGtal_1_1Color.html#aa5e8679bd0da49f95d13cd95a17b619b">Color::Red</a>, c )</div><div class="line">             &lt;&lt; ks.unsigns( node.first );</div><div class="line">      visitor2.expand();</div><div class="line">    }</div><div class="line">  viewer &lt;&lt; Viewer3D&lt;&gt;::updateDisplay;</div><div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;nb surfels = &quot;</span> &lt;&lt; nbSurfels &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">endBlock</a>();</div><div class="line">  <span class="keywordflow">return</span> application.exec();</div></div><!-- fragment --><p> We may call it as follows </p><pre class="fragment"># Commands
$ ./examples/topology/volBreadthFirstTraversal ../examples/samples/lobster.vol 50 255
$ ./examples/topology/volBreadthFirstTraversal ../examples/samples/Al.100.vol 0 1
$ ./examples/topology/volBreadthFirstTraversal ../examples/samples/cat10.vol 1 255
</pre><p>to get these pictures: </p><div class="image">
<img src="digital-surface-bfv-all.png" alt="digital-surface-bfv-all.png"/>
<div class="caption">
Examples of breadth-first traversal on a digital surface.</div></div>
<dl class="section note"><dt>Note</dt><dd>In fact, the specific container <a class="el" href="classDGtal_1_1LightImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">LightImplicitDigitalSurface</a> performs itself a breadth-first traversal to extract its vertices by itself. Therefere, you may use a simple begin() and end() to get the vertices in this order, when <b>your</b> <b>container</b> <b>is</b> <b>a</b> <b><a class="el" href="classDGtal_1_1LightImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">LightImplicitDigitalSurface</a></b>.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000063">Todo:</a></b></dt><dd>The concepts <a class="el" href="structDGtal_1_1concepts_1_1CUndirectedSimpleLocalGraph.html" title="Aim: Represents the concept of local graph: each vertex has neighboring vertices, but we do not neces...">concepts::CUndirectedSimpleLocalGraph</a> and <a class="el" href="structDGtal_1_1concepts_1_1CUndirectedSimpleGraph.html" title="Aim: Represents the concept of local graph: each vertex has neighboring vertices, but we do not neces...">concepts::CUndirectedSimpleGraph</a> are susceptible to evolve to meet other standards.</dd></dl>
<h2><a class="anchor" id="dgtal_digsurf_sec3_5"></a>
Boundary and frontiers  examples of digital surface</h2>
<p>Surfels of a digital surface can also be defined by a predicate telling whether or not some surfel belongs to it. Given an image of labels, the class <a class="el" href="classDGtal_1_1functors_1_1BoundaryPredicate.html" title="Aim: The predicate on surfels that represents the frontier between a region and its complementary in ...">functors::BoundaryPredicate</a> and <a class="el" href="classDGtal_1_1functors_1_1FrontierPredicate.html" title="Aim: The predicate on surfels that represents the frontier between two regions in an image...">functors::FrontierPredicate</a> are such predicates:</p>
<ol type="1">
<li><a class="el" href="classDGtal_1_1functors_1_1BoundaryPredicate.html" title="Aim: The predicate on surfels that represents the frontier between a region and its complementary in ...">functors::BoundaryPredicate</a> ( KSpace, <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values. ">Image</a>, l ) is a predicate returning true for a surfel <em>s</em> iff the interior spel of <em>s</em> has label <code>l</code> while the exterior spel of <em>s</em> has label different from <code>l</code>.</li>
<li><a class="el" href="classDGtal_1_1functors_1_1FrontierPredicate.html" title="Aim: The predicate on surfels that represents the frontier between two regions in an image...">functors::FrontierPredicate</a> ( KSpace, <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values. ">Image</a>, l1, l2 ) is a predicate returning true for a surfel <em>s</em> iff the interior spel of <em>s</em> has label <code>l1</code> while the exterior spel of <em>s</em> has label <code>l2</code>.</li>
</ol>
<p>Using container <a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">ExplicitDigitalSurface</a>, we can very simply define digital surfaces that are <b>connected</b> boundary of frontiers in some image. The following snippet is an excerpt from <a class="el" href="frontierAndBoundary_8cpp_source.html">frontierAndBoundary.cpp</a>.</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a>( <span class="stringliteral">&quot;Set up digital surface.&quot;</span> );</div><div class="line">  <span class="keyword">typedef</span> SurfelAdjacency&lt;KSpace::dimension&gt; MySurfelAdjacency;</div><div class="line">  MySurfelAdjacency surfAdj( <span class="keyword">true</span> ); <span class="comment">// interior in all directions.</span></div><div class="line">  <span class="keyword">typedef</span> functors::FrontierPredicate&lt;KSpace, Image&gt; FSurfelPredicate;</div><div class="line">  <span class="keyword">typedef</span> ExplicitDigitalSurface&lt;KSpace,FSurfelPredicate&gt; FrontierContainer;</div><div class="line">  <span class="keyword">typedef</span> DigitalSurface&lt;FrontierContainer&gt; Frontier;</div><div class="line">  <span class="keyword">typedef</span> functors::BoundaryPredicate&lt;KSpace, Image&gt; BSurfelPredicate;</div><div class="line">  <span class="keyword">typedef</span> ExplicitDigitalSurface&lt;KSpace,BSurfelPredicate&gt; BoundaryContainer;</div><div class="line">  <span class="keyword">typedef</span> DigitalSurface&lt;BoundaryContainer&gt; Boundary;</div><div class="line">  <span class="comment">// frontier between label 1 and 0 (connected part containing bel10)</span></div><div class="line">  SCell vox1  = K.sSpel( c1 + Point( radius1 - 1, 0, 0 ), K.POS );</div><div class="line">  SCell bel10 = K.sIncident( vox1, 0, <span class="keyword">true</span> );</div><div class="line">  FSurfelPredicate surfPredicate10( K, image, 1, 0 );</div><div class="line">  Frontier frontier10 =</div><div class="line">    <span class="keyword">new</span> FrontierContainer( K, surfPredicate10, surfAdj, bel10 );</div><div class="line">  <span class="comment">// frontier between label 2 and 0 (connected part containing bel20)</span></div><div class="line">  SCell vox2  = K.sSpel( c2 - Point( radius2 - 1, 0, 0 ), K.POS );</div><div class="line">  SCell bel20 = K.sIncident( vox2, 0, <span class="keyword">false</span> );</div><div class="line">  FSurfelPredicate surfPredicate20( K, image, 2, 0 );</div><div class="line">  Frontier frontier20 =</div><div class="line">    <span class="keyword">new</span> FrontierContainer( K, surfPredicate20, surfAdj, bel20 );</div><div class="line">  <span class="comment">// boundary of label 3 (connected part containing bel32)</span></div><div class="line">  SCell vox3  = K.sSpel( c1 - Point( radius1 - 1, 0, 0 ), K.POS );</div><div class="line">  SCell bel32 = K.sIncident( vox3, 0, <span class="keyword">false</span> );</div><div class="line">  BSurfelPredicate surfPredicate3( K, image, 3 );</div><div class="line">  Boundary boundary3 =</div><div class="line">    <span class="keyword">new</span> BoundaryContainer( K, surfPredicate3, surfAdj, bel32 );</div><div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">endBlock</a>();</div></div><!-- fragment --><p> Running it give the pictures: </p><div class="image">
<img src="digital-surface-intersecting-balls.png" alt="digital-surface-intersecting-balls.png"/>
<div class="caption">
Frontiers and boundary of two intersecting balls. The first ball is labelled 1 (red), the second 2 (yellow), their intersection 3 (orange). The frontier between 1 and 0 is displayed in red, the frontier between 2 and 0 is displayed in yellow, the boundary of region 3 is displayed in orange.</div></div>
<h1><a class="anchor" id="dgtal_digsurf_sec4"></a>
The digital surface graph is a combinatorial manifold</h1>
<h2><a class="anchor" id="dgtal_digsurf_sec4_1"></a>
Umbrellas and faces</h2>
<p>We have shown before that a digital surface has a dual structure that is the graph whose vertices are n-1-cells and whose arcs are (almost) n-2-cells. We can go further and use n-3-cells to define faces on this graph. This is related to the concept of <b>umbrellas</b> in 3D (see [Franon]). More precisely, given a start surfel, an incident n-2-cell (the separator) and an incident n-3-cell (the pivot), one can turn around the pivot progressively to get a face. This gives precisely in 3D the dual to a digital surface that is a kind of marching-cube surface (see [Lachaud:1998-icip, Lachaud:2000-gmod]).</p>
<p>The main class for computing umbrellas is the class <a class="el" href="classDGtal_1_1UmbrellaComputer.html" title="Aim: Useful for computing umbrellas on &#39;DigitalSurface&#39;s, ie set of n-1 cells around a n-3 cell...">UmbrellaComputer</a>. Turning around the pivot means moving the face and the separator once (in the track direction), such that the pivot is the same (ie <em>+p</em>), the track and separator directions being updated. Repeating this process a sufficient number of times brings the umbrella back in its original position, except in the case when the <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a> has a boundary touching the pivot. You may use it to compute umbrellas given a tracker on your surface.</p>
<p>You may look at file <a class="el" href="testUmbrellaComputer_8cpp_source.html">testUmbrellaComputer.cpp</a> to see how to use this class directly.</p>
<h2><a class="anchor" id="dgtal_digsurf_sec4_2"></a>
Vertices, arcs and faces on a digital surface</h2>
<p>However, it is simpler to use directly the methods defined in <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>. It offers three types: <a class="el" href="classDGtal_1_1DigitalSurface.html#a637f8034aff12a2f65fe9cc47c95b8db" title="Defines the type for a vertex. ">DigitalSurface::Vertex</a>, <a class="el" href="structDGtal_1_1DigitalSurface_1_1Arc.html">DigitalSurface::Arc</a>, <a class="el" href="structDGtal_1_1DigitalSurface_1_1Face.html">DigitalSurface::Face</a> to get the combinatorial structure of the surface. An arc is an oriented edge, a face is a sequence of edges that is closed when the pivot is not on the boundary and open otherwise.</p>
<p>The following code lists the faces of a <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a> object, and for each face it lists the coordinates of its vertices.</p>
<div class="fragment"><div class="line"><span class="comment">// MyDigitalSurface is a DigitalSurface realization.</span></div><div class="line"><span class="comment">// digSurf is any object of type MyDigitalSurface. </span></div><div class="line"><span class="comment">// K is a cellular space. </span></div><div class="line"><a class="code" href="classDGtal_1_1DigitalSurface.html#aca5daf921da1f67b921cfc109f2dbb20">MyDigitalSurface::FaceSet</a> all_faces = digSurf.allFaces();</div><div class="line"><span class="keywordflow">for</span> ( MyDigitalSurface::FaceSet::const_iterator it = all_faces.begin(),</div><div class="line"> it_end = all_faces.end(); it != it_end; ++it )</div><div class="line"> {</div><div class="line">std::cerr &lt;&lt; <span class="stringliteral">&quot; face=&quot;</span> &lt;&lt; K.sKCoords( digSurf.pivot( *it ) ) &lt;&lt; <span class="stringliteral">&quot;:&quot;</span>;</div><div class="line">std::cerr &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; it-&gt;nbVertices &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; (it-&gt;isClosed() ? <span class="stringliteral">&quot;C&quot;</span>: <span class="stringliteral">&quot;O&quot;</span>);</div><div class="line"><a class="code" href="classDGtal_1_1DigitalSurface.html#a7bbab2b7e1bedf06738f5151d1157b37">MyDigitalSurface::VertexRange</a> vtx = digSurf.verticesAroundFace( *it );</div><div class="line"><span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; vtx.size(); ++i )</div><div class="line">  {</div><div class="line"> std::cerr &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; K.sKCoords( vtx[ i ] );</div><div class="line">  }</div><div class="line">std::cerr &lt;&lt; std::endl;</div><div class="line"> }</div></div><!-- fragment --><p><a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a> provides you with many methods to get faces from edges or vertices and reciprocally.</p>
<ul>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#a3ea01c391c37a306943bf16fd2f61086">DigitalSurface::outArcs</a> (Vertex): the range of outgoing arcs from the given vertex.</li>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#ae8376390d87b57b7133ef500cef16929">DigitalSurface::inArcs</a> (Vertex): the range of ingoing arcs from the given vertex.</li>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#acb6678fa39068f61e410d41a0c6fc869">DigitalSurface::facesAroundVertex</a> (Vertex): the range of faces containing this vertex [v]: 0 in 2D, 4 in 3D, 12 in 4D, 2(n-1)(n-2) in nD.</li>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#a98e697e7fb96a8dd93d367e35395ae0a">DigitalSurface::head</a> (Arc): the head vertex of the given arc</li>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#a534419944bdb0c9e279097192d9f3450">DigitalSurface::tail</a> (Arc): the tail vertex of the given arc</li>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#aa32a9a704382fe028d519bdc3e812149">DigitalSurface::opposite</a> (Arc): the opposite arc of the given arc (may not exist if the arc lies on some boundary).</li>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#a49bd765d5b598cbba9aa49753852b753">DigitalSurface::arc</a> (Vertex,Vertex): the arc from the first vertex toward the second.</li>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#a8c7992abb25c469f7b02e11a05d03869">DigitalSurface::facesAroundArc</a> (Arc): the range of faces incident to a given arc. Empty in 2D. 1 face in 3D, 2 in 4D and so one, n-2 in nD. Returned faces may be open.</li>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#a6f4b8d016b2104de1e251f3752de3633">DigitalSurface::verticesAroundFace</a> (Face): the sequence of vertices that touches this face. The order follows the order of incident arcs.</li>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#a565e293101e152d850a8fcf4cd92aa9e">DigitalSurface::allFaces</a> (): the set of all faces of the digital surface (open and closed faces).</li>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#a41e4a590553eca228cf34fc231ddc22d">DigitalSurface::allClosedFaces</a> (): the set of all closed faces of the digital surface.</li>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#a393c2945be95ecf087bf8648306e661a">DigitalSurface::allOpenFaces</a> (): the set of all open faces of the digital surface.</li>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#aa44e576b921a434fc8ff4daf57b4841e">DigitalSurface::computeFace</a> ( <a class="el" href="structDGtal_1_1UmbrellaComputer_1_1State.html">UmbrellaComputer::State</a> ): compute the face from a given umbrella state.</li>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#a506e74d6f41277856a9c3ed7dd9ab6a1">DigitalSurface::separator</a> ( Arc ): the separator of a given arc (the n-2-cell between the two surfels forming the arc).</li>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#a2ef52ac13cb8aa90be64e368e5430ef0">DigitalSurface::pivot</a> ( Face ): the positively oriented n-3-cell that is the pivot of the face.</li>
</ul>
<h2><a class="anchor" id="dgtal_digsurf_sec4_3"></a>
Application to export surface in OFF format</h2>
<p>In 3D, you may use faces to transform an arbitrary digital surface into a polygonal manifold (closed or open). You can for instance directly the method <a class="el" href="classDGtal_1_1DigitalSurface.html#a0ca3aa0e577cb37f684345dfa5dee23d">DigitalSurface::exportSurfaceAs3DOFF</a> to do so, or look at its code to see how it works.</p>
<p>The following snippets of file <a class="el" href="volToOFF_8cpp_source.html">volToOFF.cpp</a> show how to extract all surfels in an image and then how to export the surface in OFF format. The output is a surface that is very much the classical <b>marching-cube</b> surface, except that vertices lies in the middle of the edge.</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a>( <span class="stringliteral">&quot;Extracting boundary by scanning the space. &quot;</span> );</div><div class="line">  <span class="keyword">typedef</span> KSpace::SurfelSet SurfelSet;</div><div class="line">  <span class="keyword">typedef</span> SetOfSurfels&lt; KSpace, SurfelSet &gt; MySetOfSurfels;</div><div class="line">  <span class="keyword">typedef</span> DigitalSurface&lt; MySetOfSurfels &gt; MyDigitalSurface;</div><div class="line"></div><div class="line">  MySetOfSurfels theSetOfSurfels( K, surfAdj );</div><div class="line">  <a class="code" href="classDGtal_1_1Surfaces.html#af61619b3dbd948aea387202369bddd6f">Surfaces&lt;KSpace&gt;::sMakeBoundary</a>( theSetOfSurfels.surfelSet(),</div><div class="line">                                   K, set3d,</div><div class="line">                                   image.domain().lowerBound(),</div><div class="line">                                   image.domain().upperBound() );</div><div class="line">  MyDigitalSurface digSurf( theSetOfSurfels );</div><div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;Digital surface has &quot;</span> &lt;&lt; digSurf.size() &lt;&lt; <span class="stringliteral">&quot; surfels.&quot;</span></div><div class="line">               &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">endBlock</a>();</div></div><!-- fragment --><div class="fragment"><div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a>( <span class="stringliteral">&quot;Making OFF surface &lt;marching-cube.off&gt;. &quot;</span> );</div><div class="line">  ofstream out( <span class="stringliteral">&quot;marching-cube.off&quot;</span> );</div><div class="line">  <span class="keywordflow">if</span> ( out.good() )</div><div class="line">    digSurf.exportSurfaceAs3DOFF( out );</div><div class="line">  out.close();</div><div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">endBlock</a>();</div></div><!-- fragment --> <div class="image">
<img src="digital-surface-mc-cat10.png" alt="digital-surface-mc-cat10.png"/>
<div class="caption">
Marching-cube surface of cat10.vol file.</div></div>
 <div class="image">
<img src="digital-surface-mc-lobster.png" alt="digital-surface-mc-lobster.png"/>
<div class="caption">
Marching-cube surface of lobster.vol file.</div></div>
 </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 22 2016 21:11:47 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
