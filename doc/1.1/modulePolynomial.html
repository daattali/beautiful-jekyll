<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Multivariate polynomials</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Multivariate polynomials </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#dgtal_mpolynomial_sec1">Multivariate polynomial</a><ul><li class="level2"><a href="#dgtal_mpolynomial_sec1_1">What is a multivariate polynomial ?</a></li>
<li class="level2"><a href="#dgtal_mpolynomial_sec1_2">The class MPolynomial</a></li>
<li class="level2"><a href="#dgtal_mpolynomial_sec1_3">Interface of the class MPolynomial</a></li>
<li class="level2"><a href="#dgtal_mpolynomial_sec1_4">How monomials and coefficients are stored ?</a></li>
<li class="level2"><a href="#dgtal_mpolynomial_sec1_5">Computing partial derivatives</a></li>
<li class="level2"><a href="#dgtal_mpolynomial_sec1_6">Computing euclidean division and greatest commond divisor (gcd)</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtal_mpolynomial_sec2">Efficiency considerations.</a><ul><li class="level2"><a href="#dgtal_mpolynomial_sec2_1">Best suited polynomials</a></li>
<li class="level2"><a href="#dgtal_mpolynomial_sec2_2">Repetitive evaluations in space</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtal_mpolynomial_sec3">Input and output for multivariate polynomials</a></li>
<li class="level1"><a href="#dgtal_mpolynomial_sec4">Displaying implicit 3-variate polynomials</a></li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>Felix Fontein, Jacques-Olivier Lachaud</dd></dl>
<dl class="section since"><dt>Since</dt><dd>0.5</dd></dl>
<p><b>LICENSE:</b> LGPL</p>
<p>Part of <a class="el" href="packageMath.html">Mathematical package</a>.</p>
<p><b>Module</b> <b>Overview</b> </p>
<p>This module provides classes to represent polynomials, like \( x^3-3x-1 \), and multi-variate polynomials, like \( xy^2-yz \), \( x^4-y^2z^2+z^4 \), etc. The number of variables is fixed at compilation time. Essentially, a n-variate polynomial is defined as a standard polynomial whose coefficients are n-1-variate polynomials.</p>
<p>The following examples are related to this module:</p><ul>
<li><a class="el" href="polynomial-derivative_8cpp.html">polynomial-derivative.cpp</a>, <a class="el" href="polynomial2-derivative_8cpp.html">polynomial2-derivative.cpp</a>.</li>
<li><a class="el" href="trackImplicitPolynomialSurfaceToOFF_8cpp.html">trackImplicitPolynomialSurfaceToOFF.cpp</a></li>
</ul>
<h1><a class="anchor" id="dgtal_mpolynomial_sec1"></a>
Multivariate polynomial</h1>
<h2><a class="anchor" id="dgtal_mpolynomial_sec1_1"></a>
What is a multivariate polynomial ?</h2>
<p>A <em>multivariate</em> <em>monomial</em> is a product of powers of zero, one or several variables, like \( 1, x, x^2, xy, y^3, xy^2z, x^4y^4z^4 \). Sometimes the coefficient in front of the monomial is also included in the definition of the monomial. A <em>multivariate</em> <em>polynomial</em> is a sum of products of a coefficient with a multivariate monomial.</p>
<p>A <em>polynomial</em> is a special case of multivariate polynomial where there is only one variable. The terms <em>variable</em> and <em>indeterminate</em> are synonymous. When you define a multivariate polynomial, you must precise its number of variables. The variables are numbered from 0 to <em>n</em> - 1, if <em>n</em> is the number of variables.</p>
<h2><a class="anchor" id="dgtal_mpolynomial_sec1_2"></a>
The class MPolynomial</h2>
<p>The class <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field.">MPolynomial</a> is the base class for representing arbitrary multivariate polynomials, i.e. an element of \( K[X_0, ..., X_{-1}] \), where <em>K</em> is some ring. The class MPolynomial&lt;n,K&gt; is parameterized by <em>n</em>, the number of indeterminates, and by <em>K</em>, the type of the coefficients, which should be at least a ring.</p>
<p>If you wish to declare a monovariate polynomial P1(x) over the <code>int</code> ring and a 2-variate polynomial P2(x,y) over the <code>double</code> field, you write the following lines:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/math/MPolynomial.h&quot;</span></div>
<div class="line">...</div>
<div class="line">MPolynomial&lt;1,<span class="keywordtype">int</span>&gt; P1;</div>
<div class="line">MPolynomial&lt;2,double&gt; P2;</div>
</div><!-- fragment --><p>In fact, the complete polynomial type is <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field.">MPolynomial</a> &lt;n, K, A&gt;, where A is an allocator for K, for example std::allocator&lt;K&gt;; this is also the default parameter. Usually this parameter does not need to be changed.</p>
<p>This is implemented recursively: <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field.">MPolynomial</a> &lt;n, K&gt; is a polynomial in one indeterminate with coefficients in <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field.">MPolynomial</a> &lt;n-1, K&gt;. The last instance, <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field.">MPolynomial</a> &lt;0, K&gt;, is essentially equal to K.</p>
<p>Generally, a multivariate polynomial is created by summing multivariate monomials and constants. The following snippet creates the 3-variate polynomial "durchblick", \( Pd(x,y,z) = x^3y+xz^3+y^3z+z^3+5z \). </p><div class="fragment"><div class="line">MPolynomial&lt;3, double&gt; Pd</div>
<div class="line">= mmonomial&lt;double&gt;( 3, 1, 0 )</div>
<div class="line">+ mmonomial&lt;double&gt;( 1, 0, 3 )</div>
<div class="line">+ mmonomial&lt;double&gt;( 0, 3, 1 )</div>
<div class="line">+ mmonomial&lt;double&gt;( 0, 0, 3 )</div>
<div class="line">+ 5 * mmonomial&lt;double&gt;( 0, 0, 1 );</div>
</div><!-- fragment --><p>A constant multivariate polynomial is created simply with: </p><div class="fragment"><div class="line">MPolynomial&lt;3, double&gt; Pc = 1.0;</div>
</div><!-- fragment --><p>Creation is thus accomplished using the functions mmonomial&lt;K, A&gt;(e_0, ..., e_{n-1}), where A again is std::allocator&lt;K&gt; by default. This creates a polynomial of type <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field.">MPolynomial</a> &lt;n, K, A&gt; which consists of exactly one monomial \( X_0^{e_0} * ... * X_{n-1}^{e_{n-1}}\) having coefficient 1.</p>
<p>Otherwise, polynomials are created through operations, derivations, etc.</p>
<h2><a class="anchor" id="dgtal_mpolynomial_sec1_3"></a>
Interface of the class MPolynomial</h2>
<p>Let us describe the interface:</p>
<ul>
<li><a class="el" href="classDGtal_1_1MPolynomial.html#aeba7a6693ecd495a5a3767a9d20bc425">MPolynomial::isZero</a>: Every polynomial has a predicate isZero(), testing whether the polynomial is the zero polynomial. Note that it is not the same to be a zero polynomial in <em>n</em> variables or to be a zero polynomial in <em>n'</em> variables, <em>n</em> != <em>n'</em>.</li>
<li>Moreover, it has basic arithmetic, i.e. addition, subtraction, multiplication; this is realized via operator overloading. Assignment and comparison operators are also provided.</li>
<li><a class="el" href="classDGtal_1_1MPolynomial.html#ad9825386ba929e7dedf2fa9ff0753516">MPolynomial::degree</a>, <a class="el" href="classDGtal_1_1MPolynomial.html#a96b1d905eeab7d77f23a8ccc59a22a40">MPolynomial::leading</a>: Polynomials have a degree function <code>degree()</code>, returning the degree as a polynomial in the first indeterminate, as well as a method <code>leading()</code>, returning the leading term (which is of type <code>const</code> <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field.">MPolynomial</a>&lt;n-1, K&gt; &amp;). Note that the degree of the zero polynomial is -1. For instance, \( 1 + xy^2 + x^4yz \) is a degree 4 polynomial in <em>x</em>. Its leading term is \( x^4yz \).</li>
</ul>
<div class="fragment"><div class="line">MPolynomial&lt;3, double&gt; Q = mmonomial&lt;double&gt;( 0, 0, 0 )</div>
<div class="line">+ mmonomial&lt;double&gt;( 1, 2, 0 ) + mmonomial&lt;double&gt;( 4, 1, 1 );</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Q(x,y,z)=1+xy^2+x^4yz = &quot;</span> &lt;&lt; Q &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot; degree = &quot;</span> &lt;&lt; Q.degree() &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot; leading= &quot;</span> &lt;&lt; Q.leading() &lt;&lt; std::endl;</div>
</div><!-- fragment --><pre class="fragment">Q(x,y,z)=1+xy^2+x^4yz = (1 + 1 X_1^2 X_0 + 1 X_2 X_1 X_0^4)
 degree = 4
 leading= 1 X_1 X_0
</pre><ul>
<li><p class="startli"><a class="el" href="classDGtal_1_1MPolynomial.html#a4e66d961247088815cbfde51c638ef9f">MPolynomial::operator[]</a>: The i-th coefficient can be obtained by writing f[i] if f is of type <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field.">MPolynomial</a> &lt;n, K&gt;; then f[i] is of type <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field.">MPolynomial</a> &lt;n - 1, K&gt;. In case i is larger than the degree of f, a zero polynomial will be returned, and in case f is not constant, the internal space for the coefficients will be enlarged to have space for the i-th coefficient. Note that one should call f.normalize() afterwards if one accessed f[i] for non-const f to ensure that degree and leading coefficients will be computed correctly afterwards. </p><pre class="fragment">@code
</pre><p> std::cout &lt;&lt; "         Q[0]         = " &lt;&lt; Q[ 0 ] &lt;&lt; std::endl; std::cout &lt;&lt; "         Q[1]         = " &lt;&lt; Q[ 1 ] &lt;&lt; std::endl; std::cout &lt;&lt; "         Q[2]         = " &lt;&lt; Q[ 2 ] &lt;&lt; std::endl; std::cout &lt;&lt; "         Q[3]         = " &lt;&lt; Q[ 3 ] &lt;&lt; std::endl; std::cout &lt;&lt; "         Q[4]         = " &lt;&lt; Q[ 4 ] &lt;&lt; std::endl; </p>
<p class="startli">You may notice that Q[i] are n-1-variate polynomials, i.e., x,y stands for the former y,z variables.</p>
</li>
</ul>
<pre class="fragment">         Q[0]         = 1
         Q[1]         = 1 X_0^2
         Q[2]         = 0
         Q[3]         = 0
         Q[4]         = 1 X_1 X_0</pre><ul>
<li>MPolynomial::operator(): The polynomial can be evaluated using operator(). If f is of type <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field.">MPolynomial</a> &lt;n, K, A&gt;, then f(x) with x of type S will return an object of type <a class="el" href="classDGtal_1_1MPolynomialEvaluator.html">MPolynomialEvaluator</a> &lt;n, K, A, S&gt;. This object can be casted to <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field.">MPolynomial</a> &lt;n-1, S&gt; to obtain f with the first indeterminate evaluated as x. Note that S must be a type to which elements of K can be casted. One can also continue evaluating with the <a class="el" href="classDGtal_1_1MPolynomialEvaluator.html">MPolynomialEvaluator</a> &lt;n, K, A, S&gt; object, yielding <a class="el" href="classDGtal_1_1MPolynomialEvaluatorImpl.html">MPolynomialEvaluatorImpl</a> &lt;k, K, ..., A, S&gt; objects, k &lt; n. These object hierarchy ensures that polynomial evaluation is efficient, i.e. after (good enough) optimization of the compiler, is essentially a block of code of (n-k+1) nested for-loops.</li>
</ul>
<pre class="fragment">double v = Q(1)(2)(3); // evaluation at (x,y,z)=(1,2,3)
</pre><ul>
<li>Polynomials can be written to std::ostream's using operator&lt;&lt;. There is also a member function MPolynomial::selfDisplay(std::ostream &amp;) const. Note that the first indeterminate in MPolynomial&lt;n, K&gt; is denoted by X_0, and the last by X_{n-1}.</li>
<li>Finally, there is a method <a class="el" href="namespaceDGtal.html#a446432667939719ccd514801eaebbf97">swap()</a> to swap two polynomial's contents. The polynomials have to be of the same type.This is for instance useful in some algorithms of the STL.</li>
</ul>
<h2><a class="anchor" id="dgtal_mpolynomial_sec1_4"></a>
How monomials and coefficients are stored ?</h2>
<p>The coefficients are stored in a std::vector&lt;K&gt;; while MPolynomial&lt;1, K&gt; uses std::vector&lt;K&gt;, MPolynomial&lt;n, K&gt; for n &gt; 1 uses std::vector &lt;<a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field.">MPolynomial</a>&lt;n-1, K&gt; *&gt;, i.e. pointers to coefficients are stored. This is implemented using the "intelligent" vector IVector&lt;K&gt; template.</p>
<h2><a class="anchor" id="dgtal_mpolynomial_sec1_5"></a>
Computing partial derivatives</h2>
<p>The library also offers to compute partial derivatives. Given a polynomial f of type MPolynomial&lt;n, K&gt;, one can compute the partial derivative with respect to the j-th variable of f by writing derivative&lt;j&gt;(f). Note that K is required to allow multiplication by int's for this to work.</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Q(x,y,z)=1+xy^2+x^4yz = &quot;</span> &lt;&lt; Q &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot; dQ/dx        = &quot;</span> &lt;&lt; derivative&lt;0&gt;(Q) &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;         dQ/dy        = &quot;</span> &lt;&lt; derivative&lt;1&gt;(Q) &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;         dQ/dz        = &quot;</span> &lt;&lt; derivative&lt;2&gt;(Q) &lt;&lt; std::endl;</div>
</div><!-- fragment --><pre class="fragment">Q(x,y,z)=1+xy^2+x^4yz = (1 + 1 X_1^2 X_0 + 1 X_2 X_1 X_0^4)
         dQ/dx        = (1 X_1^2 + 4 X_2 X_1 X_0^3) // y^2+4zyx^3
         dQ/dy        = (2 X_1 X_0 + 1 X_2 X_0^4)   // 2yx+zx^4
         dQ/dz        = 1 X_1 X_0^4                 // yx^4
</pre><p>You may have a look at example <a class="el" href="polynomial-derivative_8cpp.html">polynomial-derivative.cpp</a> to see how to get derivatives of simple polynomials:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/math/MPolynomial.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/io/readers/MPolynomialReader.h&quot;</span></div>
</div><!-- fragment --><div class="fragment"><div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">double</span> Ring;</div>
<div class="line">  <span class="keyword">typedef</span> MPolynomial&lt;1, Ring&gt; MyPolynomial;</div>
</div><!-- fragment --><div class="fragment"><div class="line">  std::string polynomialString( argv[ 1 ] );</div>
<div class="line">  std::istringstream polynomialIStream( polynomialString );</div>
<div class="line">  MyPolynomial P;</div>
<div class="line">  polynomialIStream &gt;&gt; P;</div>
<div class="line">  MyPolynomial P1 = derivative&lt;0&gt;( P );</div>
<div class="line">  MyPolynomial P2 = derivative&lt;0&gt;( P1 );</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;P(X_0)   = &quot;</span> &lt;&lt; P &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;P&#39;(X_0)  = &quot;</span> &lt;&lt; P1 &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;P&#39;&#39;(X_0) = &quot;</span> &lt;&lt; P2 &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> Along the same lines, the example <a class="el" href="polynomial2-derivative_8cpp.html">polynomial2-derivative.cpp</a> computes first- and second-order partial derivatives of a 2-variate polynomial.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/math/MPolynomial.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/io/readers/MPolynomialReader.h&quot;</span></div>
</div><!-- fragment --><div class="fragment"><div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">double</span> Ring;</div>
<div class="line">  <span class="keyword">typedef</span> MPolynomial&lt;2, Ring&gt; MyPolynomial;</div>
</div><!-- fragment --><div class="fragment"><div class="line">  std::string polynomialString( argv[ 1 ] );</div>
<div class="line">  std::istringstream polynomialIStream( polynomialString );</div>
<div class="line">  MyPolynomial P;</div>
<div class="line">  polynomialIStream &gt;&gt; P;</div>
<div class="line">  MyPolynomial P1_0 = derivative&lt;0&gt;( P );</div>
<div class="line">  MyPolynomial P2_0 = derivative&lt;0&gt;( P1_0 );</div>
<div class="line">  MyPolynomial P0_1 = derivative&lt;1&gt;( P );</div>
<div class="line">  MyPolynomial P0_2 = derivative&lt;1&gt;( P0_1 );</div>
<div class="line">  MyPolynomial P1_1 = derivative&lt;1&gt;( P1_0 );</div>
<div class="line">  MyPolynomial P1_1b= derivative&lt;0&gt;( P0_1 );</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;P(X_0,X_1)        = &quot;</span> &lt;&lt; P &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;dP/dX_0(X_0,X_1)  = &quot;</span> &lt;&lt; P1_0 &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;dP/dX_1(X_0,X_1)  = &quot;</span> &lt;&lt; P0_1 &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;d/dX_1 dP/dX_0(X_0,X_1) = &quot;</span> &lt;&lt; P1_1 &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;d/dX_0 dP/dX_1(X_0,X_1) = &quot;</span> &lt;&lt; P1_1b &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;d/dX_0 dP/dX_0(X_0,X_1) = &quot;</span> &lt;&lt; P2_0 &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;d/dX_1 dP/dX_1(X_0,X_1) = &quot;</span> &lt;&lt; P0_2 &lt;&lt; std::endl;</div>
</div><!-- fragment --><h2><a class="anchor" id="dgtal_mpolynomial_sec1_6"></a>
Computing euclidean division and greatest commond divisor (gcd)</h2>
<p>Finally, there exist functions <a class="el" href="namespaceDGtal.html#a2bbdffe7efc4f8af031964cecfe477a7">euclidDiv()</a> (parameters f, g, q, r), requiring parameters f, g of type const <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field.">MPolynomial</a> &lt;1, K&gt; &amp; and q, r of type <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field.">MPolynomial</a> &lt;1, K&gt; &amp;. This function computes q, r of f, g such that degree(r) &lt; degree(g) and f = q*g + r, i.e. it does long division of f by g, storing the quotient in q and the remainder in r. Note that <a class="el" href="namespaceDGtal.html#a2bbdffe7efc4f8af031964cecfe477a7">euclidDiv()</a> only works if K is a field, or if everything appearing is divisible by g.leading().</p>
<p>There is another function, <a class="el" href="namespaceDGtal.html#a38fc7e3a7ad4420d8b0b5950ae21c32e">gcd()</a> (parameters f, g), accepting f, g of type const <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field.">MPolynomial</a> &lt;1, K&gt; &amp; and returning a <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field.">MPolynomial</a> &lt;1, K&gt; object. It computes the monic greatest common divisor of f and g using the euclidean algorithm. In every step, the remainder is made monic. This function is ignoring potential round-off errors, and this function needs that K is (kind of) a field. Use with care.</p>
<h1><a class="anchor" id="dgtal_mpolynomial_sec2"></a>
Efficiency considerations.</h1>
<h2><a class="anchor" id="dgtal_mpolynomial_sec2_1"></a>
Best suited polynomials</h2>
<p>The class is tuned so as to be efficient for rather dense polynomials. More precisely, this class is not space nor time efficient for a polynomial like \( 1+x+x^{100000} \). This class is rather efficient for low-degree polynomials, even if there are many monomials. In fact, it factors the computation of the first variables.</p>
<p>For instance, \( x^2y^2+x^2z^2+x^4y^2z+x^4y^2z^3 \) is represented as \( x^2(1(z^2)+y^2(1))+x^4(y^2(z+z^3)) \). As one can see, \( x^2 \) is computed once, which is nice, but \( y^2 \) is computed twice. When you design a polynomial, you should choose the variable order well so as to choose the one that factors at best computations.</p>
<h2><a class="anchor" id="dgtal_mpolynomial_sec2_2"></a>
Repetitive evaluations in space</h2>
<p>Consider the following simple code, which integrates some information in cubic part of the space:</p>
<div class="fragment"><div class="line">MPolynomial&lt;3, double&gt; P = mmonomial&lt;double&gt;( 3, 1, 0 )</div>
<div class="line">  + mmonomial&lt;double&gt;( 1, 0, 3 )</div>
<div class="line">  + mmonomial&lt;double&gt;( 0, 3, 1 )</div>
<div class="line">  + mmonomial&lt;double&gt;( 0, 0, 3 )</div>
<div class="line">  + 5 * mmonomial&lt;double&gt;( 0, 0, 1 );</div>
<div class="line"><span class="keywordtype">double</span> total = 0.0;</div>
<div class="line"><span class="keywordflow">for</span> ( <span class="keywordtype">double</span> x = -1.0; x &lt; 1.0; x += step )</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> ( <span class="keywordtype">double</span> y = -1.0; y &lt; 1.0; y += step )</div>
<div class="line">      {</div>
<div class="line">        <span class="keywordflow">for</span> ( <span class="keywordtype">double</span> z = -1.0; z &lt; 1.0; z += step )</div>
<div class="line">          total += P(x)(y)(z);</div>
<div class="line">      }</div>
<div class="line">  }</div>
</div><!-- fragment --><p>This function takes 206ms for a step 0.01, for 8000000 evaluations.</p>
<p>In fact, you can factor evaluations of the first variables at the beginning of the inner loops. </p><div class="fragment"><div class="line">MPolynomial&lt;3, double&gt; P = <span class="comment">//...</span></div>
<div class="line">  <span class="keywordtype">double</span> total1 = 0.0;</div>
<div class="line">  <span class="keywordflow">for</span> ( <span class="keywordtype">double</span> x = -1.0; x &lt; 1.0; x += step )</div>
<div class="line">    {</div>
<div class="line">      MPolynomial&lt;2, double&gt; PX = P( x );</div>
<div class="line">      <span class="keywordflow">for</span> ( <span class="keywordtype">double</span> y = -1.0; y &lt; 1.0; y += step )</div>
<div class="line">        {</div>
<div class="line">          MPolynomial&lt;1, double&gt; PXY = PX( y );</div>
<div class="line">          <span class="keywordflow">for</span> ( <span class="keywordtype">double</span> z = -1.0; z &lt; 1.0; z += step )</div>
<div class="line">            total1 += PXY( z );</div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment --><p>This function takes 69ms for a step 0.01, for 8000000 evaluations. The C version where the function is explicitely compiled takes 22ms.</p>
<h1><a class="anchor" id="dgtal_mpolynomial_sec3"></a>
Input and output for multivariate polynomials</h1>
<p>You may simply output a polynomial an output stream with the usual operator&lt;&lt;.</p>
<div class="fragment"><div class="line">MPolynomial&lt;3,int&gt; Q = mmonomial&lt;int&gt;(0,0,0) + mmonomial&lt;int&gt;(1,2,0) + mmonomial&lt;int&gt;(4,1,1);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Q(x,y,z)=1+xy^2+x^4yz = &quot;</span> &lt;&lt; Q &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>You may also input a polynomial from an input stream with the usual operator&gt;&gt;. However, it is required to include file "MPolynomialReader.h".</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/io/readers/MPolynomialReader.h&quot;</span></div>
<div class="line">...</div>
<div class="line">string s = <span class="stringliteral">&quot;1+xy^2+x^4yz&quot;</span>.</div>
<div class="line">std::istringstream sin( s );</div>
<div class="line">MPolynomial&lt;3,int&gt; P;</div>
<div class="line">sin &gt;&gt; P;</div>
<div class="line"><a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;- Read &quot;</span> &lt;&lt; P &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>You may read successively several polynomials from the input stream: you just have to separate them with newlines. The input stream is read as long as the input is valid for the multivariate polynomial grammar.</p>
<p>If you wish to handle better error recovery when creating a polynomial, you can use the method <a class="el" href="classDGtal_1_1MPolynomialReader.html#ae015cb5a58c4b91d03a7428140d66181">MPolynomialReader::read</a> directly. You may look at example <a class="el" href="polynomial-read_8cpp.html">polynomial-read.cpp</a> for a more concrete example.</p>
<p>In input, you may write the variables either simply <code>x</code>, <code>y</code>, <code>z</code>, <code>t</code> for the first four variables, or more generically <code>X_0</code>, <code>X_1</code>, ..., <code>X_m</code>, where <code>m</code> is an integer number that is smaller than the number of variables of the polynomial.</p>
<p>For instance, you may test <a class="el" href="polynomial-derivative_8cpp.html">polynomial-derivative.cpp</a> and <a class="el" href="polynomial2-derivative_8cpp.html">polynomial2-derivative.cpp</a> as follows:</p>
<pre class="fragment">$ ./examples/math/polynomial-derivative "1+x+x^2-3*x^4"
P(X_0)   = (1 + 1 X_0 + 1 X_0^2 + -3 X_0^4)
P'(X_0)  = (1 + 2 X_0 + -12 X_0^3)
P''(X_0) = (2 + -36 X_0^2)
$ ./examples/math/polynomial-derivative "(2 + -36 X_0^2)"
P(X_0)   = (2 + -36 X_0^2)
P'(X_0)  = -72 X_0
P''(X_0) = -72
</pre><pre class="fragment">$ ./examples/math/polynomial2-derivative "(x-3)^2 + (y-2)^2 - 4"
P(X_0,X_1)        = ((9 + -4 X_1 + 1 X_1^2) + -6 X_0 + 1 X_0^2)
dP/dX_0(X_0,X_1)  = (-6 + 2 X_0)
dP/dX_1(X_0,X_1)  = (-4 + 2 X_1)
d/dX_1 dP/dX_0(X_0,X_1) = 0
d/dX_0 dP/dX_1(X_0,X_1) = 0
d/dX_0 dP/dX_0(X_0,X_1) = 2
d/dX_1 dP/dX_1(X_0,X_1) = 2
</pre><h1><a class="anchor" id="dgtal_mpolynomial_sec4"></a>
Displaying implicit 3-variate polynomials</h1>
<p>If you wish to display surfaces defined as 0-locii of polynomials \( P(x,y,z) \), then you may have a look at example <a class="el" href="trackImplicitPolynomialSurfaceToOFF_8cpp.html">trackImplicitPolynomialSurfaceToOFF.cpp</a>. The following program extract a linear approximation of the given polynomial as a triangulated surface in OFF format.</p>
<pre class="fragment">$ ./examples/topology/trackImplicitPolynomialSurfaceToOFF "(x^2+y^2+2*z^2-1)*(z^2x-0.1)" -2 -2 -2 2 2 2 0.02
# Digital surface has 112826 surfels.
# output in marching-cube.off (in 1809ms)
# You may display it with your favorite OFF displayer (like geomview, etc).
$ ctmviewer marching-cube.off
</pre><div class="image">
<img src="nice-mpolynomial.png" alt=""/>
<div class="caption">
Implicit polynomial surface (x^2+y^2+2*z^2-1)*(z^2x-0.1) between [-2,-2,-2] and [2,2,2], step 0.02.</div></div>
 <dl class="section see"><dt>See also</dt><dd><a class="el" href="polynomial-read_8cpp.html">polynomial-read.cpp</a>, <a class="el" href="polynomial-derivative_8cpp.html">polynomial-derivative.cpp</a>, <a class="el" href="polynomial2-derivative_8cpp.html">polynomial2-derivative.cpp</a>. </dd>
<dd>
<a class="el" href="trackImplicitPolynomialSurfaceToOFF_8cpp.html">trackImplicitPolynomialSurfaceToOFF.cpp</a>. </dd>
<dd>
<a class="el" href="testMPolynomial_8cpp.html">testMPolynomial.cpp</a>, <a class="el" href="testMPolynomialReader_8cpp.html">testMPolynomialReader.cpp</a>. </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="anamespaceDGtal_html_a8fc7012708b0416880a5c8b12dfdf9dd"><div class="ttname"><a href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">DGtal::trace</a></div><div class="ttdeci">Trace trace</div><div class="ttdef"><b>Definition:</b> <a href="Common_8h_source.html#l00150">Common.h:150</a></div></div>
<div class="ttc" id="aclassDGtal_1_1Trace_html_ad054990834d2763627166540087a2980"><div class="ttname"><a href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">DGtal::Trace::info</a></div><div class="ttdeci">std::ostream &amp; info()</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 6 2020 14:17:08 for DGtal by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
