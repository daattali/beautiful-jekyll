<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Plane recognition and plane width computation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Plane recognition and plane width computation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#modulePlaneRecognition_sec1">Planarity as a parallel strip</a><ul><li class="level2"><a href="#modulePlaneRecognition_sec11">Definition of parallel strip</a></li>
<li class="level2"><a href="#modulePlaneRecognition_sec12">Naive digital planes</a></li>
<li class="level2"><a href="#modulePlaneRecognition_sec13">Standard digital planes</a></li>
</ul>
</li>
<li class="level1"><a href="#modulePlaneRecognition_sec2">Naive digital plane recognition (and naive planes with rational width)</a><ul><li class="level2"><a href="#modulePlaneRecognition_sec21">Naive plane recognition (known axis) with COBA algorithm</a></li>
<li class="level2"><a href="#modulePlaneRecognition_sec22">Naive plane recognition (known axis) with Chord algorithm</a></li>
<li class="level2"><a href="#modulePlaneRecognition_sec23">Naive plane recognition (unknown axis) with COBA algorithm</a></li>
<li class="level2"><a href="#modulePlaneRecognition_sec24">Naive plane recognition (unknown axis) with Chord algorithm</a></li>
<li class="level2"><a href="#modulePlaneRecognition_sec25">Standard plane recognition with COBA algorithm</a></li>
<li class="level2"><a href="#modulePlaneRecognition_sec26">Standard plane recognition with Chord algorithm</a></li>
</ul>
</li>
<li class="level1"><a href="#modulePlaneRecognition_sec3">Incremental or additive plane recognition</a><ul><li class="level2"><a href="#modulePlaneRecognition_sec31">Incremental plane recognition</a></li>
<li class="level2"><a href="#modulePlaneRecognition_sec32">Additive plane recognition</a></li>
</ul>
</li>
<li class="level1"><a href="#modulePlaneRecognition_sec4">Width of a set of points</a></li>
<li class="level1"><a href="#modulePlaneRecognition_sec5">Comparative evaluation of COBA and Chord algorithm</a></li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>Jacques-Olivier Lachaud</dd></dl>
<p>Part of the <a class="el" href="packageGeometry.html">Geometry package</a>.</p>
<p>This part of the manual describes classes and functions related to the planarity of a set of points in 3D. For instance, it provides solutions to the following problems:</p>
<ul>
<li><b>planarity</b> <b>decision:</b> checks whether or not a given set of (digital or not) points belongs to a parallel strip of specified width. Strips may be specified with an <em>axis</em> <em>width</em> (like <em>naive</em> planes) or with a <em>diagonal</em> <em>width</em> (like <em>standard</em> <em>planes</em>).</li>
<li><b>plane</b> <b>recognition:</b> decide if a given set of (digital or not) points is planar and provides an explicit solution (i.e. gives the normal and shift of some parallel strip containing all the points).</li>
<li><b>incremental</b> or <b>additive</b> <b>plane</b> <b>recognition:</b> same as above, except that planarity of points can be checked progressively by adding points one at a time (incremental) or by groups (additive).</li>
<li><b>width</b> <b>computation:</b> computes the minimal width of a parallel strip that containes a given set of (digital or not) points.</li>
</ul>
<p>This module thus extends to the 3D case the recognition of <b>digital</b> <b>straight</b> <b>segments</b> and of <b>blurred</b> <b>segments</b>.</p>
<p>For now, these problems are solved thanks to two algorithms: the COBA algorithm by Charrier and Buzer <a class="el" href="citelist.html#CITEREF_Charrier_2008_dgci">[20]</a> and the Chord algorithm by Gerard, Debled-Rennesson and Zimmermann <a class="el" href="citelist.html#CITEREF_Gerard_2005_dam">[48]</a> .</p>
<p>More precisely, these modules tackle <em>naive</em> <em>digital</em> <em>planes</em> (with or without a specified axis) and <em>digital</em> <em>planes</em> of arbitrary <em>rational</em> <em>axis</em> <em>width</em>.</p>
<dl class="section note"><dt>Note</dt><dd>A current limitation is that these algorithms do not compute the <em>minimal</em> characteristics of the digital plane containing the input points, but only a valid parallel strip of approximated normal.</dd></dl>
<p>Related examples are <a class="el" href="viewer3D-7-planes_8cpp.html">viewer3D-7-planes.cpp</a>, <a class="el" href="viewer3D-7bis-planes_8cpp.html">viewer3D-7bis-planes.cpp</a>, <a class="el" href="viewer3D-7-stdplane_8cpp.html">viewer3D-7-stdplane.cpp</a>, <a class="el" href="greedy-plane-segmentation_8cpp.html">greedy-plane-segmentation.cpp</a>, <a class="el" href="greedy-plane-segmentation-ex2_8cpp.html">greedy-plane-segmentation-ex2.cpp</a>.</p>
<h1><a class="anchor" id="modulePlaneRecognition_sec1"></a>
Planarity as a parallel strip</h1>
<h2><a class="anchor" id="modulePlaneRecognition_sec11"></a>
Definition of parallel strip</h2>
<p>A <b>parallel</b> <b>strip</b> is the intersection of two parallel half-planes such that each half-plane includes the other. Half-planes may be closed or open. Hence, parallel strips take one of the following form:</p>
<ul>
<li>\( \mu \le \vec{N} \cdot \vec{X} \le \mu + \epsilon \), class <a class="el" href="classDGtal_1_1ParallelStrip.html">ParallelStrip&lt;Space, true, true&gt;</a></li>
<li>\( \mu \le \vec{N} \cdot \vec{X} &lt; \mu + \epsilon \), class <a class="el" href="classDGtal_1_1ParallelStrip.html">ParallelStrip&lt;Space, true, false&gt;</a></li>
<li>\( \mu &lt; \vec{N} \cdot \vec{X} \le \mu + \epsilon \), class <a class="el" href="classDGtal_1_1ParallelStrip.html">ParallelStrip&lt;Space, false, true&gt;</a></li>
<li>\( \mu &lt; \vec{N} \cdot \vec{X} &lt; \mu + \epsilon \), class <a class="el" href="classDGtal_1_1ParallelStrip.html">ParallelStrip&lt;Space, false, false&gt;</a></li>
</ul>
<p>Here are a few useful definitions:</p>
<ul>
<li>The <b>normal</b> to the strip is the vector <em>N</em>, which is a unit vector in the class <a class="el" href="classDGtal_1_1ParallelStrip.html">ParallelStrip</a>.</li>
<li>The <b>width</b> of the strip is the scalar \(\epsilon\).</li>
<li>The <b>axis</b> <b>width</b> of the strip is the quantity \(|\epsilon / N_i|\) where \(|N_i|\) is the greatest component. The <b>main</b> <b>axis</b> is the <em>i-th</em> axis.</li>
<li>The <b>diagonal</b> <b>width</b> is the quantity \( \frac{\epsilon \sqrt{n}}{\|N\|_1} \), where <em>n</em> is the dimension of the space. The <b>main</b> <b>diagonal</b> is the vector \(( \pm 1, \ldots, \pm 1) \), where the \( \pm 1 \) are the signs of the components of <b>N</b>.</li>
</ul>
<p>Digital planes are specific cases of parallel strips. We give below their 3D definitions, but their <em>n-dimensional</em> definition is straightforward.</p>
<h2><a class="anchor" id="modulePlaneRecognition_sec12"></a>
Naive digital planes</h2>
<p>A <b>naive</b> <b>digital</b> <b>plane</b> is a set of digital points \((x,y,z) \in Z^3\) such that \( d \le ax+by+cz &lt; d + \omega \), with <em>a</em>, <em>b</em>, <em>c</em> integer numbers and \( \omega = \max(|a|,|b|,|c|) \).</p>
<p>It is easily seen that naive planes are parallel strips of <em>axis</em> <em>width</em> strictly smaller than 1, by a simple division of both inequalities by \(\omega\).</p>
<h2><a class="anchor" id="modulePlaneRecognition_sec13"></a>
Standard digital planes</h2>
<p>A <b>standard</b> <b>digital</b> <b>plane</b> is a set of digital points \((x,y,z) \in Z^3\) such that \( d \le ax+by+cz &lt; d + \omega \), with <em>a</em>, <em>b</em>, <em>c</em> integer numbers and \( \omega = |a|+|b|+|c| \).</p>
<p>It is easily seen that standard planes are parallel strips of <em>diagonal</em> <em>width</em> strictly smaller than \( \sqrt{3} \), by a simple division of both inequalities by \(\sqrt{a^2+b^2+c^2}\).</p>
<h1><a class="anchor" id="modulePlaneRecognition_sec2"></a>
Naive digital plane recognition (and naive planes with rational width)</h1>
<p>Since plane recognition solves also planarity decision, we focus on plane recognition. Note that both COBA algorithm and Chord algorithm takes the same time for a planarity decision and for a plane recognition. In this section, the user specifies the (strict) maximal axis width as a rational p/q. Naive digital planes are thus specified by 1/1.</p>
<h2><a class="anchor" id="modulePlaneRecognition_sec21"></a>
Naive plane recognition (known axis) with COBA algorithm</h2>
<p>The user should instantiate a <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlaneComputer</a> with the appropriate digital space. The axis and the maximal axis width (as a rational number p/q) are specified by method <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html#a17098fa05c7e9cf548d69283410c10e2">COBANaivePlaneComputer::init</a>. The diameter of the set of points <em>S</em> <b>must</b> also be specified (i.e. \( \max_{p,q \in S} \|p-q\|_\infty \)). Then, method <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html#af2772a864766a21ee7ab9538c6c8d66e">COBANaivePlaneComputer::extend</a> is called with the appropriate range of points. The method <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html#a94c6724d2ad2161f569b8dfb8809e0fe">COBANaivePlaneComputer::primitive</a> returns the solution (if any) as parallel strip of axis width smaller than p/q.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/surfaces/COBANaivePlaneComputer.h&quot;</span></div>
<div class="line">...</div>
<div class="line">std::vector&lt;<a class="code" href="namespaceDGtal_1_1Z3i.html#a8d69892de6b10119a8070bd5d0871bf5">Z3i::Point</a>&gt; pts;       <span class="comment">// any container of 3D digital points</span></div>
<div class="line">...                                <span class="comment">// fill pts with your points</span></div>
<div class="line">COBANaivePlaneComputer&lt;Z3i::Space, int64_t&gt; plane; <span class="comment">// int64_t is enough for diameter 100</span></div>
<div class="line">plane.init( 2, 100, 1, 1 );        <span class="comment">// axis is z (2), diameter is 100, epsilon=1/1</span></div>
<div class="line"><span class="keywordtype">bool</span> isPlane = plane.extend( pts.begin(), pts.end() );</div>
<div class="line"><span class="keywordflow">if</span> ( isPlane )</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;This is a naive plane, well approximated by &quot;</span> &lt;&lt; plane.primitive() &lt;&lt; std::endl;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;This is a not naive plane.&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The second template parameter for class <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlaneComputer</a> gives the internal integer type for computation. Detailed explanations can be found in <a class="el" href="moduleCOBANaivePlaneRecognition.html">Detailed explanation of COBA plane recognition algorithm</a>. The type should be able to hold integers of order \((2D^3)^2\) if <em>D</em> is the diameter of the set of digital points. In practice, diameter is limited to 20 for <a class="el" href="namespaceDGtal.html#ac1e9ac6a329319ae13c51c0c9e92486a">int32_t</a>, diameter is approximately 500 for <a class="el" href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63">int64_t</a>, and whatever with <a class="el" href="namespaceDGtal.html#ad14cde66089fcbdefb20c819562d2a0d">BigInteger</a> / GMP integers. For huge diameters, the slow-down is polylogarithmic with respect to the diameter.</dd></dl>
<h2><a class="anchor" id="modulePlaneRecognition_sec22"></a>
Naive plane recognition (known axis) with Chord algorithm</h2>
<p>The user should instantiate a <a class="el" href="classDGtal_1_1ChordNaivePlaneComputer.html" title="Aim: A class that contains the chord-based algorithm for recognizing pieces of digital planes of give...">ChordNaivePlaneComputer</a> with the appropriate digital space. The axis and the maximal axis width (as a rational number p/q) are specified by method <a class="el" href="classDGtal_1_1ChordNaivePlaneComputer.html#a9359f5057958f7f792fa36d72a198ace">ChordNaivePlaneComputer::init</a>. Then, method <a class="el" href="classDGtal_1_1ChordNaivePlaneComputer.html#a1c83ed13e7a1b860a536f4d2f12a613a">ChordNaivePlaneComputer::extend</a> is called with the appropriate range of points. The method <a class="el" href="classDGtal_1_1ChordNaivePlaneComputer.html#a56b17b0c97b2a348d1b12c5ab1311beb">ChordNaivePlaneComputer::primitive</a> returns the solution (if any) as parallel strip of axis width smaller than p/q.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/surfaces/ChordNaivePlaneComputer.h&quot;</span></div>
<div class="line">...</div>
<div class="line">std::vector&lt;<a class="code" href="namespaceDGtal_1_1Z3i.html#a8d69892de6b10119a8070bd5d0871bf5">Z3i::Point</a>&gt; pts;       <span class="comment">// any container of 3D digital points</span></div>
<div class="line">...                                <span class="comment">// fill pts with your points</span></div>
<div class="line">ChordNaivePlaneComputer&lt;Z3i::Space, Z3i::Point, int64_t&gt; plane; <span class="comment">// int64_t is enough for diameter 440000000 !</span></div>
<div class="line">plane.init( 2, 1, 1 );        <span class="comment">// axis is z (2), epsilon=1/1</span></div>
<div class="line"><span class="keywordtype">bool</span> isPlane = plane.extend( pts.begin(), pts.end() );</div>
<div class="line"><span class="keywordflow">if</span> ( isPlane )</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;This is a naive plane, well approximated by &quot;</span> &lt;&lt; plane.primitive() &lt;&lt; std::endl;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;This is a not naive plane.&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The second template parameter of the class <a class="el" href="classDGtal_1_1ChordNaivePlaneComputer.html" title="Aim: A class that contains the chord-based algorithm for recognizing pieces of digital planes of give...">ChordNaivePlaneComputer</a> gives the type of input points. When recognizing digital planes, you shoud set it to <a class="el" href="classDGtal_1_1SpaceND.html#a34beb5f81d0848e8ae393f39a1422ebc" title="Points in DGtal::SpaceND.">Space::Point</a>, where Space is your digital space. Note that the Chord algorithm works also for real-valued points: in this case, you can specify another kind of Point like RealPoint.</dd>
<dd>
The third template parameter of the class <a class="el" href="classDGtal_1_1ChordNaivePlaneComputer.html" title="Aim: A class that contains the chord-based algorithm for recognizing pieces of digital planes of give...">ChordNaivePlaneComputer</a> gives the internal scalar (or integer) type for computation. If the input points are digital points, then this type should be integral and hold integers of order \((2D)^2\) if <em>D</em> is the diameter of the set of digital points. In practice, diameter is limited to 14000 for <a class="el" href="namespaceDGtal.html#ac1e9ac6a329319ae13c51c0c9e92486a">int32_t</a>, diameter is approximately 440000000 for <a class="el" href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63">int64_t</a>, and whatever with <a class="el" href="namespaceDGtal.html#ad14cde66089fcbdefb20c819562d2a0d" title="Multi-precision integer with GMP implementation.">DGtal::BigInteger</a> / GMP integers. For huge diameters, the slow-down is polylogarithmic with respect to the diameter. If the input points are not digital, you should provide a scalar type for intermediate computations (e.g. double).</dd></dl>
<h2><a class="anchor" id="modulePlaneRecognition_sec23"></a>
Naive plane recognition (unknown axis) with COBA algorithm</h2>
<p>The user should instantiate a <a class="el" href="classDGtal_1_1COBAGenericNaivePlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the width is 1,...">COBAGenericNaivePlaneComputer</a> with the appropriate digital space. The maximal axis width (as a rational number p/q) is specified by method <a class="el" href="classDGtal_1_1COBAGenericNaivePlaneComputer.html#aafeaade647f0bdb99ebf952e3b7203b8">COBAGenericNaivePlaneComputer::init</a>. The diameter of the set of points <em>S</em> <b>must</b> also be specified (i.e. \( \max_{p,q \in S} \|p-q\|_\infty \)). Then, method <a class="el" href="classDGtal_1_1COBAGenericNaivePlaneComputer.html#a5d92322a1cb00ea3d358496551a21ff5">COBAGenericNaivePlaneComputer::extend</a> is called with the appropriate range of points. The method <a class="el" href="classDGtal_1_1COBAGenericNaivePlaneComputer.html#a4e8953203fe2bcf26d29758e5cc3e9bc">COBAGenericNaivePlaneComputer::primitive</a> returns the solution (if any) as parallel strip of axis width smaller than p/q.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/surfaces/COBAGenericNaivePlaneComputer.h&quot;</span></div>
<div class="line">...</div>
<div class="line">std::vector&lt;<a class="code" href="namespaceDGtal_1_1Z3i.html#a8d69892de6b10119a8070bd5d0871bf5">Z3i::Point</a>&gt; pts;       <span class="comment">// any container of 3D digital points</span></div>
<div class="line">...                                <span class="comment">// fill pts with your points</span></div>
<div class="line">COBAGenericNaivePlaneComputer&lt;Z3i::Space, int64_t&gt; plane; <span class="comment">// int64_t is enough for diameter 100</span></div>
<div class="line">plane.init( 100, 1, 1 );           <span class="comment">// any axis, diameter is 100, epsilon=1/1</span></div>
<div class="line"><span class="keywordtype">bool</span> isPlane = plane.extend( pts.begin(), pts.end() );</div>
<div class="line"><span class="keywordflow">if</span> ( isPlane )</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;This is a naive plane, well approximated by &quot;</span> &lt;&lt; plane.primitive() &lt;&lt; std::endl;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;This is a not naive plane.&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>The advantage is that the object detects progressively what is the correct main axis. You may know what is a correct main axis by calling <a class="el" href="classDGtal_1_1COBAGenericNaivePlaneComputer.html#aeb0accb6c809179d0c1ea017169a847f">COBAGenericNaivePlaneComputer::active()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The principle of <a class="el" href="classDGtal_1_1COBAGenericNaivePlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the width is 1,...">COBAGenericNaivePlaneComputer</a> is to have three instances of <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlaneComputer</a> at the beginning, one per possible axis. When extending the object by adding points, all active instances are extended. If any one of the active instance fails, it is removed from the active instances. It is guaranteed that if there is a naive plane (of specified width) that contains the given set of points, then the object <a class="el" href="classDGtal_1_1COBAGenericNaivePlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the width is 1,...">COBAGenericNaivePlaneComputer</a> will have at least one active <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlaneComputer</a> instance. <a class="el" href="classDGtal_1_1COBAGenericNaivePlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the width is 1,...">COBAGenericNaivePlaneComputer</a> is thus a correct recognizer of arbitrary pieces of naive planes.</dd>
<dd>
Template parameters have the same role as for class <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlaneComputer</a> (see above).</dd></dl>
<h2><a class="anchor" id="modulePlaneRecognition_sec24"></a>
Naive plane recognition (unknown axis) with Chord algorithm</h2>
<p>The user should instantiate a <a class="el" href="classDGtal_1_1ChordGenericNaivePlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the width is 1,...">ChordGenericNaivePlaneComputer</a> with the appropriate digital space. The maximal axis width (as a rational number p/q) is specified by method <a class="el" href="classDGtal_1_1ChordGenericNaivePlaneComputer.html#a78cb3c6e8f2fa03acd1d16770caf9bc9">ChordGenericNaivePlaneComputer::init</a>. Then, method <a class="el" href="classDGtal_1_1ChordGenericNaivePlaneComputer.html#a7c103383880e323aa88fd7f5ec3d5511">ChordGenericNaivePlaneComputer::extend</a> is called with the appropriate range of points. The method <a class="el" href="classDGtal_1_1ChordGenericNaivePlaneComputer.html#a22f0df0c5f34aed38fa7577aa8ffafdf">ChordGenericNaivePlaneComputer::primitive</a> returns the solution (if any) as parallel strip of axis width smaller than p/q.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/surfaces/ChordGenericNaivePlaneComputer.h&quot;</span></div>
<div class="line">...</div>
<div class="line">std::vector&lt;<a class="code" href="namespaceDGtal_1_1Z3i.html#a8d69892de6b10119a8070bd5d0871bf5">Z3i::Point</a>&gt; pts;       <span class="comment">// any container of 3D digital points</span></div>
<div class="line">...                                <span class="comment">// fill pts with your points</span></div>
<div class="line">ChordGenericNaivePlaneComputer&lt;Z3i::Space, Z3i::Point, int64_t&gt; plane; <span class="comment">// int64_t is enough for diameter 440000000 !</span></div>
<div class="line">plane.init( 1, 1 );                <span class="comment">// epsilon=1/1</span></div>
<div class="line"><span class="keywordtype">bool</span> isPlane = plane.extend( pts.begin(), pts.end() );</div>
<div class="line"><span class="keywordflow">if</span> ( isPlane )</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;This is a naive plane, well approximated by &quot;</span> &lt;&lt; plane.primitive() &lt;&lt; std::endl;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;This is a not naive plane.&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>The advantage is that the object detects progressively what is the correct main axis. You may know what is a correct main axis by calling <a class="el" href="classDGtal_1_1ChordGenericNaivePlaneComputer.html#ac9c9ef474aec7c976e600ed09c5765bc">ChordGenericNaivePlaneComputer::active()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Similarly to <a class="el" href="classDGtal_1_1COBAGenericNaivePlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the width is 1,...">COBAGenericNaivePlaneComputer</a>, the principle of <a class="el" href="classDGtal_1_1ChordGenericNaivePlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the width is 1,...">ChordGenericNaivePlaneComputer</a> is to have three instances of <a class="el" href="classDGtal_1_1ChordNaivePlaneComputer.html" title="Aim: A class that contains the chord-based algorithm for recognizing pieces of digital planes of give...">ChordNaivePlaneComputer</a> at the beginning, one per possible axis.</dd></dl>
<h2><a class="anchor" id="modulePlaneRecognition_sec25"></a>
Standard plane recognition with COBA algorithm</h2>
<p>The user should instantiate a <a class="el" href="classDGtal_1_1COBAGenericStandardPlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the diagonal width is...">COBAGenericStandardPlaneComputer</a> with the appropriate digital space. The maximal diagonal width (as a rational number \(p/q \times \sqrt{3}\) ) is specified by method <a class="el" href="classDGtal_1_1COBAGenericStandardPlaneComputer.html#aad2a10a4ad1385baae0468bd03480943">COBAGenericStandardPlaneComputer::init</a>. The diameter of the set of points <em>S</em> <b>must</b> also be specified (i.e. \( \max_{p,q \in S} \|p-q\|_\infty \)). Then, method <a class="el" href="classDGtal_1_1COBAGenericStandardPlaneComputer.html#a7fe38f82dea6d5747b66ee8e7a58ddb2">COBAGenericStandardPlaneComputer::extend</a> is called with the appropriate range of points. The method <a class="el" href="classDGtal_1_1COBAGenericStandardPlaneComputer.html#aa23fd4fcadec9195a2dc5175b6c334c8">COBAGenericStandardPlaneComputer::primitive</a> returns the solution (if any) as parallel strip of axis width smaller than p/q.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/surfaces/COBAGenericStandardPlaneComputer.h&quot;</span></div>
<div class="line">...</div>
<div class="line">std::vector&lt;<a class="code" href="namespaceDGtal_1_1Z3i.html#a8d69892de6b10119a8070bd5d0871bf5">Z3i::Point</a>&gt; pts;       <span class="comment">// any container of 3D digital points</span></div>
<div class="line">...                                <span class="comment">// fill pts with your points</span></div>
<div class="line">COBAGenericStandardPlaneComputer&lt;Z3i::Space, int64_t&gt; plane; <span class="comment">// int64_t is enough for diameter 100</span></div>
<div class="line">plane.init( 100, 1, 1 );           <span class="comment">// any axis, diameter is 100, epsilon=1/1 x sqrt(3)</span></div>
<div class="line"><span class="keywordtype">bool</span> isPlane = plane.extend( pts.begin(), pts.end() );</div>
<div class="line"><span class="keywordflow">if</span> ( isPlane )</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;This is a standard plane, well approximated by &quot;</span> &lt;&lt; plane.primitive() &lt;&lt; std::endl;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;This is a not standard plane.&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>The advantage is that the object detects progressively what is the correct main diagonal. You may know what is a correct main diagonal by calling <a class="el" href="classDGtal_1_1COBAGenericStandardPlaneComputer.html#a2308fae9a3360d682f6ed32d14efa790">COBAGenericStandardPlaneComputer::active()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The principle of <a class="el" href="classDGtal_1_1COBAGenericNaivePlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the width is 1,...">COBAGenericNaivePlaneComputer</a> is to have four instances of <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlaneComputer</a> at the beginning, all of z axis. When extending the object by adding points, the points are transformed such as: \((x,y,z) \mapsto (x \pm z, y \pm z, z)\). We need four instances for the four possible sign combinations. It is guaranteed that if there is a naive plane (of specified width) that contains the given set of points, then it corresponds to a standard plane before the transformation. Then the object <a class="el" href="classDGtal_1_1COBAGenericStandardPlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the diagonal width is...">COBAGenericStandardPlaneComputer</a> will have at least one active <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlaneComputer</a> instance. <a class="el" href="classDGtal_1_1COBAGenericStandardPlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the diagonal width is...">COBAGenericStandardPlaneComputer</a> is thus a correct recognizer of arbitrary pieces of standard planes.</dd>
<dd>
Template parameters have the same role as for class <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlaneComputer</a> (see above).</dd></dl>
<h2><a class="anchor" id="modulePlaneRecognition_sec26"></a>
Standard plane recognition with Chord algorithm</h2>
<p>The user should instantiate a <a class="el" href="classDGtal_1_1ChordGenericStandardPlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given diagonal width. When the width is ,...">ChordGenericStandardPlaneComputer</a> with the appropriate digital space. The maximal diagonal width (as a rational number \(p/q \times \sqrt{3}\) ) is specified by method <a class="el" href="classDGtal_1_1ChordGenericStandardPlaneComputer.html#aa5d9b84f6df3cf8796680581fc1d9f7a">ChordGenericStandardPlaneComputer::init</a>. Then, method <a class="el" href="classDGtal_1_1ChordGenericStandardPlaneComputer.html#a4d70ccbf1b419b18e13aff8876f5dca6">ChordGenericStandardPlaneComputer::extend</a> is called with the appropriate range of points. The method <a class="el" href="classDGtal_1_1ChordGenericStandardPlaneComputer.html#a150d32f439af845e10241c6a0c75f0d8">ChordGenericStandardPlaneComputer::primitive</a> returns the solution (if any) as parallel strip of axis width smaller than p/q.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/surfaces/ChordGenericStandardPlaneComputer.h&quot;</span></div>
<div class="line">...</div>
<div class="line">std::vector&lt;<a class="code" href="namespaceDGtal_1_1Z3i.html#a8d69892de6b10119a8070bd5d0871bf5">Z3i::Point</a>&gt; pts;       <span class="comment">// any container of 3D digital points</span></div>
<div class="line">...                                <span class="comment">// fill pts with your points</span></div>
<div class="line">ChordGenericStandardPlaneComputer&lt;Z3i::Space, Z3i::Point, int64_t&gt; plane;</div>
<div class="line">plane.init( 1, 1 );                <span class="comment">// any axis, epsilon=1/1 x sqrt(3)</span></div>
<div class="line"><span class="keywordtype">bool</span> isPlane = plane.extend( pts.begin(), pts.end() );</div>
<div class="line"><span class="keywordflow">if</span> ( isPlane )</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;This is a standard plane, well approximated by &quot;</span> &lt;&lt; plane.primitive() &lt;&lt; std::endl;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;This is a not standard plane.&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>The advantage is that the object detects progressively what is the correct main diagonal. You may know what is a correct main diagonal by calling <a class="el" href="classDGtal_1_1ChordGenericStandardPlaneComputer.html#a065b02fa456ad06695ba6e2b4af27404">ChordGenericStandardPlaneComputer::active()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The principle of <a class="el" href="classDGtal_1_1ChordGenericNaivePlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the width is 1,...">ChordGenericNaivePlaneComputer</a> is to have four instances of <a class="el" href="classDGtal_1_1ChordNaivePlaneComputer.html" title="Aim: A class that contains the chord-based algorithm for recognizing pieces of digital planes of give...">ChordNaivePlaneComputer</a> at the beginning, all of z axis. When extending the object by adding points, the points are transformed such as: \((x,y,z) \mapsto (x \pm z, y \pm z, z)\). We need four instances for the four possible sign combinations. It is guaranteed that if there is a naive plane (of specified width) that contains the given set of points, then it corresponds to a standard plane before the transformation. Then the object <a class="el" href="classDGtal_1_1ChordGenericStandardPlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given diagonal width. When the width is ,...">ChordGenericStandardPlaneComputer</a> will have at least one active <a class="el" href="classDGtal_1_1ChordNaivePlaneComputer.html" title="Aim: A class that contains the chord-based algorithm for recognizing pieces of digital planes of give...">ChordNaivePlaneComputer</a> instance. <a class="el" href="classDGtal_1_1ChordGenericStandardPlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given diagonal width. When the width is ,...">ChordGenericStandardPlaneComputer</a> is thus a correct recognizer of arbitrary pieces of standard planes.</dd>
<dd>
Template parameters have the same role as for class <a class="el" href="classDGtal_1_1ChordNaivePlaneComputer.html" title="Aim: A class that contains the chord-based algorithm for recognizing pieces of digital planes of give...">ChordNaivePlaneComputer</a> (see above).</dd></dl>
<h1><a class="anchor" id="modulePlaneRecognition_sec3"></a>
Incremental or additive plane recognition</h1>
<p>Incremental and additive plane recognition are done in exactly the same way for all six classes <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlaneComputer</a>, <a class="el" href="classDGtal_1_1COBAGenericNaivePlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the width is 1,...">COBAGenericNaivePlaneComputer</a>, <a class="el" href="classDGtal_1_1COBAGenericStandardPlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the diagonal width is...">COBAGenericStandardPlaneComputer</a>, <a class="el" href="classDGtal_1_1ChordNaivePlaneComputer.html" title="Aim: A class that contains the chord-based algorithm for recognizing pieces of digital planes of give...">ChordNaivePlaneComputer</a>, <a class="el" href="classDGtal_1_1ChordGenericNaivePlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given axis width. When the width is 1,...">ChordGenericNaivePlaneComputer</a>, <a class="el" href="classDGtal_1_1ChordGenericStandardPlaneComputer.html" title="Aim: A class that recognizes pieces of digital planes of given diagonal width. When the width is ,...">ChordGenericStandardPlaneComputer</a>. They are illustrated in examples <a class="el" href="viewer3D-7-planes_8cpp.html">viewer3D-7-planes.cpp</a>, <a class="el" href="viewer3D-7bis-planes_8cpp.html">viewer3D-7bis-planes.cpp</a>, <a class="el" href="viewer3D-7-stdplane_8cpp.html">viewer3D-7-stdplane.cpp</a>, and <a class="el" href="viewer3D-7bis-stdplane_8cpp.html">viewer3D-7bis-stdplane.cpp</a>.</p>
<h2><a class="anchor" id="modulePlaneRecognition_sec31"></a>
Incremental plane recognition</h2>
<p>These six classes are models of <a class="el" href="structDGtal_1_1concepts_1_1CIncrementalPrimitiveComputer.html" title="Aim: Defines the concept describing an object that computes some primitive from input points given on...">concepts::CIncrementalPrimitiveComputer</a>. They all have an internal state that store a current parallel strip that contains all points previously inserted. Furthermore, they provide methods <b>extend</b>( <em>p</em> ) and <b>isExtendable</b>( <em>p</em> ) to insert a new point <em>p</em> and to check whether there is a some parallel strip that contains both the previously inserted points and the new point <em>p</em>.</p>
<ul>
<li><b>extend</b>( Point <em>p</em> ) : bool. Tries to add point <em>p</em> to the current plane computer. If it is possible, update potentially the parallel strip and returns true, otherwise returns false and the object is left <b>unchanged</b>.</li>
<li><b>isExtendable</b>( Point <em>p</em> ) : bool. Tries to add point <em>p</em> to the current plane computer. Returns true iff it is possible. The object is always left <b>unchanged</b>.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> ChordNaivePlaneComputer&lt;Z3i::Space, Z3i::Point, int32_t&gt; PlaneComputer;</div>
<div class="line"><span class="keyword">typedef</span> PlaneComputer::Primitive Primitive;</div>
<div class="line"> </div>
<div class="line">PlaneComputer plane;</div>
<div class="line">plane.init( 2, 1, 1 ); <span class="comment">// Z-axis</span></div>
<div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> pt0( 0, 0, 0 );</div>
<div class="line"><span class="keywordtype">bool</span> pt0_inside = plane.extend( pt0 ); <span class="comment">// true</span></div>
<div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> pt1( 8, 1, 3 );</div>
<div class="line"><span class="keywordtype">bool</span> pt1_inside = plane.extend( pt1 ); <span class="comment">// true</span></div>
<div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> pt2( 2, 7, 1 );</div>
<div class="line"><span class="keywordtype">bool</span> pt2_inside = plane.extend( pt2 ); <span class="comment">// true</span></div>
<div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> pt3( 0, 5, 12 );</div>
<div class="line"><span class="keywordtype">bool</span> pt3_inside = plane.extend( pt3 ); <span class="comment">// false</span></div>
<div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> pt4( -5, -5, 10 );</div>
<div class="line"><span class="keywordtype">bool</span> pt4_inside = plane.extend( pt4 ); <span class="comment">// false</span></div>
<div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> pt5 = pt0 + pt1 + pt2 + <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>( 0, 0, 1 );</div>
<div class="line"><span class="keywordtype">bool</span> pt5_inside = plane.extend( pt5 ); <span class="comment">// true</span></div>
<div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> pt6 = <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>( 1, 0, 1 );</div>
<div class="line"><span class="keywordtype">bool</span> pt6_inside = plane.extend( pt6 ); <span class="comment">// true</span></div>
<div class="line">Primitive strip = plane.primitive();</div>
<div class="line"><a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;strip=&quot;</span> &lt;&lt; strip</div>
<div class="line">             &lt;&lt; <span class="stringliteral">&quot; axis=&quot;</span> &lt;&lt; strip.mainAxis()</div>
<div class="line">             &lt;&lt; <span class="stringliteral">&quot; axiswidth=&quot;</span> &lt;&lt; strip.axisWidth()</div>
<div class="line">             &lt;&lt; <span class="stringliteral">&quot; diag=&quot;</span> &lt;&lt; strip.mainDiagonal()</div>
<div class="line">             &lt;&lt; <span class="stringliteral">&quot; diagwidth=&quot;</span> &lt;&lt; strip.diagonalWidth()</div>
<div class="line">             &lt;&lt; std::endl;</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Calling <b>isExtendable</b> before <b>extend</b> does not speed up the execution of <b>extend</b>. Hence the user should always prefer to call <b>extend</b> directly whenever possible.</dd></dl>
<h2><a class="anchor" id="modulePlaneRecognition_sec32"></a>
Additive plane recognition</h2>
<p>These six classes are models of <a class="el" href="structDGtal_1_1concepts_1_1CAdditivePrimitiveComputer.html" title="Aim: Defines the concept describing an object that computes some primitive from input points given gr...">concepts::CAdditivePrimitiveComputer</a>. They all have an internal state that store a current parallel strip that contains all points previously inserted. Furthermore, they provide templated methods <b>extend</b>( <em>it</em>, <em>itE</em> ) and <b>isExtendable</b>( <em>it</em>, <em>itE</em> ) to insert a range [<em>it</em>, <em>itE</em>) of new points and to check whether there is a some parallel strip that contains both the previously inserted points and all the new points.</p>
<ul>
<li><b>extend</b>( PointIterator <em>it</em>, PointIterator <em>itE</em> ) : bool. Tries to add the range [<em>it</em>, <em>itE</em>) of points to the current plane computer. If it is possible, update potentially the parallel strip and returns true, otherwise returns false and the object is left <b>unchanged</b>.</li>
<li><b>isExtendable</b>( PointIterator <em>it</em>, PointIterator <em>itE</em> ) : bool. Tries to add the range [<em>it</em>, <em>itE</em>) of points to the current plane computer. Returns true iff it is possible. The object is always left <b>unchanged</b>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Calling <b>isExtendable</b> before <b>extend</b> does not speed up the execution of <b>extend</b>. Hence the user should always prefer to call <b>extend</b> directly whenever possible.</dd></dl>
<h1><a class="anchor" id="modulePlaneRecognition_sec4"></a>
Width of a set of points</h1>
<p>Computing the axis width of a set of points is easily done with the static method <a class="el" href="classDGtal_1_1ChordNaivePlaneComputer.html#a65d3cf6b7f0cd22c7bff0dcf6f9818b9">ChordNaivePlaneComputer::computeAxisWidth</a>. The axis width is returned as a pair (p,q), such that the width is p/q.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/surfaces/ChordNaivePlaneComputer.h&quot;</span></div>
<div class="line">...</div>
<div class="line">std::set&lt;<a class="code" href="namespaceDGtal_1_1Z3i.html#a8d69892de6b10119a8070bd5d0871bf5">Z3i::Point</a>&gt; pts;       <span class="comment">// any container of 3D digital points</span></div>
<div class="line">...                             <span class="comment">// fill pts with your points</span></div>
<div class="line"><span class="keyword">typedef</span> ChordNaivePlaneComputer&lt;Z3i::Space, Z3i::Point, int64_t&gt; PlaneComputer;</div>
<div class="line">std::pair&lt;Z3i::Integer,Z3i::Integer&gt; width =</div>
<div class="line">  PlaneComputer::computeAxisWidth( 2, pts.begin(), pts.end() ); <span class="comment">// z-axis</span></div>
</div><!-- fragment --><h1><a class="anchor" id="modulePlaneRecognition_sec5"></a>
Comparative evaluation of COBA and Chord algorithm</h1>
<p>For now, there are only two computers for computing a <a class="el" href="classDGtal_1_1ParallelStrip.html" title="Aim: A parallel strip in the space is the intersection of two parallel half-planes such that each hal...">ParallelStrip</a> primitive: the <a class="el" href="classDGtal_1_1ChordNaivePlaneComputer.html" title="Aim: A class that contains the chord-based algorithm for recognizing pieces of digital planes of give...">ChordNaivePlaneComputer</a> (CHORD) and the <a class="el" href="classDGtal_1_1COBANaivePlaneComputer.html" title="Aim: A class that contains the COBA algorithm (Emilie Charrier, Lilian Buzer, DGCI2008) for recognizi...">COBANaivePlaneComputer</a> (COBA).</p>
<ol type="1">
<li>Complexity: (COBA) has a better worst time complexity than (CHORD), but neither (CHORD) nor (COBA) has an easy bound on the number of global recomputation (traversal of all input points to recompute a valid direction). From experiments, asymptotic behavior seems quasi-linear.</li>
<li>Big integers: (CHORD) requires (significantly) smaller integers than (COBA). For instance, <a class="el" href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63">int64_t</a> are required for diameter greater than 25 for (COBA) instead of 14000 for (CHORD).</li>
<li>Practical speed: both algorithms are very comparable. (CHORD) seems slightly faster than (COBA) on average (but this was not tested on many architecture). According to the graph below, obtained with programs <a class="el" href="testCOBANaivePlaneComputer-benchmark_8cpp.html">testCOBANaivePlaneComputer-benchmark.cpp</a> and <a class="el" href="testChordNaivePlaneComputer-benchmark_8cpp.html">testChordNaivePlaneComputer-benchmark.cpp</a>, (CHORD) is faster for a number of points below 200 while (COBA) is best for a big number of points. However, if the diameter is not too big, <a class="el" href="classDGtal_1_1ChordNaivePlaneComputer.html" title="Aim: A class that contains the chord-based algorithm for recognizing pieces of digital planes of give...">ChordNaivePlaneComputer</a> with <a class="el" href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63">int64_t</a> seems always faster.</li>
<li>Exactness: Both algorithms do not return the smallest possible arithmetic parameters for the plane, but only a rational approximation.</li>
<li>Services: Algorithm (CHORD) can be transformed to find the exact axis width of a given set of points, (COBA) is not suited for that task.</li>
</ol>
<div class="image">
<img src="coba-chord-benchmark.png" alt=""/>
<div class="caption">
Evaluation of computation times of COBA and Chord algorithms according to the number of points. Times are in ms. We did not put the graph of COBANaivePlaneComputer with int64_t since we cannot exceed a diameter of 500. In this benchmark, the diameter was always 10 times the number of points.</div></div>
  </div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="anamespaceDGtal_html_a8fc7012708b0416880a5c8b12dfdf9dd"><div class="ttname"><a href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">DGtal::trace</a></div><div class="ttdeci">Trace trace</div><div class="ttdef"><b>Definition:</b> <a href="Common_8h_source.html#l00150">Common.h:150</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1Z3i_html_a8d69892de6b10119a8070bd5d0871bf5"><div class="ttname"><a href="namespaceDGtal_1_1Z3i.html#a8d69892de6b10119a8070bd5d0871bf5">DGtal::Z3i::Point</a></div><div class="ttdeci">Space::Point Point</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00168">StdDefs.h:168</a></div></div>
<div class="ttc" id="aclassDGtal_1_1Trace_html_ad054990834d2763627166540087a2980"><div class="ttname"><a href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">DGtal::Trace::info</a></div><div class="ttdeci">std::ostream &amp; info()</div></div>
<div class="ttc" id="atestClone2_8cpp_html_a15e9592ccc512dc691b46185e6814758"><div class="ttname"><a href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a></div><div class="ttdeci">MyPointD Point</div><div class="ttdef"><b>Definition:</b> <a href="testClone2_8cpp_source.html#l00383">testClone2.cpp:383</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 6 2020 14:17:02 for DGtal by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
