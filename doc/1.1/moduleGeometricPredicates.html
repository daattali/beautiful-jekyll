<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Implementation of geometric predicates</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Implementation of geometric predicates </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#sectmoduleGeometricPredicates0">Introduction</a></li>
<li class="level1"><a href="#sectmoduleGeometricPredicates1">Orientation of three points in the plane</a><ul><li class="level2"><a href="#subsectmoduleGeometricPredicates11">Basic usage</a></li>
<li class="level2"><a href="#subsectmoduleGeometricPredicates12">List of available functors</a></li>
<li class="level2"><a href="#subsectmoduleGeometricPredicates13">How to avoid overflows ?</a></li>
<li class="level2"><a href="#subsectmoduleGeometricPredicates14">Benchmark</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>Tristan Roussillon</dd></dl>
<p>Several algorithms of the <a class="el" href="packageGeometry.html">Geometry package</a> rely on geometric predicates. For instance, any convex hull algorithm relies on an orientation test (see <a class="el" href="moduleHull2D.html">Convex hull and alpha-shape in the plane</a> for algorithms computing the convex hull of a finite planar set of points). <br  />
 If the test is not exact or if it is not robust to possible overflows, the algorithm can return an incorrect result or can even infinitely loop. We provide below several solutions to cope with such problems.</p>
<h1><a class="anchor" id="sectmoduleGeometricPredicates0"></a>
Introduction</h1>
<p>In our framework, we consider points in a space of dimension \( n \). The orientation of \( k+1 \) points \( (p_1, \ldots, p_{k+1}) \) is given by the sign of the algebraic distance between \( p_{k+1} \) and an algebraic variety, chosen such that it is uniquely defined by the first \( k \) points \( (p_1, \ldots, p_{k}) \).</p>
<p>An algebraic variety is the set of points where a given \(n\)-variate polynomial \( \mathcal{P} \) is evaluated to zero, ie. \( \{ x \in \mathbb{R}^n | \mathcal{P}(x) = 0 \} \). We consider only \( n\)-variate polynomials that are sums of exactly \( k+1 \) monomials, so that they are uniquely defined by exactly \( k \) points. The algebraic distance of \( p_{k+1} \) to the algebraic variety of polynomial \( \mathcal{P} \) is <br  />
 equal to \( \mathcal{P}(p_{k+1}) \).</p>
<p>Examples of algebraic varieties are:</p><ul>
<li>in dimension two<ul>
<li>line ( \( k = 2 \))</li>
<li>circle ( \( k = 3 \))</li>
<li>circle of given radius and orientation ( \( k = 2 \))</li>
<li>circle passing by a given point ( \( k = 2 \))</li>
</ul>
</li>
<li>in dimension three<ul>
<li>plane ( \( k = 3 \))</li>
<li>sphere ( \( k = 4 \))</li>
</ul>
</li>
</ul>
<p>The main concept of this module is COrientationFunctor, but there are also refinements, which are specific to small polynomials: COrientationFunctor2 and COrientationFunctor3.</p>
<p>Models of COrientationFunctor provide a method <a class="el" href="testCubicalComplex_8cpp.html#a2ab29adfd8ee31956627f4230b96a34b">init()</a> taking a static array of \( k \) points \( (p_1, \ldots, p_{k}) \) as argument. This initialization step is geometrically equivalent to defining the unique shape \( \mathcal{S} \) passing by these \( k \) points. Models of COrientationFunctor are also refinements of CPointFunctor. As such, they provide a parenthesis operator, which takes an extra point \( p_{k+1} \) as argument and returns a signed value that is:</p><ul>
<li>0 if \( p_{k+1} \) is lying on \( \mathcal{S} \).</li>
<li>strictly negative if \( p_{k+1} \) belongs to the <em>interior</em> of \( \mathcal{S} \). <br  />
</li>
<li>strictly positive if \( p_{k+1} \) belongs to the <em>exterior</em> of \( \mathcal{S} \).</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><em>Interior</em> and <em>exterior</em> are not geometric concepts, but algebraic ones: they depend on the lexicographic order of the points. For example, for a circle passing by three points in the plane, the geometric interior coincides with the algebraic interior iff the three points are counter-clockwise oriented. <br  />
</dd></dl>
<p>Geometric predicates, which return a boolean, usually adapt models of COrientationFunctor, which return an algebraic distance, so that either</p><ul>
<li>strictly positive values,</li>
<li>non-negative values,</li>
<li>strictly negative values,</li>
<li>or non-positive values are accepted.</li>
</ul>
<p><a class="el" href="classDGtal_1_1PredicateFromOrientationFunctor2.html" title="Aim: Small adapter to models of COrientationFunctor2. It is a model of concepts::CPointPredicate....">PredicateFromOrientationFunctor2</a> is an example of such adapter.</p>
<h1><a class="anchor" id="sectmoduleGeometricPredicates1"></a>
Orientation of three points in the plane</h1>
<p>In order to determine whether 3 given points are aligned, clockwise oriented or counter-clockwise oriented, we provide several predicates. They are actually adaptations of some models of COrientationFunctor2, devoted to the computation of the distance of a point to a line.</p>
<p>Instances of such classes must be initialized from two points \( P, Q \) and provide a parenthesis operator taking a third point \( R \) as argument and returning a signed value.</p>
<p>The resulting value may be interpreted as follows: <br  />
</p><ul>
<li>equal to 0 if \( P, Q, R \) belong to the same line <br  />
</li>
<li>strictly positive if \( R \) belongs to the open half-plane lying on the left of the oriented line \( (PQ) \) (ie. \( P, Q, R \) are counter-clockwise oriented) <br  />
</li>
<li>strictly negative if \( R \) belongs to the open half-plane lying on the right of the oriented line \( (PQ) \) (ie. \( P, Q, R \) are clockwise oriented)</li>
</ul>
<h2><a class="anchor" id="subsectmoduleGeometricPredicates11"></a>
Basic usage</h2>
<p>Let us assume that we are working with the following domain: </p><div class="fragment"><div class="line">  <span class="comment">//domain definition</span></div>
<div class="line">  <span class="keyword">typedef</span> SpaceND&lt; 2, DGtal::int16_t &gt; DigitalSpace;</div>
<div class="line">  <span class="keyword">typedef</span> HyperRectDomain&lt; DigitalSpace &gt; <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a>; </div>
<div class="line">  <span class="keyword">typedef</span> <a class="code" href="classDGtal_1_1PointVector.html">Domain::Point</a> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>; </div>
<div class="line">  <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a> <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(-32767,-32767), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(32767,32767) ); </div>
</div><!-- fragment --><p> To determine the orientation of the three following points... </p><div class="fragment"><div class="line">  <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> P, Q, R; </div>
<div class="line">  P = <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,0); </div>
<div class="line">  Q = <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(5,2); </div>
<div class="line">  R = <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(2,1); </div>
<div class="line">  <span class="comment">//problem: are P, Q, R counter-clockwise oriented ?</span></div>
</div><!-- fragment --><p> ...you must construct an orientation functor as follows: </p><div class="fragment"><div class="line">  <span class="comment">//orientation functor</span></div>
<div class="line">  <span class="keyword">typedef</span> InHalfPlaneBySimple3x3Matrix&lt;Point, DGtal::int32_t&gt; OrientationFunctor; </div>
<div class="line">  OrientationFunctor orientationFunctor;</div>
</div><!-- fragment --><p> Then, you can adapt this functor in order to get a predicate: </p><div class="fragment"><div class="line">  <span class="comment">//geometric predicate</span></div>
<div class="line">  PredicateFromOrientationFunctor2&lt;OrientationFunctor&gt; </div>
<div class="line">    pointPredicate( orientationFunctor ); </div>
</div><!-- fragment --><p> The default behavior of <a class="el" href="classDGtal_1_1PredicateFromOrientationFunctor2.html" title="Aim: Small adapter to models of COrientationFunctor2. It is a model of concepts::CPointPredicate....">PredicateFromOrientationFunctor2</a> is to return 'true' for strictly positive functor values.</p>
<p>The test can be done in one or two separate steps as follows: </p><div class="fragment"><div class="line">  <span class="comment">//initialization</span></div>
<div class="line">  pointPredicate.init( P, Q ); </div>
<div class="line">  <span class="comment">//which is equivalent to </span></div>
<div class="line">  <span class="comment">//orientationFunctor.init( P, Q );</span></div>
<div class="line">  <span class="comment">//because the predicate stores a pointer to the functor</span></div>
</div><!-- fragment --><div class="fragment"><div class="line">  <span class="comment">//decision</span></div>
<div class="line">  isCCW = pointPredicate( R ); </div>
<div class="line">  <span class="comment">//which is equivalent to the following shortcut:</span></div>
<div class="line">  <span class="comment">//isCCW = pointPredicate( P, Q, R ); </span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This small example, which may be found in <a class="el" href="exampleInHalfPlane_8cpp.html">exampleInHalfPlane.cpp</a>, requires the following headers: <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/tools/determinant/PredicateFromOrientationFunctor2.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/tools/determinant/InHalfPlaneBySimple3x3Matrix.h&quot;</span></div>
</div><!-- fragment --></dd></dl>
<h2><a class="anchor" id="subsectmoduleGeometricPredicates12"></a>
List of available functors</h2>
<p>Two useful classes have been implemented:</p><ul>
<li><a class="el" href="classDGtal_1_1InHalfPlaneBySimple3x3Matrix.html" title="Aim: Class that implements an orientation functor, ie. it provides a way to compute the orientation o...">InHalfPlaneBySimple3x3Matrix</a>, an orientation functor based on the determinant of a 3x3 matrix:</li>
</ul>
<p>\( \begin{vmatrix} P_x &amp; Q_x &amp; R_x \\ P_y &amp; Q_y &amp; R_y \\ 1 &amp; 1 &amp; 1 \end{vmatrix} \)</p>
<ul>
<li><a class="el" href="classDGtal_1_1InHalfPlaneBy2x2DetComputer.html" title="Aim: Class that implements an orientation functor, ie. it provides a way to compute the orientation o...">InHalfPlaneBy2x2DetComputer</a>, an orientation functor that reduces the computation to the determinant of a 2x2 matrix:</li>
</ul>
<p>\( \begin{vmatrix} Q_x - P_x &amp; R_x - P_x \\ Q_y - P_y &amp; R_y - P_y \end{vmatrix} \)</p>
<p><a class="el" href="classDGtal_1_1InHalfPlaneBy2x2DetComputer.html" title="Aim: Class that implements an orientation functor, ie. it provides a way to compute the orientation o...">InHalfPlaneBy2x2DetComputer</a> delegates the computation of this determinant to a model of <a class="el" href="structDGtal_1_1C2x2DetComputer.html" title="Aim: This concept gathers all models that are able to compute the (sign of the) determinant of a 2x2 ...">C2x2DetComputer</a>. <br  />
</p><ul>
<li><a class="el" href="classDGtal_1_1Simple2x2DetComputer.html" title="Aim: Small class useful to compute the determinant of a 2x2 matrix from its four coefficients,...">Simple2x2DetComputer</a>, which merely computes \( (Q_x - P_x)(R_y - P_y) - (Q_y - P_y)(R_x - P_x) \). <br  />
</li>
<li><a class="el" href="classDGtal_1_1AvnaimEtAl2x2DetSignComputer.html" title="Aim: Class that provides a way of computing the sign of the determinant of a 2x2 matrix from its four...">AvnaimEtAl2x2DetSignComputer</a>, an implementation of [Avnaim et.al., 1997 : <a class="el" href="citelist.html#CITEREF_AvnaimEtAlAlgorithmica1997">[8]</a>] that returns the sign of the determinant without increasing the size of the matrix entries.</li>
<li><a class="el" href="classDGtal_1_1Filtered2x2DetComputer.html" title="Aim: Class that provides a way of computing the sign of the determinant of a 2x2 matrix from its four...">Filtered2x2DetComputer</a>, which is a lazy adapter of any other determinant computer: the adaptee is only used for determinants close to zero.</li>
</ul>
<p>Most classes are template classes parametrized by a type for the points (or its coordinates) and an integral type for the computations. All these implementations return an exact value (or sign), provided that the integral type used for the computations is well chosen with respect to the coordinates of the points.</p>
<p>Let \( x \) and \( x&#39; \) be respectively \( b \)-bits and \( b&#39; \)-bits integers. The sum \( x+x&#39; \) may require \( \max(b,b&#39;)+1 \) bits and the product \( xx&#39; \) may require \( b+b&#39; \) bits. Consequently, we can determine the number of bits required for the different computations. <br  />
 If the coordinates of the points are \( b \)-bits integers, both <a class="el" href="classDGtal_1_1InHalfPlaneBySimple3x3Matrix.html" title="Aim: Class that implements an orientation functor, ie. it provides a way to compute the orientation o...">InHalfPlaneBySimple3x3Matrix</a> and <a class="el" href="classDGtal_1_1InHalfPlaneBy2x2DetComputer.html" title="Aim: Class that implements an orientation functor, ie. it provides a way to compute the orientation o...">InHalfPlaneBy2x2DetComputer</a> with <a class="el" href="classDGtal_1_1Simple2x2DetComputer.html" title="Aim: Small class useful to compute the determinant of a 2x2 matrix from its four coefficients,...">Simple2x2DetComputer</a> may return determinant values of \( 2b + 3 \) bits. However, <a class="el" href="classDGtal_1_1InHalfPlaneBy2x2DetComputer.html" title="Aim: Class that implements an orientation functor, ie. it provides a way to compute the orientation o...">InHalfPlaneBy2x2DetComputer</a> with <a class="el" href="classDGtal_1_1AvnaimEtAl2x2DetSignComputer.html" title="Aim: Class that provides a way of computing the sign of the determinant of a 2x2 matrix from its four...">AvnaimEtAl2x2DetSignComputer</a> only require integers of \( b+1 \) bits.</p>
<h2><a class="anchor" id="subsectmoduleGeometricPredicates13"></a>
How to avoid overflows ?</h2>
<p>For coordinates of \( 30 \) bits, lying within the range \( ]-2^{30}; 2^{30}[ \), we recommand to use <a class="el" href="classDGtal_1_1InHalfPlaneBySimple3x3Matrix.html" title="Aim: Class that implements an orientation functor, ie. it provides a way to compute the orientation o...">InHalfPlaneBySimple3x3Matrix</a> with <a class="el" href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63" title="signed 94-bit integer.">DGtal::int64_t</a> as result type. </p><div class="fragment"><div class="line">  <span class="comment">//for coordinates of 30 (not zero) bits</span></div>
<div class="line">  <span class="keyword">typedef</span> PointVector&lt;2, DGtal::int32_t&gt; <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>; </div>
<div class="line">  <span class="keyword">typedef</span> InHalfPlaneBySimple3x3Matrix&lt;Point, DGtal::int64_t&gt; <a class="code" href="testConvexHull2DReverse_8cpp.html#a4b95d895f3d8af697b8c550bc833cc9f">Functor</a>; </div>
</div><!-- fragment --><p> For coordinates of \( 52 \) bits, lying within the range \( ]-2^{52}; 2^{52}[ \), we recommand to use <a class="el" href="classDGtal_1_1InHalfPlaneBy2x2DetComputer.html" title="Aim: Class that implements an orientation functor, ie. it provides a way to compute the orientation o...">InHalfPlaneBy2x2DetComputer</a> with a lazy implementation of [Avnaim et.al., 1997 : <a class="el" href="citelist.html#CITEREF_AvnaimEtAlAlgorithmica1997">[8]</a>] using the \( 53 \) bits of the mantissa of the double-precision floating-point data type. </p><div class="fragment"><div class="line">  <span class="comment">//for coordinates of 52 (not zero) bits</span></div>
<div class="line">  <span class="keyword">typedef</span> PointVector&lt;2, DGtal::int64_t&gt; <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>;  </div>
<div class="line">  <span class="keyword">typedef</span> AvnaimEtAl2x2DetSignComputer&lt;double&gt; DetComputer; </div>
<div class="line">  <span class="keyword">typedef</span> Filtered2x2DetComputer&lt;DetComputer&gt; FDetComputer; </div>
<div class="line">  <span class="keyword">typedef</span> InHalfPlaneBy2x2DetComputer&lt;Point, FDetComputer&gt; <a class="code" href="testConvexHull2DReverse_8cpp.html#a4b95d895f3d8af697b8c550bc833cc9f">Functor</a>; </div>
</div><!-- fragment --><p> For coordinates of \( 62 \) bits, lying within the range \( ]-2^{62}; 2^{62}[ \), we recommand to use <a class="el" href="classDGtal_1_1InHalfPlaneBy2x2DetComputer.html" title="Aim: Class that implements an orientation functor, ie. it provides a way to compute the orientation o...">InHalfPlaneBy2x2DetComputer</a> with an implementation of [Avnaim et.al., 1997 : <a class="el" href="citelist.html#CITEREF_AvnaimEtAlAlgorithmica1997">[8]</a>] using <a class="el" href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63" title="signed 94-bit integer.">DGtal::int64_t</a> as a working type. </p><div class="fragment"><div class="line">  <span class="comment">//for coordinates of 62 (not zero) bits</span></div>
<div class="line">  <span class="keyword">typedef</span> PointVector&lt;2, DGtal::int64_t&gt; <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>; </div>
<div class="line">  <span class="keyword">typedef</span> AvnaimEtAl2x2DetSignComputer&lt;DGtal::int64_t&gt; DetComputer; </div>
<div class="line">  <span class="keyword">typedef</span> InHalfPlaneBy2x2DetComputer&lt;Point, DetComputer&gt; <a class="code" href="testConvexHull2DReverse_8cpp.html#a4b95d895f3d8af697b8c550bc833cc9f">Functor</a>; </div>
</div><!-- fragment --><p> For greater coordinates, we recommand to use <a class="el" href="classDGtal_1_1InHalfPlaneBy2x2DetComputer.html" title="Aim: Class that implements an orientation functor, ie. it provides a way to compute the orientation o...">InHalfPlaneBy2x2DetComputer</a> together with <a class="el" href="classDGtal_1_1Simple2x2DetComputer.html" title="Aim: Small class useful to compute the determinant of a 2x2 matrix from its four coefficients,...">Simple2x2DetComputer</a> using <a class="el" href="namespaceDGtal.html#ad14cde66089fcbdefb20c819562d2a0d" title="Multi-precision integer with GMP implementation.">DGtal::BigInteger</a> as integral types (WITH_GMP ON). </p><div class="fragment"><div class="line">  <span class="comment">//for arbitrary coordinates</span></div>
<div class="line">  <span class="keyword">typedef</span> PointVector&lt;2, DGtal::BigInteger&gt; <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>; </div>
<div class="line">  <span class="keyword">typedef</span> Simple2x2DetComputer&lt;DGtal::BigInteger&gt; DetComputer; </div>
<div class="line">  <span class="keyword">typedef</span> InHalfPlaneBy2x2DetComputer&lt;Point, DetComputer&gt; <a class="code" href="testConvexHull2DReverse_8cpp.html#a4b95d895f3d8af697b8c550bc833cc9f">Functor</a>; </div>
<div class="line">  <a class="code" href="testConvexHull2DReverse_8cpp.html#a4b95d895f3d8af697b8c550bc833cc9f">Functor</a> *a= <span class="keyword">new</span> <a class="code" href="testConvexHull2DReverse_8cpp.html#a4b95d895f3d8af697b8c550bc833cc9f">Functor</a>();</div>
<div class="line">  BOOST_VERIFY( a);</div>
</div><!-- fragment --> <h2><a class="anchor" id="subsectmoduleGeometricPredicates14"></a>
Benchmark</h2>
<p>Experimental tests justify the above recommendations. In <a class="el" href="testInHalfPlane-benchmark_8cpp.html">testInHalfPlane-benchmark.cpp</a>, we compare several methods:</p><ul>
<li><code>3x3</code> : <a class="el" href="classDGtal_1_1InHalfPlaneBySimple3x3Matrix.html" title="Aim: Class that implements an orientation functor, ie. it provides a way to compute the orientation o...">InHalfPlaneBySimple3x3Matrix</a></li>
<li><code>2x2</code> : <a class="el" href="classDGtal_1_1InHalfPlaneBy2x2DetComputer.html" title="Aim: Class that implements an orientation functor, ie. it provides a way to compute the orientation o...">InHalfPlaneBy2x2DetComputer</a> with <a class="el" href="classDGtal_1_1Simple2x2DetComputer.html" title="Aim: Small class useful to compute the determinant of a 2x2 matrix from its four coefficients,...">Simple2x2DetComputer</a></li>
<li><code>2x2-avnaim</code> : <a class="el" href="classDGtal_1_1InHalfPlaneBy2x2DetComputer.html" title="Aim: Class that implements an orientation functor, ie. it provides a way to compute the orientation o...">InHalfPlaneBy2x2DetComputer</a> with <a class="el" href="classDGtal_1_1AvnaimEtAl2x2DetSignComputer.html" title="Aim: Class that provides a way of computing the sign of the determinant of a 2x2 matrix from its four...">AvnaimEtAl2x2DetSignComputer</a></li>
<li><code>2x2-avnaim++</code> : a combination of <a class="el" href="classDGtal_1_1InHalfPlaneBy2x2DetComputer.html" title="Aim: Class that implements an orientation functor, ie. it provides a way to compute the orientation o...">InHalfPlaneBy2x2DetComputer</a>, <a class="el" href="classDGtal_1_1Filtered2x2DetComputer.html" title="Aim: Class that provides a way of computing the sign of the determinant of a 2x2 matrix from its four...">Filtered2x2DetComputer</a> and <a class="el" href="classDGtal_1_1AvnaimEtAl2x2DetSignComputer.html" title="Aim: Class that provides a way of computing the sign of the determinant of a 2x2 matrix from its four...">AvnaimEtAl2x2DetSignComputer</a></li>
</ul>
<p>Input and output types follow the name of the method. For instance, the <code>3x3-int32-int64</code>-method runs on coordinates of type <a class="el" href="namespaceDGtal.html#ac1e9ac6a329319ae13c51c0c9e92486a" title="signed 32-bit integer.">DGtal::int32_t</a> and return a determinant of type <a class="el" href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63" title="signed 94-bit integer.">DGtal::int64_t</a>. <br  />
</p>
<p>We ran all the above methods on a laptop (Intel core i5 2.50GHz, 4GB RAM) with Ubuntu 12.04. <a class="el" href="testInHalfPlane-benchmark_8cpp.html">testInHalfPlane-benchmark.cpp</a> was compiled in Release mode with gcc 4.6.3.</p>
<p>We performed 1 million orientation tests on five different kinds of inputs: <br  />
</p><ol type="1">
<li>Three points \( P, Q, R \) of random coordinates.</li>
<li>Random \( P \) and \( Q \) and \( R = Q \) (null determinants). <br  />
</li>
<li>Random \( P \) and \( Q \) and \( R = P \) (null determinants). <br  />
</li>
<li>\( P = (0,0) \) and \( Q-P = k\vec{u}, R-P = l\vec{u} \) with random \( k, l, \vec{u}_x \vec{u}_y \) (null determinants). <br  />
</li>
<li>\( P = (0,0) \) and \( Q-P = k\vec{u} + \epsilon, R-P = l\vec{u} + \epsilon \) with random \( k, l, \vec{u}_x \vec{u}_y \) and \( \epsilon \) (determinants close to zero). <br  />
</li>
</ol>
<p>For coordinates of \( 30 \) bits, we obtain the following results (running times are in seconds):</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">method vs input  </th><th class="markdownTableHeadNone">1.  </th><th class="markdownTableHeadNone">2.  </th><th class="markdownTableHeadNone">3.  </th><th class="markdownTableHeadNone">4.  </th><th class="markdownTableHeadNone">5.   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">3x3-int32-int64  </td><td class="markdownTableBodyNone">0.28  </td><td class="markdownTableBodyNone">0.18  </td><td class="markdownTableBodyNone">0.18  </td><td class="markdownTableBodyNone">0.13  </td><td class="markdownTableBodyNone">0.18   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">3x3-int32-BigInt  </td><td class="markdownTableBodyNone">2.54  </td><td class="markdownTableBodyNone">2.3  </td><td class="markdownTableBodyNone">2.4  </td><td class="markdownTableBodyNone">2.34  </td><td class="markdownTableBodyNone">2.36   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2x2-int32-int64  </td><td class="markdownTableBodyNone">0.28  </td><td class="markdownTableBodyNone">0.18  </td><td class="markdownTableBodyNone">0.19  </td><td class="markdownTableBodyNone">0.12  </td><td class="markdownTableBodyNone">0.2   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2x2-int32-BigInt  </td><td class="markdownTableBodyNone">0.61  </td><td class="markdownTableBodyNone">0.5  </td><td class="markdownTableBodyNone">0.46  </td><td class="markdownTableBodyNone">0.45  </td><td class="markdownTableBodyNone">0.52   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2x2-avnaim-int32-int32  </td><td class="markdownTableBodyNone">0.32  </td><td class="markdownTableBodyNone">0.2  </td><td class="markdownTableBodyNone">0.18  </td><td class="markdownTableBodyNone">0.3  </td><td class="markdownTableBodyNone">0.36   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2x2-avnaim-int32-double  </td><td class="markdownTableBodyNone">0.33  </td><td class="markdownTableBodyNone">0.21  </td><td class="markdownTableBodyNone">0.19  </td><td class="markdownTableBodyNone">0.38  </td><td class="markdownTableBodyNone">0.46   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2x2-avnaim++-int32-double  </td><td class="markdownTableBodyNone">0.28  </td><td class="markdownTableBodyNone">0.21  </td><td class="markdownTableBodyNone">0.2  </td><td class="markdownTableBodyNone">0.38  </td><td class="markdownTableBodyNone">0.19   </td></tr>
</table>
<p>Best methods are <code>3x3-int32-int64</code> and <code>2x2-int32-int64</code>. We therefore recommend to use <code>3x3-int32-int64</code>, whose type is simpler to define.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>As expected <code>2x2-avnaim++-int32-double</code> performs well, excepted for null determinants (columns 2, 3 and 4), because more steps are required in such cases to take a decision. <br  />
</li>
<li><code>2x2-int32-BigInt</code> outperforms <code>3x3-int32-BigInt</code> because the allocation/desallocation of BigIntegers, which represent a substantial part of running time, is minimized in <a class="el" href="classDGtal_1_1Simple2x2DetComputer.html" title="Aim: Small class useful to compute the determinant of a 2x2 matrix from its four coefficients,...">Simple2x2DetComputer</a>.</li>
</ul>
</dd></dl>
<p>For coordinates of \( 52 \) bits, we obtain the following results:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">method vs input  </th><th class="markdownTableHeadNone">1.  </th><th class="markdownTableHeadNone">2.  </th><th class="markdownTableHeadNone">3.  </th><th class="markdownTableHeadNone">4.  </th><th class="markdownTableHeadNone">5.   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">3x3-double-BigInt  </td><td class="markdownTableBodyNone">3.32  </td><td class="markdownTableBodyNone">3.02  </td><td class="markdownTableBodyNone">3.01  </td><td class="markdownTableBodyNone">2.7  </td><td class="markdownTableBodyNone">2.75   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2x2-double-BigInt  </td><td class="markdownTableBodyNone">1.08  </td><td class="markdownTableBodyNone">0.91  </td><td class="markdownTableBodyNone">0.72  </td><td class="markdownTableBodyNone">0.76  </td><td class="markdownTableBodyNone">0.84   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2x2-avnaim-int64-int64  </td><td class="markdownTableBodyNone">0.55  </td><td class="markdownTableBodyNone">0.36  </td><td class="markdownTableBodyNone">0.34  </td><td class="markdownTableBodyNone">0.87  </td><td class="markdownTableBodyNone">0.94   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2x2-avnaim-double-int64  </td><td class="markdownTableBodyNone">0.56  </td><td class="markdownTableBodyNone">0.37  </td><td class="markdownTableBodyNone">0.35  </td><td class="markdownTableBodyNone">0.87  </td><td class="markdownTableBodyNone">0.94   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2x2-avnaim-int64-double  </td><td class="markdownTableBodyNone">0.52  </td><td class="markdownTableBodyNone">0.34  </td><td class="markdownTableBodyNone">0.33  </td><td class="markdownTableBodyNone">0.6  </td><td class="markdownTableBodyNone">0.65   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2x2-avnaim-double-double  </td><td class="markdownTableBodyNone">0.5  </td><td class="markdownTableBodyNone">0.33  </td><td class="markdownTableBodyNone">0.31  </td><td class="markdownTableBodyNone">0.58  </td><td class="markdownTableBodyNone">0.68   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2x2-avnaim++-int64-double  </td><td class="markdownTableBodyNone">0.5  </td><td class="markdownTableBodyNone">0.35  </td><td class="markdownTableBodyNone">0.33  </td><td class="markdownTableBodyNone">0.62  </td><td class="markdownTableBodyNone">0.24   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2x2-avnaim++-double-double  </td><td class="markdownTableBodyNone">0.46  </td><td class="markdownTableBodyNone">0.34  </td><td class="markdownTableBodyNone">0.32  </td><td class="markdownTableBodyNone">0.67  </td><td class="markdownTableBodyNone">0.26   </td></tr>
</table>
<p>The best method is the lazy implementation of [Avnaim et.al., 1997 : <a class="el" href="citelist.html#CITEREF_AvnaimEtAlAlgorithmica1997">[8]</a>] using the \( 53 \) bits of the mantissa of the double data type, ie. <code>2x2-avnaim++-double-double</code> (last line). <br  />
</p>
<p>For coordinates of \( 62 \) bits, we obtain the following results:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">method vs input  </th><th class="markdownTableHeadNone">1.  </th><th class="markdownTableHeadNone">2.  </th><th class="markdownTableHeadNone">3.  </th><th class="markdownTableHeadNone">4.  </th><th class="markdownTableHeadNone">5.   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">3x3-BigInt-BigInt  </td><td class="markdownTableBodyNone">7.4  </td><td class="markdownTableBodyNone">6.62  </td><td class="markdownTableBodyNone">4.89  </td><td class="markdownTableBodyNone">2.4  </td><td class="markdownTableBodyNone">2.54   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2x2-BigInt-BigInt  </td><td class="markdownTableBodyNone">4.76  </td><td class="markdownTableBodyNone">3.54  </td><td class="markdownTableBodyNone">3.49  </td><td class="markdownTableBodyNone">1.28  </td><td class="markdownTableBodyNone">1.44   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2x2-avnaim-int64-int64  </td><td class="markdownTableBodyNone">0.65  </td><td class="markdownTableBodyNone">0.42  </td><td class="markdownTableBodyNone">0.4  </td><td class="markdownTableBodyNone">0.98  </td><td class="markdownTableBodyNone">1.06   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2x2-avnaim++-int64-longdouble  </td><td class="markdownTableBodyNone">0.6  </td><td class="markdownTableBodyNone">0.42  </td><td class="markdownTableBodyNone">0.4  </td><td class="markdownTableBodyNone">0.78  </td><td class="markdownTableBodyNone">0.26   </td></tr>
</table>
<p>Best methods are <code>2x2-avnaim-int64-int64</code> and <code>2x2-avnaim++-int64-longdouble</code>, where long double is implemented as the 80-bit extended precision type. If this implementation is available on your system, you should use <br  />
 <code>2x2-avnaim++-int64-longdouble</code> in order to perform faster computations in the case of (quasi)-collinear (but not confunded) points (columns 4 and 5). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="atestConvexHull2DReverse_8cpp_html_a4b95d895f3d8af697b8c550bc833cc9f"><div class="ttname"><a href="testConvexHull2DReverse_8cpp.html#a4b95d895f3d8af697b8c550bc833cc9f">Functor</a></div><div class="ttdeci">InHalfPlaneBySimple3x3Matrix&lt; Point, double &gt; Functor</div><div class="ttdef"><b>Definition:</b> <a href="testConvexHull2DReverse_8cpp_source.html#l00053">testConvexHull2DReverse.cpp:51</a></div></div>
<div class="ttc" id="atestSimpleRandomAccessRangeFromPoint_8cpp_html_acd532b318489cd93df57e0b3d136d050"><div class="ttname"><a href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a></div><div class="ttdeci">HyperRectDomain&lt; Space &gt; Domain</div><div class="ttdef"><b>Definition:</b> <a href="testSimpleRandomAccessRangeFromPoint_8cpp_source.html#l00044">testSimpleRandomAccessRangeFromPoint.cpp:44</a></div></div>
<div class="ttc" id="atestProjection_8cpp_html_a1f1a69f8d8b037b72c2160ed12b3ef51"><div class="ttname"><a href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a></div><div class="ttdeci">Domain domain</div><div class="ttdef"><b>Definition:</b> <a href="testProjection_8cpp_source.html#l00088">testProjection.cpp:88</a></div></div>
<div class="ttc" id="aclassDGtal_1_1PointVector_html"><div class="ttname"><a href="classDGtal_1_1PointVector.html">DGtal::PointVector&lt; dim, Integer &gt;</a></div></div>
<div class="ttc" id="atestClone2_8cpp_html_a15e9592ccc512dc691b46185e6814758"><div class="ttname"><a href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a></div><div class="ttdeci">MyPointD Point</div><div class="ttdef"><b>Definition:</b> <a href="testClone2_8cpp_source.html#l00383">testClone2.cpp:383</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 9 2020 08:58:47 for DGtal by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
