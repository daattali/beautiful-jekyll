<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Digital surfaces</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Digital surfaces </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#dgtal_digsurf_sec1">Introduction to digital surfaces</a><ul><li class="level2"><a href="#dgtal_digsurf_sec1_1">Possible definitions for digital surfaces</a></li>
<li class="level2"><a href="#dgtal_digsurf_sec1_2">Digital surface as a set of n-1-cells</a></li>
<li class="level2"><a href="#dgtal_digsurf_sec1_3">Digital surface as a graph: adding adjacencies between surfels</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtal_digsurf_sec2">Tracking digital surfaces</a><ul><li class="level2"><a href="#dgtal_digsurf_sec2_1">Constructing digital surfaces by scanning</a></li>
<li class="level2"><a href="#dgtal_digsurf_sec2_2">Constructing digital surfaces by tracking</a></li>
<li class="level2"><a href="#dgtal_digsurf_sec2_3">Other constructions by tracking: 2D contours, surface connected components, 2D slices in 3D surface</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtal_digsurf_sec3">High-level classes for digital surfaces</a><ul><li class="level2"><a href="#dgtal_digsurf_sec3_1">A common architecture for digital surfaces</a></li>
<li class="level2"><a href="#dgtal_digsurf_sec3_2">Models of digital surface containers</a></li>
<li class="level2"><a href="#dgtal_digsurf_sec3_3">Relating a digital surface to some container</a></li>
<li class="level2"><a href="#dgtal_digsurf_sec3_4">A digital surface is a graph, example of breadth-first traversal</a></li>
<li class="level2"><a href="#dgtal_digsurf_sec3_5">Boundary and frontiers  examples of digital surface</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtal_digsurf_sec4">The digital surface graph is a combinatorial manifold</a><ul><li class="level2"><a href="#dgtal_digsurf_sec4_1">Umbrellas and faces</a></li>
<li class="level2"><a href="#dgtal_digsurf_sec4_2">Vertices, arcs and faces on a digital surface</a></li>
<li class="level2"><a href="#dgtal_digsurf_sec4_3">Application to export surface in OFF format</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtal_digsurf_sec5">Precomputed 3D digital surface with IndexedDigitalSurface</a><ul><li class="level2"><a href="#dgtal_digsurf_sec5_1">Creating an IndexedDigitalSurface</a></li>
<li class="level2"><a href="#dgtal_digsurf_sec5_2">Guide for using an IndexedDigitalSurface</a></li>
<li class="level2"><a href="#dgtal_digsurf_sec5_3">When using an IndexedDigitalSurface instead of a DigitalSurface ?</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>Jacques-Olivier Lachaud</dd></dl>
<p>Part of the <a class="el" href="packageTopology.html">Topology package</a>.</p>
<p>This part of the manual describes how to define digital surfaces, closed or open. A lot of the ideas, concepts, algorithms, documentation and code is a backport from <em>ImaGene</em> <a class="el" href="citelist.html#CITEREF_ImaGene">[52]</a>. Digital surfaces can be defined in very different way depending on input data, but they can be manipulated uniformly with class <a class="el" href="classDGtal_1_1DigitalSurface.html">DigitalSurface</a>, whichever is the dimension. Note that the topology within digital surfaces is computed on-the-fly. Since 0.9.4, one can precompute the topology of a 3D digital surface with class <a class="el" href="classDGtal_1_1IndexedDigitalSurface.html">IndexedDigitalSurface</a>. In some usages (typically local traversals), this can speed-up algorithms up to three times faster.</p>
<p>The following programs are related to this documentation: <a class="el" href="volToOFF_8cpp.html">volToOFF.cpp</a>, <a class="el" href="volMarchingCubes_8cpp.html">volMarchingCubes.cpp</a>, <a class="el" href="volScanBoundary_8cpp.html">volScanBoundary.cpp</a>, <a class="el" href="volTrackBoundary_8cpp.html">volTrackBoundary.cpp</a>, <a class="el" href="frontierAndBoundary_8cpp.html">frontierAndBoundary.cpp</a>, <a class="el" href="volBreadthFirstTraversal_8cpp.html">volBreadthFirstTraversal.cpp</a>, <a class="el" href="trackImplicitPolynomialSurfaceToOFF_8cpp.html">trackImplicitPolynomialSurfaceToOFF.cpp</a>, <a class="el" href="area-estimation-with-digital-surface_8cpp.html">area-estimation-with-digital-surface.cpp</a>, <a class="el" href="area-estimation-with-indexed-digital-surface_8cpp.html">area-estimation-with-indexed-digital-surface.cpp</a></p>
<h1><a class="anchor" id="dgtal_digsurf_sec1"></a>
Introduction to digital surfaces</h1>
<h2><a class="anchor" id="dgtal_digsurf_sec1_1"></a>
Possible definitions for digital surfaces</h2>
<p>Although continuous surfaces are well defined as n-manifolds, a digital or discrete analog of surface is more tricky to define. Several methods have been explored to define consistent digital surfaces. We mention three approaches here.</p>
<ul>
<li>Surface as specific subsets of \( Z^n \), i.e. as sets of pixels in 2D, voxels in 3D, etc, with specific properties. This approach was proposed by Rosenfeld in the 70s. The set \( S \subset Z^n \) is a digital surface iff \( Z^n \setminus S \) is composed of two \( \alpha \)-connected components and if <em>S</em> is thin (i.e. if any point of <em>S</em> is removed, the preceding property does not hold). This approach is not too bad in 2D, becomes more complex in 3D (see the work of Morgenthaler and Rosenfeld or Malgouyres) and is unusable in practice. For instance the border of any digital object is generally not a surface.</li>
<li>Surface as \( n-1 \)-dimensional cubical complexes. For example, if a digital object is a pure \( n \)-dimensional cubical complex, its boundary is naturally a \( n-1 \)-dimensional cubical complex. This seems at first sight a good approach, and it works well with well-composed pictures and images (see the work of Latecki et al.). The obtain complex is indeed a \( n-1 \)-manifold when realized in the Euclidean space. However, if the object contains any <em>cross</em> configuration (like two voxels connected by their edge, and the other two voxels adjacent to them are not in the object) then the preceding property does not hold anymore. Cubical complexes are thus interesting for representing objects, but not so interesting when one is interested by the geometry of its boundary.</li>
<li>Surface as set of n-1-cells with some specific adjacencies. This approach is more or less the approach of Herman, Udupa and others, which was designed originally for tracking surfaces in a digital space. In 2D, this correspond to an interpixel approach. You choose first if you wish an interior adjacency (4-connectedness) or an exterior adjacency (8-adjacency). Two linels (or edges) are connected if they are point-connected and in case of a cross configuration they border the same interior (resp. exterior) pixel. The principle is the same in 3D, where a 2-cell (surfel) has edge-connected surfels with a preference in case of cross configuration.</li>
</ul>
<p>We focus here on the last method to define digital surfaces.</p>
<h2><a class="anchor" id="dgtal_digsurf_sec1_2"></a>
Digital surface as a set of n-1-cells</h2>
<p>Formally, the elements of the digital space \( Z^n \) are called <em>spels</em>, and often <em>pixels</em> in 2D and <em>voxels</em> in 3D. A <em>surfel</em> is a couple (u,v) of face-adjacent voxels. A <em>digital</em> <em>surface</em> is a set of surfels. It is obvious that a spel is a n-cell in the cellular grid decomposition of the space, while a surfel is clearly some oriented n-1-cell which is incident to the two n-cells u and v (see <a class="el" href="moduleCellularTopology.html">Cellular grid space and topology, unoriented and oriented cells, incidence</a>).</p>
<p>Let <em>s</em> be some surfel. It is incident to two oriented voxels. By convention, its <em>interior</em> pixel is the one that is <b>positively</b> oriented.</p>
<p>We assume from now on that you have instantiated some cellular space <em>K</em> of type <em>KSpace</em> (see dgtal_ctopo_sec4), for instance with the following lines:</p>
<div class="fragment"><div class="line"><a class="code" href="classDGtal_1_1KhalimskySpaceND.html">KSpace</a> <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>;</div>
<div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> low( -10, -10, -10 );</div>
<div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> high( 10, 10, 10 );</div>
<div class="line"><span class="keywordtype">bool</span> space_ok = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a15dcbcaae831dd1c36090e6336c177d4">init</a>( low, high, <span class="keyword">true</span> );</div>
</div><!-- fragment --><p>A surfel is an oriented \(n-1\)-cell, i.e. some SCell. Surfel may be obtained from spels by incidence relation. Reciprocally, you can use incidence to get spels.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="structDGtal_1_1SignedKhalimskyCell.html">KSpace::SCell</a> Surfel; <span class="comment">// or typedef KSpace::Surfel Surfel;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="structDGtal_1_1SignedKhalimskyCell.html">KSpace::SCell</a> Spel; <span class="comment">// or typedef KSpace::Surfel Surfel;</span></div>
<div class="line">Spel v = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a7d5231f241513f15be0a1ee092db2590">sSpel</a>( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>( 0, 0, 0 ), POS ); <span class="comment">// +v</span></div>
<div class="line">Surfel sx = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#adcda490970c3962a731a5ad604ef5ce6">sIncident</a>( v, 0, <span class="keyword">true</span> ); <span class="comment">// surfel further along x</span></div>
<div class="line">Surfel sy = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#adcda490970c3962a731a5ad604ef5ce6">sIncident</a>( v, 1, <span class="keyword">true</span> ); <span class="comment">// surfel further along y</span></div>
<div class="line">Surfel sz = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#adcda490970c3962a731a5ad604ef5ce6">sIncident</a>( v, 2, <span class="keyword">true</span> ); <span class="comment">// surfel further along z</span></div>
<div class="line">Spel qx = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#aaa60ad137a7aa68627cd86b0d76c3693">sDirectIncident</a>( s, 0 ); <span class="comment">// positive coboundary of s</span></div>
<div class="line">Spel qy = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#aaa60ad137a7aa68627cd86b0d76c3693">sDirectIncident</a>( s, 1 ); <span class="comment">// positive coboundary of s</span></div>
<div class="line">Spel qz = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#aaa60ad137a7aa68627cd86b0d76c3693">sDirectIncident</a>( s, 2 ); <span class="comment">// positive coboundary of s</span></div>
<div class="line">ASSERT( v == qx &amp;&amp; v == qy &amp;&amp; v == qz ); <span class="comment">// same as qx, qy, qz</span></div>
</div><!-- fragment --><p>The direct orientation to some cell <em>s</em> is the one that gives a positively oriented cell in the boundary or coboundary of <em>s</em>.</p>
<p>You may now for instance define the digital surface that lies in the boundary of some digital shape \( S \subset Z^n \) as the set of oriented surfels between spels of <em>S</em> and spels not in <em>S</em>. Algebraically, <em>S</em> is the formal of its positively oriented spels, and its <em>boundary</em> is obtained by applying the boundary operator on <em>S</em>.</p>
<div class="image">
<img src="digital-surface-BdryOp-1s.png" alt=""/>
<div class="caption">
Using the boundary operator to compute the boundary of a digital shape S.</div></div>
  <div class="image">
<img src="digital-surface-BdryOp-2s.png" alt=""/>
<div class="caption">
The boundary operator is linear with cells, thus we compute spel by spel.</div></div>
  <div class="image">
<img src="digital-surface-BdryOp-3s.png" alt=""/>
<div class="caption">
The boundary operator is linear with cells, thus we compute spel by spel.</div></div>
  <div class="image">
<img src="digital-surface-BdryOp-4s.png" alt=""/>
<div class="caption">
Opposite cells cancel each other.</div></div>
  <div class="image">
<img src="digital-surface-BdryOp-5s.png" alt=""/>
<div class="caption">
This is the resulting set of surfels (in blue and magenta.</div></div>
 <p>Defining a digital surface as a set of surfels is not enough for geometry. Indeed we need to relate surfels together so as to have a topology on the digital surface. The first step is to transform the digital surface into a graph.</p>
<h2><a class="anchor" id="dgtal_digsurf_sec1_3"></a>
Digital surface as a graph: adding adjacencies between surfels</h2>
<p>The idea here is to connect surfels that share some \(n-2\)-cells. The obtained adjacency relations are called <em>bel</em> <em>adjacencies</em> in the terminology of Herman, Udupa and others. Generally an \(n-2\)-cell is shared by at most two \(n-1\)-cells, except in "cross
configuration", symbolized below:</p>
<pre class="fragment">   O | X    X: interior spels               O a X
   - + -    O: exterior spels               b + c
   X | O    - and |: surfels a,b,c,d        X d O
            +: n-2-cell 
</pre><p>A bel adjacency makes a deterministic choice to connect b to d and a to c when interior, and b to a and c to d when exterior. This choice has to be made along each possible pair of directions when going nD. In <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>, this is encoded with the class <a class="el" href="classDGtal_1_1SurfelAdjacency.html" title="Aim: Represent adjacencies between surfel elements, telling if it follows an interior to exterior ord...">SurfelAdjacency</a>.</p>
<div class="image">
<img src="digital-surface-IntAdjacency.png" alt=""/>
<div class="caption">
Interior adjacency on digital surfaces in 2D</div></div>
 <p>The following snippet shows the interior surfel adjacency (i.e. (6,18)-surfaces).</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> SurfelAdjacency&lt;KSpace::dimension&gt; MySurfelAdjacency;</div>
<div class="line">  MySurfelAdjacency surfAdj( intAdjacency ); <span class="comment">// interior in all directions.</span></div>
</div><!-- fragment --><p> Once the adjacency has been chosen, it is possible to determine what are the adjacent surfels to a given surfel. More precisely, any surfel (or \(n-1\)-cell) has exactly \(2n-2\) adjacent surfels (for closed surfaces). More precisely, it has exactly 2 adjacent surfels along directions different from the orthogonal direction of the surfel.</p>
<div class="image">
<img src="digital-surface-SurfaceTracking2.png" alt=""/>
<div class="caption">
Any surfel in 3D has 4 adjacent surfels.</div></div>
 <p>In fact, we can be even more precise. We can use orientation to orient the adjacencies consistently. Given two surfels sharing an \(n-2\)-cell, this cell is positively oriented in the boundary of one surfel and negatively oriented in the boundary of the other. We have thus that there are \(n-1\) adjacent cells in the direct orientation (positive) and \(n-1\) adjacent cells in the indirect orientation (negative). The direct adjacent surfels look like:</p>
<div class="image">
<img src="digital-surface-SurfaceTracking.png" alt=""/>
<div class="caption">
Any surfel in 3D has 2 adjacent surfels in the direct orientation.</div></div>
 <p>The class <a class="el" href="classDGtal_1_1SurfelNeighborhood.html" title="Aim: This helper class is useful to compute the neighboring surfels of a given surfel,...">SurfelNeighborhood</a> is the base class for computing adjacent surfels. You may use it as follow, but generally this class is hidden for you since you will have more high-level classes to move on surfaces.</p>
<div class="fragment"><div class="line"><span class="comment">// K is a KSpace, surfAdj is a SurfelAdjacency, surfel is some SCell.</span></div>
<div class="line">SurfelNeighborhood&lt;KSpace&gt; sNeigh;</div>
<div class="line">sNeigh.init( &amp;<a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, &amp;SAdj, surfel );</div>
<div class="line"><a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;surfel=&quot;</span> &lt;&lt; surfel &lt;&lt; endl;</div>
<div class="line"><a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;follower1(+)=&quot;</span> &lt;&lt; sNeigh.follower1( 1, <span class="keyword">true</span> ) &lt;&lt; endl;</div>
<div class="line"><a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;follower2(+)=&quot;</span> &lt;&lt; sNeigh.follower2( 1, <span class="keyword">true</span> ) &lt;&lt; endl;</div>
<div class="line"><a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;follower3(+)=&quot;</span> &lt;&lt; sNeigh.follower3( 1, <span class="keyword">true</span> ) &lt;&lt; endl;</div>
<div class="line"><a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;follower1(-)=&quot;</span> &lt;&lt; sNeigh.follower1( 1, <span class="keyword">false</span> ) &lt;&lt; endl;</div>
<div class="line"><a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;follower2(-)=&quot;</span> &lt;&lt; sNeigh.follower2( 1, <span class="keyword">false</span> ) &lt;&lt; endl;</div>
<div class="line"><a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;follower3(-)=&quot;</span> &lt;&lt; sNeigh.follower3( 1, <span class="keyword">false</span> ) &lt;&lt; endl;</div>
<div class="line"><a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">endBlock</a>();</div>
</div><!-- fragment --><p>Generally, methods <a class="el" href="classDGtal_1_1SurfelNeighborhood.html#a72314f00ceb218840941603a747ed943">SurfelNeighborhood::getAdjacentOnSpelSet</a>, <a class="el" href="classDGtal_1_1SurfelNeighborhood.html#af068272b417d474fb2da209ac4fffadd">SurfelNeighborhood::getAdjacentOnDigitalSet</a>, <a class="el" href="classDGtal_1_1SurfelNeighborhood.html#a037decca8ea4fa23ec595887d1664644">SurfelNeighborhood::getAdjacentOnPointPredicate</a>, <a class="el" href="classDGtal_1_1SurfelNeighborhood.html#a956a08b53dbfbc908f698afd7ccf994f">SurfelNeighborhood::getAdjacentOnSurfelPredicate</a> are used to find adjacent surfels.</p>
<p>Since we have defined adjacencies between surfels on a digital surface, the digital surface forms a graph (at least in theory).</p>
<h1><a class="anchor" id="dgtal_digsurf_sec2"></a>
Tracking digital surfaces</h1>
<p>This section shows how to extract the boundary of a digital set, given some predicate telling whether we are inside or outside the surface.</p>
<h2><a class="anchor" id="dgtal_digsurf_sec2_1"></a>
Constructing digital surfaces by scanning</h2>
<p>Given a domain and a predicate telling whether we are inside or outside the object of interest, it is easy to determine the set of surfels by a simple scanning of the space. This is done for you by static methods <a class="el" href="classDGtal_1_1Surfaces.html#a7c4c49a163650eaaff8759504d7891f7">Surfaces::uMakeBoundary</a> and <a class="el" href="classDGtal_1_1Surfaces.html#af61619b3dbd948aea387202369bddd6f">Surfaces::sMakeBoundary</a>.</p>
<p>The following snippet shows how to get a set of surfels that is the boundary of some predicate on point by a simple scan of the whole domain (see <a class="el" href="volScanBoundary_8cpp.html">volScanBoundary.cpp</a>).</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a>( <span class="stringliteral">&quot;Extracting boundary by scanning the space. &quot;</span> );</div>
<div class="line">  <a class="code" href="classDGtal_1_1KhalimskySpaceND.html#ae6cf442a7d0a46d254f9fbdd7237ab11">KSpace::SCellSet</a> boundary;</div>
<div class="line">  <a class="code" href="classDGtal_1_1Surfaces.html#af61619b3dbd948aea387202369bddd6f">Surfaces&lt;KSpace&gt;::sMakeBoundary</a>( boundary, ks, set3d,</div>
<div class="line">                                   image.domain().lowerBound(),</div>
<div class="line">                                   image.domain().upperBound() );</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">endBlock</a>();</div>
</div><!-- fragment --> <h2><a class="anchor" id="dgtal_digsurf_sec2_2"></a>
Constructing digital surfaces by tracking</h2>
<p>In many circumstances, it is better to use the above mentioned graph structure of digital surfaces. For instance it may be used to find the surface just by searching it by adjacencies. This process is called <b>tracking</b>. This is done for you by static method <a class="el" href="classDGtal_1_1Surfaces.html#a274dbb659f269382154035ae61d7e7b3">Surfaces::trackBoundary</a>.</p>
<p>The following snippet shows how to get a set of surfels that is the boundary of some predicate on point given only a starting surfel and by tracking (see <a class="el" href="volTrackBoundary_8cpp.html">volTrackBoundary.cpp</a>).</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a>( <span class="stringliteral">&quot;Extracting boundary by tracking from an initial bel.&quot;</span> );</div>
<div class="line">  <a class="code" href="classDGtal_1_1KhalimskySpaceND.html#ae6cf442a7d0a46d254f9fbdd7237ab11">KSpace::SCellSet</a> boundary;</div>
<div class="line">  <a class="code" href="structDGtal_1_1SignedKhalimskyCell.html">SCell</a> bel = <a class="code" href="classDGtal_1_1Surfaces.html#a48e3a0e7c4728f6a6f23ec6f468a41b8">Surfaces&lt;KSpace&gt;::findABel</a>( ks, set3d, 100000 );</div>
<div class="line">  <a class="code" href="classDGtal_1_1Surfaces.html#a274dbb659f269382154035ae61d7e7b3">Surfaces&lt;KSpace&gt;::trackBoundary</a>( boundary, ks, </div>
<div class="line">                                   surfAdj,</div>
<div class="line">                                   set3d, bel );</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">endBlock</a>();</div>
</div><!-- fragment --><p> On the lobser.vol volume, <a class="el" href="volScanBoundary_8cpp.html">volScanBoundary.cpp</a> extracts 155068 surfels in 3866ms, while <a class="el" href="volTrackBoundary_8cpp.html">volTrackBoundary.cpp</a> extracts 148364 surfels in 351ms.</p>
<pre class="fragment"># Commands
$ ./examples/topology/volScanBoundary ../examples/samples/lobster.vol 50 255
$ ./examples/topology/volTrackBoundary ../examples/samples/lobster.vol 50 255
</pre><div class="image">
<img src="volTrackBoundary-lobster.png" alt=""/>
<div class="caption">
Digital surface that is the boundary of a (6,18)-connected component in image lobster.vol, extracted by tracking from an initial surfel in 351ms.</div></div>
 <p>In the case you know <b>beforehands</b> that your surface is closed (i.e. without boundary), you should use preferentially <a class="el" href="classDGtal_1_1Surfaces.html#a1d3cf3c5f54d0b556630f9dde154968d">Surfaces::trackClosedBoundary</a>. This technique only follows direct adjacent surfels and extracts the whole surface when it is closed. This process can be illustrated as follows:</p>
<div class="image">
<img src="suivi-parcours-largeur.png" alt=""/>
<div class="caption">
Tracking a digital surface by following adjacencies.</div></div>
  <div class="image">
<img src="suivi-artzy.png" alt=""/>
<div class="caption">
Tracking a digital surface by following only direct adjacencies.</div></div>
 <h2><a class="anchor" id="dgtal_digsurf_sec2_3"></a>
Other constructions by tracking: 2D contours, surface connected components, 2D slices in 3D surface</h2>
<p>You can have a look at page <a class="el" href="moduleDigitalSurfaceHelpers.html">Helpers for digital surfaces</a> to see how to construct directly a 2D contour in \( Z^2 \), how to get the set of surface components, how to get 2D contours as slices onto a 3D surface.</p>
<p>You may also use the template class <a class="el" href="classDGtal_1_1DigitalSurface2DSlice.html" title="Aim: Represents a 2-dimensional slice in a DigitalSurface. In a sense, it is a 4-connected contour,...">DigitalSurface2DSlice</a>, which, given a tracker on a digital surface, computes and store a 2d slice on the associated surface. You may after visit the slice with iterators or circulators. </p><div class="fragment"><div class="line"><span class="comment">// Tracker is a type of tracker on some digital surface.</span></div>
<div class="line"><span class="keyword">typedef</span> DigitalSurface2DSlice&lt;Tracker&gt; MySlice;</div>
<div class="line">Tracker* ptrTracker = ... ; <span class="comment">// some pointer on a tracker.</span></div>
<div class="line">MySlice slicex( ptrTracker, 0 ); <span class="comment">// slice containing x-axis</span></div>
<div class="line">MySlice slicey( ptrTracker, 1 ); <span class="comment">// slice containing y-axis</span></div>
<div class="line">MySlice slicez( ptrTracker, 2 ); <span class="comment">// slice containing z-axis</span></div>
<div class="line"><span class="comment">// One of them is invalid in 3D.</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="digitalSurfaceSlice_8cpp.html">digitalSurfaceSlice.cpp</a></dd></dl>
<h1><a class="anchor" id="dgtal_digsurf_sec3"></a>
High-level classes for digital surfaces</h1>
<p>Digital surfaces arise in many different contexts:</p>
<ul>
<li>an explicit set of oriented surfels</li>
<li>the boundary of an explicit set of spels</li>
<li>the boundary of an explicit set of digital points</li>
<li>the boundary of a set of digital points, defined implicitly by a predicate: Point -&gt; bool</li>
<li>a set of oriented surfels, defined implicitly by a predicate: Surfel -&gt; bool</li>
<li>a set of oriented surfels, implicitly by a predicate: Oriented Surfel -&gt; bool</li>
<li>the boundary of a region in a labelled image</li>
<li>the frontier between two regions in a labelled image</li>
<li>...</li>
</ul>
<p>Since there are so many digital surfaces, it is necessary to provide a mechanism to handle them generically. The class <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a> will be the common proxy to hide models of <a class="el" href="structDGtal_1_1concepts_1_1CDigitalSurfaceContainer.html" title="Aim: The digital surface container concept describes a minimal set of inner types and methods so as t...">concepts::CDigitalSurfaceContainer</a>.</p>
<h2><a class="anchor" id="dgtal_digsurf_sec3_1"></a>
A common architecture for digital surfaces</h2>
<p>Since there may be several types of digital surfaces, there are several container classes for them. All of them follow the concept <a class="el" href="structDGtal_1_1concepts_1_1CDigitalSurfaceContainer.html" title="Aim: The digital surface container concept describes a minimal set of inner types and methods so as t...">concepts::CDigitalSurfaceContainer</a>. Essentially, a model of this class should provide methods begin() and end() to visit all the surfels, and a <em>Tracker</em> which allows to move by adjacencies on the surface. A Tracker should be a model of <a class="el" href="structDGtal_1_1concepts_1_1CDigitalSurfaceTracker.html" title="Aim:">concepts::CDigitalSurfaceTracker</a>. The architecture is sumed up below:</p>
<div class="image">
<img src="diag-digital-surface-1.png" alt=""/>
<div class="caption">
Class architecture of digital surfaces.</div></div>
 <h2><a class="anchor" id="dgtal_digsurf_sec3_2"></a>
Models of digital surface containers</h2>
<p>For now, the implemented digital surface container are (realization of <a class="el" href="structDGtal_1_1concepts_1_1CDigitalSurfaceContainer.html" title="Aim: The digital surface container concept describes a minimal set of inner types and methods so as t...">concepts::CDigitalSurfaceContainer</a>):</p>
<ul>
<li>model <a class="el" href="classDGtal_1_1DigitalSetBoundary.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of a given...">DigitalSetBoundary</a>, parameterized by a cellular space and a digital set. Represents the boundary of a digital set (a set of digital points, considered as the set of pixels/voxels/spels of the space).</li>
<li>model <a class="el" href="classDGtal_1_1ImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">ImplicitDigitalSurface</a>, parameterized by a cellular space and a predicate Point-&gt;bool. Represents the (connected) boundary of shape defined implicitly by a predicate. Computes at instanciation the set of surfels by a tracking algorithm.</li>
<li>model <a class="el" href="classDGtal_1_1LightImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">LightImplicitDigitalSurface</a>, parameterized by a cellular space and a predicate Point-&gt;bool. Represents the (connected) boundary of shape defined implicitly by a predicate. Do not compute at instanciation the set of surfels, but rather visits the surface on demand.</li>
<li>model <a class="el" href="classDGtal_1_1SetOfSurfels.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels....">SetOfSurfels</a>, parameterized by a cellular space and a set storing surfels. Represents an arbitrary set of surfels stored explicitly.</li>
<li>model <a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels....">ExplicitDigitalSurface</a>, parameterized by a cellular space and a predicate Surfel-&gt;bool. Represents a (connected) set of surfels defined implicitly by a predicate. Computes at instanciation the set of surfels by a tracking algorithm.</li>
<li>model <a class="el" href="classDGtal_1_1LightExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels....">LightExplicitDigitalSurface</a>, parameterized by a cellular space and a predicate Surfel-&gt;bool. Represents a (connected) set of surfels defined implicitly by a predicate. Do not compute at instanciation the set of surfels, but rather visits the surface on demand.</li>
</ul>
<p>Depending of what is your digital surface, you should choose your container accordingly:</p><ul>
<li>an explicit set of oriented surfels: model <a class="el" href="classDGtal_1_1SetOfSurfels.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels....">SetOfSurfels</a>, or if you wish to keep only one connected component, the model <a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels....">ExplicitDigitalSurface</a> together with a model of <a class="el" href="structDGtal_1_1concepts_1_1CSurfelPredicate.html" title="Aim: Defines a predicate on a surfel.">concepts::CSurfelPredicate</a> on your set.</li>
<li>the boundary of an explicit set of spels: either convert it to a DigitalSet and use model <a class="el" href="classDGtal_1_1DigitalSetBoundary.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of a given...">DigitalSetBoundary</a>, or use model <a class="el" href="classDGtal_1_1ImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">ImplicitDigitalSurface</a> and a <a class="el" href="structDGtal_1_1concepts_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">concepts::CPointPredicate</a> on your set of spels (require connectedness).</li>
<li>the boundary of an explicit set of digital points: model <a class="el" href="classDGtal_1_1DigitalSetBoundary.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of a given...">DigitalSetBoundary</a> directly</li>
<li>the boundary of a set of digital points, defined implicitly by a predicate Point -&gt; bool: model <a class="el" href="classDGtal_1_1ImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">ImplicitDigitalSurface</a> and a start surfel</li>
<li>a set of oriented surfels, defined implicitly by a predicate Surfel -&gt; bool: model <a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels....">ExplicitDigitalSurface</a> and a start surfel.</li>
<li>the boundary of a region in a labelled image: model <a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels....">ExplicitDigitalSurface</a> and a start surfel, and the class <a class="el" href="classDGtal_1_1functors_1_1BoundaryPredicate.html" title="Aim: The predicate on surfels that represents the frontier between a region and its complementary in ...">functors::BoundaryPredicate</a>, which is model of <a class="el" href="structDGtal_1_1concepts_1_1CSurfelPredicate.html" title="Aim: Defines a predicate on a surfel.">concepts::CSurfelPredicate</a>.</li>
<li>the frontier between two regions in a labelled image: model <a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels....">ExplicitDigitalSurface</a> and a start surfel, and the class <a class="el" href="classDGtal_1_1functors_1_1FrontierPredicate.html" title="Aim: The predicate on surfels that represents the frontier between two regions in an image....">functors::FrontierPredicate</a>, which is model of <a class="el" href="structDGtal_1_1concepts_1_1CSurfelPredicate.html" title="Aim: Defines a predicate on a surfel.">concepts::CSurfelPredicate</a>.</li>
</ul>
<p>Light versions of containers should be preferred in mostly two cases:</p>
<ol type="1">
<li>The digital surface is big and you do not wish to keep it in memory. This is probably the case when tracking some implicit function and outputing it in some stream.</li>
<li>The digital surface is likely to evolve (i.e. the predicate do not give the same response at a point/surfel depending on when it is called).</li>
</ol>
<h2><a class="anchor" id="dgtal_digsurf_sec3_3"></a>
Relating a digital surface to some container</h2>
<p>The following snippet shows how to create a digital surface associated to a <a class="el" href="classDGtal_1_1LightImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">LightImplicitDigitalSurface</a>. The <a class="el" href="classDGtal_1_1LightImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">LightImplicitDigitalSurface</a> is connected to a shape described by a predicate on point (a simple digital set). The full code is in <a class="el" href="volBreadthFirstTraversal_8cpp.html">volBreadthFirstTraversal.cpp</a>.</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a>( <span class="stringliteral">&quot;Set up digital surface.&quot;</span> );</div>
<div class="line">  <span class="keyword">typedef</span> LightImplicitDigitalSurface&lt;KSpace, DigitalSet &gt;</div>
<div class="line">    <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#ac9ee7087e3a195e77c3d27a1b002d6d6">MyDigitalSurfaceContainer</a>;</div>
<div class="line">  <span class="keyword">typedef</span> DigitalSurface&lt;MyDigitalSurfaceContainer&gt; <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a03d731f44ed1110acdbefdc2357f84cf">MyDigitalSurface</a>;</div>
<div class="line">  <a class="code" href="structDGtal_1_1SignedKhalimskyCell.html">SCell</a> bel = <a class="code" href="classDGtal_1_1Surfaces.html#a48e3a0e7c4728f6a6f23ec6f468a41b8">Surfaces&lt;KSpace&gt;::findABel</a>( ks, set3d, 100000 );</div>
<div class="line">  <a class="code" href="classDGtal_1_1DigitalSetBoundary.html">MyDigitalSurfaceContainer</a>* ptrSurfContainer =</div>
<div class="line">    <span class="keyword">new</span> <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#ac9ee7087e3a195e77c3d27a1b002d6d6">MyDigitalSurfaceContainer</a>( ks, set3d, surfAdj, bel );</div>
<div class="line">  <a class="code" href="classDGtal_1_1DigitalSurface.html">MyDigitalSurface</a> digSurf( ptrSurfContainer ); <span class="comment">// acquired</span></div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">endBlock</a>();</div>
</div><!-- fragment --><p> Once this is done, the object <code>digSurf</code> is a proxy to your container. Here the dynamically allocated object is acquired by the digital surface, which will take care of its deletion.</p>
<dl class="section note"><dt>Note</dt><dd>This creation of the container and the connection to a digital surface takes almost no time, since the chosen container (Light...) is lazy: the whole surface has not been extracted yet.</dd></dl>
<h2><a class="anchor" id="dgtal_digsurf_sec3_4"></a>
A digital surface is a graph, example of breadth-first traversal</h2>
<p>Any <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a> is a model of <a class="el" href="structDGtal_1_1concepts_1_1CUndirectedSimpleGraph.html" title="Aim: Represents the concept of local graph: each vertex has neighboring vertices, but we do not neces...">concepts::CUndirectedSimpleGraph</a> (a refinement of <a class="el" href="structDGtal_1_1concepts_1_1CUndirectedSimpleLocalGraph.html" title="Aim: Represents the concept of local graph: each vertex has neighboring vertices, but we do not neces...">concepts::CUndirectedSimpleLocalGraph</a>). Essentially, you have methods <a class="el" href="classDGtal_1_1DigitalSurface.html#a876e5a84ca1ccb99ec16feabf1912470">DigitalSurface::begin()</a> and <a class="el" href="classDGtal_1_1DigitalSurface.html#a976e9b87d1ac2ff3387d37419b9a293d">DigitalSurface::end()</a> to visit all the vertices, and for each vertex, you obtain its neighbors with <a class="el" href="classDGtal_1_1DigitalSurface.html#af3ae5c29d59009041a76fcb64ecd3dde">DigitalSurface::writeNeighbors</a>. You may thus for instance use the class <a class="el" href="classDGtal_1_1BreadthFirstVisitor.html" title="Aim: This class is useful to perform a breadth-first exploration of a graph given a starting point or...">BreadthFirstVisitor</a> to do a breadth-first traversal of the digital surface.</p>
<p>We may extract the whole surface by doing a breadth-first traversal on the graph. The snippet below shows how to do it on any kind of digital surface, whatever the container.</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a>( <span class="stringliteral">&quot;Extracting boundary by tracking from an initial bel.&quot;</span> );</div>
<div class="line">  <span class="keyword">typedef</span> BreadthFirstVisitor&lt;MyDigitalSurface&gt; MyBreadthFirstVisitor;</div>
<div class="line">  <span class="keyword">typedef</span> MyBreadthFirstVisitor::Node MyNode;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code" href="testHalfEdgeDataStructure_8cpp.html#a1aba5499fd29449181365ce424303a10">MyBreadthFirstVisitor::Size</a> MySize;</div>
<div class="line">  MyBreadthFirstVisitor visitor( digSurf, bel );</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> nbSurfels = 0;</div>
<div class="line">  MyNode node;</div>
<div class="line">  <span class="keywordflow">while</span> ( ! visitor.finished() )</div>
<div class="line">    {</div>
<div class="line">      node = visitor.current();</div>
<div class="line">      ++nbSurfels;</div>
<div class="line">      visitor.expand();</div>
<div class="line">    }</div>
<div class="line">  MySize maxDist = node.second;</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">endBlock</a>();</div>
</div><!-- fragment --><p> Here, we only use it to get the maximal distance to the starting bel. A second pass could be done to display cells with a color that depends on the distance to the starting surfel.</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a>( <span class="stringliteral">&quot;Displaying surface in Viewer3D.&quot;</span> );</div>
<div class="line">  QApplication application(argc,argv);</div>
<div class="line">  Viewer3D&lt;&gt; viewer;</div>
<div class="line">  viewer.show();</div>
<div class="line">  HueShadeColorMap&lt;MySize,1&gt; hueShade( 0, maxDist );</div>
<div class="line">  MyBreadthFirstVisitor visitor2( digSurf, bel );</div>
<div class="line">  viewer &lt;&lt; CustomColors3D( <a class="code" href="classDGtal_1_1Color.html#ac26d8585885e7a354893b7e93c6a9dda">Color::Black</a>, <a class="code" href="classDGtal_1_1Color.html#ab7b17778033da4f2ce2825d385e53d90">Color::White</a> )</div>
<div class="line">         &lt;&lt; ks.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a22d8a0b3bf9ab0c07596ff57af908f92">unsigns</a>( bel );</div>
<div class="line">  visitor2.expand();</div>
<div class="line">  <span class="keywordflow">while</span> ( ! visitor2.finished() )</div>
<div class="line">    {</div>
<div class="line">      node = visitor2.current();</div>
<div class="line">      Color c = hueShade( node.second );</div>
<div class="line">      viewer &lt;&lt; CustomColors3D( <a class="code" href="classDGtal_1_1Color.html#aa5e8679bd0da49f95d13cd95a17b619b">Color::Red</a>, c )</div>
<div class="line">             &lt;&lt; ks.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a22d8a0b3bf9ab0c07596ff57af908f92">unsigns</a>( node.first );</div>
<div class="line">      visitor2.expand();</div>
<div class="line">    }</div>
<div class="line">  viewer &lt;&lt; Viewer3D&lt;&gt;::updateDisplay;</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;nb surfels = &quot;</span> &lt;&lt; nbSurfels &lt;&lt; std::endl;</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">endBlock</a>();</div>
<div class="line">  <span class="keywordflow">return</span> application.exec();</div>
</div><!-- fragment --><p> We may call it as follows </p><pre class="fragment"># Commands
$ ./examples/topology/volBreadthFirstTraversal ../examples/samples/lobster.vol 50 255
$ ./examples/topology/volBreadthFirstTraversal ../examples/samples/Al.100.vol 0 1
$ ./examples/topology/volBreadthFirstTraversal ../examples/samples/cat10.vol 1 255
</pre><p>to get these pictures: </p><div class="image">
<img src="digital-surface-bfv-all.png" alt=""/>
<div class="caption">
Examples of breadth-first traversal on a digital surface.</div></div>
 <dl class="section note"><dt>Note</dt><dd>In fact, the specific container <a class="el" href="classDGtal_1_1LightImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">LightImplicitDigitalSurface</a> performs itself a breadth-first traversal to extract its vertices by itself. Therefere, you may use a simple begin() and end() to get the vertices in this order, when <b>your</b> <b>container</b> <b>is</b> <b>a</b> <b><a class="el" href="classDGtal_1_1LightImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">LightImplicitDigitalSurface</a></b>.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000072">Todo:</a></b></dt><dd>The concepts <a class="el" href="structDGtal_1_1concepts_1_1CUndirectedSimpleLocalGraph.html" title="Aim: Represents the concept of local graph: each vertex has neighboring vertices, but we do not neces...">concepts::CUndirectedSimpleLocalGraph</a> and <a class="el" href="structDGtal_1_1concepts_1_1CUndirectedSimpleGraph.html" title="Aim: Represents the concept of local graph: each vertex has neighboring vertices, but we do not neces...">concepts::CUndirectedSimpleGraph</a> are susceptible to evolve to meet other standards.</dd></dl>
<h2><a class="anchor" id="dgtal_digsurf_sec3_5"></a>
Boundary and frontiers  examples of digital surface</h2>
<p>Surfels of a digital surface can also be defined by a predicate telling whether or not some surfel belongs to it. Given an image of labels, the class <a class="el" href="classDGtal_1_1functors_1_1BoundaryPredicate.html" title="Aim: The predicate on surfels that represents the frontier between a region and its complementary in ...">functors::BoundaryPredicate</a> and <a class="el" href="classDGtal_1_1functors_1_1FrontierPredicate.html" title="Aim: The predicate on surfels that represents the frontier between two regions in an image....">functors::FrontierPredicate</a> are such predicates:</p>
<ol type="1">
<li><a class="el" href="classDGtal_1_1functors_1_1BoundaryPredicate.html" title="Aim: The predicate on surfels that represents the frontier between a region and its complementary in ...">functors::BoundaryPredicate</a> ( KSpace, <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a>, l ) is a predicate returning true for a surfel <em>s</em> iff the interior spel of <em>s</em> has label <code>l</code> while the exterior spel of <em>s</em> has label different from <code>l</code>.</li>
<li><a class="el" href="classDGtal_1_1functors_1_1FrontierPredicate.html" title="Aim: The predicate on surfels that represents the frontier between two regions in an image....">functors::FrontierPredicate</a> ( KSpace, <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a>, l1, l2 ) is a predicate returning true for a surfel <em>s</em> iff the interior spel of <em>s</em> has label <code>l1</code> while the exterior spel of <em>s</em> has label <code>l2</code>.</li>
</ol>
<p>Using container <a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels....">ExplicitDigitalSurface</a>, we can very simply define digital surfaces that are <b>connected</b> boundary of frontiers in some image. The following snippet is an excerpt from <a class="el" href="frontierAndBoundary_8cpp.html">frontierAndBoundary.cpp</a>.</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a>( <span class="stringliteral">&quot;Set up digital surface.&quot;</span> );</div>
<div class="line">  <span class="keyword">typedef</span> SurfelAdjacency&lt;KSpace::dimension&gt; MySurfelAdjacency;</div>
<div class="line">  MySurfelAdjacency surfAdj( <span class="keyword">true</span> ); <span class="comment">// interior in all directions.</span></div>
<div class="line">  <span class="keyword">typedef</span> functors::FrontierPredicate&lt;KSpace, Image&gt; FSurfelPredicate;</div>
<div class="line">  <span class="keyword">typedef</span> ExplicitDigitalSurface&lt;KSpace,FSurfelPredicate&gt; FrontierContainer;</div>
<div class="line">  <span class="keyword">typedef</span> DigitalSurface&lt;FrontierContainer&gt; Frontier;</div>
<div class="line">  <span class="keyword">typedef</span> functors::BoundaryPredicate&lt;KSpace, Image&gt; BSurfelPredicate;</div>
<div class="line">  <span class="keyword">typedef</span> ExplicitDigitalSurface&lt;KSpace,BSurfelPredicate&gt; BoundaryContainer;</div>
<div class="line">  <span class="keyword">typedef</span> DigitalSurface&lt;BoundaryContainer&gt; Boundary;</div>
<div class="line">  <span class="comment">// frontier between label 1 and 0 (connected part containing bel10)</span></div>
<div class="line">  <a class="code" href="structDGtal_1_1SignedKhalimskyCell.html">SCell</a> vox1  = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a7d5231f241513f15be0a1ee092db2590">sSpel</a>( c1 + <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>( radius1, 0, 0 ), <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a30ed0a752d1e58dfd12f4f905dba38aa">POS</a> );</div>
<div class="line">  <a class="code" href="structDGtal_1_1SignedKhalimskyCell.html">SCell</a> bel10 = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#adcda490970c3962a731a5ad604ef5ce6">sIncident</a>( vox1, 0, <span class="keyword">true</span> );</div>
<div class="line">  FSurfelPredicate surfPredicate10( <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, image, 1, 0 );</div>
<div class="line">  Frontier frontier10 =</div>
<div class="line">    <span class="keyword">new</span> FrontierContainer( <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, surfPredicate10, surfAdj, bel10 );</div>
<div class="line">  <span class="comment">// frontier between label 2 and 0 (connected part containing bel20)</span></div>
<div class="line">  <a class="code" href="structDGtal_1_1SignedKhalimskyCell.html">SCell</a> vox2  = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a7d5231f241513f15be0a1ee092db2590">sSpel</a>( c2 - <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>( radius2, 0, 0 ), <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a30ed0a752d1e58dfd12f4f905dba38aa">POS</a> );</div>
<div class="line">  <a class="code" href="structDGtal_1_1SignedKhalimskyCell.html">SCell</a> bel20 = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#adcda490970c3962a731a5ad604ef5ce6">sIncident</a>( vox2, 0, <span class="keyword">false</span> );</div>
<div class="line">  FSurfelPredicate surfPredicate20( <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, image, 2, 0 );</div>
<div class="line">  Frontier frontier20 =</div>
<div class="line">    <span class="keyword">new</span> FrontierContainer( <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, surfPredicate20, surfAdj, bel20 );</div>
<div class="line">  <span class="comment">// boundary of label 3 (connected part containing bel32)</span></div>
<div class="line">  <a class="code" href="structDGtal_1_1SignedKhalimskyCell.html">SCell</a> vox3  = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a7d5231f241513f15be0a1ee092db2590">sSpel</a>( c1 - <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>( radius1, 0, 0 ), <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a30ed0a752d1e58dfd12f4f905dba38aa">POS</a> );</div>
<div class="line">  <a class="code" href="structDGtal_1_1SignedKhalimskyCell.html">SCell</a> bel32 = <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#adcda490970c3962a731a5ad604ef5ce6">sIncident</a>( vox3, 0, <span class="keyword">false</span> );</div>
<div class="line">  BSurfelPredicate surfPredicate3( <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, image, 3 );</div>
<div class="line">  Boundary boundary3 =</div>
<div class="line">    <span class="keyword">new</span> BoundaryContainer( <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, surfPredicate3, surfAdj, bel32 );</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">endBlock</a>();</div>
</div><!-- fragment --><p> Running it give the pictures: </p><div class="image">
<img src="digital-surface-intersecting-balls.png" alt=""/>
<div class="caption">
Frontiers and boundary of two intersecting balls. The first ball is labelled 1 (red), the second 2 (yellow), their intersection 3 (orange). The frontier between 1 and 0 is displayed in red, the frontier between 2 and 0 is displayed in yellow, the boundary of region 3 is displayed in orange.</div></div>
 <h1><a class="anchor" id="dgtal_digsurf_sec4"></a>
The digital surface graph is a combinatorial manifold</h1>
<h2><a class="anchor" id="dgtal_digsurf_sec4_1"></a>
Umbrellas and faces</h2>
<p>We have shown before that a digital surface has a dual structure that is the graph whose vertices are n-1-cells and whose arcs are (almost) n-2-cells. We can go further and use n-3-cells to define faces on this graph. This is related to the concept of <b>umbrellas</b> in 3D (see <a class="el" href="citelist.html#CITEREF_papier1998">[75]</a>). More precisely, given a start surfel, an incident n-2-cell (the separator) and an incident n-3-cell (the pivot), one can turn around the pivot progressively to get a face. This gives precisely in 3D the dual to a digital surface that is a kind of marching-cube surface (see <a class="el" href="citelist.html#CITEREF_Lachaud:1998-icip">[56]</a>, <a class="el" href="citelist.html#CITEREF_Lachaud:2000-gmod">[57]</a>).</p>
<p>The main class for computing umbrellas is the class <a class="el" href="classDGtal_1_1UmbrellaComputer.html" title="Aim: Useful for computing umbrellas on &#39;DigitalSurface&#39;s, ie set of n-1 cells around a n-3 cell.">UmbrellaComputer</a>. Turning around the pivot means moving the face and the separator once (in the track direction), such that the pivot is the same (ie <em>+p</em>), the track and separator directions being updated. Repeating this process a sufficient number of times brings the umbrella back in its original position, except in the case when the <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a> has a boundary touching the pivot. You may use it to compute umbrellas given a tracker on your surface.</p>
<p>You may look at file <a class="el" href="testUmbrellaComputer_8cpp.html">testUmbrellaComputer.cpp</a> to see how to use this class directly.</p>
<h2><a class="anchor" id="dgtal_digsurf_sec4_2"></a>
Vertices, arcs and faces on a digital surface</h2>
<p>However, it is simpler to use directly the methods defined in <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>. It offers three types: <a class="el" href="classDGtal_1_1DigitalSurface.html#a637f8034aff12a2f65fe9cc47c95b8db" title="Defines the type for a vertex.">DigitalSurface::Vertex</a>, <a class="el" href="structDGtal_1_1DigitalSurface_1_1Arc.html">DigitalSurface::Arc</a>, <a class="el" href="structDGtal_1_1DigitalSurface_1_1Face.html">DigitalSurface::Face</a> to get the combinatorial structure of the surface. An arc is an oriented edge, a face is a sequence of edges that is closed when the pivot is not on the boundary and open otherwise.</p>
<p>The following code lists the faces of a <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a> object, and for each face it lists the coordinates of its vertices.</p>
<div class="fragment"><div class="line"><span class="comment">// MyDigitalSurface is a DigitalSurface realization.</span></div>
<div class="line"><span class="comment">// digSurf is any object of type MyDigitalSurface. </span></div>
<div class="line"><span class="comment">// K is a cellular space. </span></div>
<div class="line"><a class="code" href="classDGtal_1_1DigitalSurface.html#aca5daf921da1f67b921cfc109f2dbb20">MyDigitalSurface::FaceSet</a> all_faces = digSurf.allFaces();</div>
<div class="line"><span class="keywordflow">for</span> ( <span class="keyword">auto</span> it = all_faces.begin(), it_end = all_faces.end(); it != it_end; ++it )</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot; face=&quot;</span> &lt;&lt; <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a52197498d5f2961b2ced5b7cb821ec40">sKCoords</a>( digSurf.pivot( *it ) ) &lt;&lt; <span class="stringliteral">&quot;:&quot;</span>;</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; it-&gt;nbVertices &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; (it-&gt;isClosed() ? <span class="stringliteral">&quot;C&quot;</span>: <span class="stringliteral">&quot;O&quot;</span>);</div>
<div class="line">    <a class="code" href="classDGtal_1_1DigitalSurface.html#a7bbab2b7e1bedf06738f5151d1157b37">MyDigitalSurface::VertexRange</a> vtx = digSurf.verticesAroundFace( *it );</div>
<div class="line">    <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; vtx.size(); ++i )</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a52197498d5f2961b2ced5b7cb821ec40">sKCoords</a>( vtx[ i ] );</div>
<div class="line">    std::cerr &lt;&lt; std::endl;</div>
<div class="line">  }</div>
</div><!-- fragment --><p><a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a> provides you with many methods to get faces from edges or vertices and reciprocally.</p>
<ul>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#a0d51d1937e80494125dd45dc647e8b27">DigitalSurface::outArcs</a> (Vertex): the range of outgoing arcs from the given vertex.</li>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#a79845ad7b0bd514667eda29dbebca4e0">DigitalSurface::inArcs</a> (Vertex): the range of ingoing arcs from the given vertex.</li>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#aa99a45bc9c76b892eeecd41959284d03">DigitalSurface::facesAroundVertex</a> (Vertex): the range of faces containing this vertex [v]: 0 in 2D, 4 in 3D, 12 in 4D, 2(n-1)(n-2) in nD. Since <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> 1.0, in 3D, the 4 faces may be ordered counterclockwise around the vertex (seen from the exterior), if the user specifies it.</li>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#afc9d9e25a0837f3dec6d8992f3077e0f">DigitalSurface::head</a> (Arc): the head vertex of the given arc</li>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#a44e1cffc945adcade40e962e77197a00">DigitalSurface::tail</a> (Arc): the tail vertex of the given arc</li>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#a7c257361daf33f099e5aa6e35820efb8">DigitalSurface::opposite</a> (Arc): the opposite arc of the given arc (may not exist if the arc lies on some boundary).</li>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#a2efc999809e351fac7640a348919dad4">DigitalSurface::arc</a> (Vertex,Vertex): the arc from the first vertex toward the second.</li>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#ae038d66a0b7c1b78b1e15d1031f6e575">DigitalSurface::facesAroundArc</a> (Arc): the range of faces incident to a given arc. Empty in 2D. 1 face in 3D, 2 in 4D and so one, n-2 in nD. Returned faces may be open.</li>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#aa80a240bae572ea16c5b4c982a4d9518">DigitalSurface::verticesAroundFace</a> (Face): the sequence of vertices that touches this face. The order follows the order of incident arcs.</li>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#a4fe4f14adc8b8ae2e1f2058be2f03d24">DigitalSurface::allFaces</a> (): the set of all faces of the digital surface (open and closed faces).</li>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#a33e48141c4ee02355f5b5e3e027d9c54">DigitalSurface::allClosedFaces</a> (): the set of all closed faces of the digital surface.</li>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#ac4390acf204d2e9b285933f23c4dc2b8">DigitalSurface::allOpenFaces</a> (): the set of all open faces of the digital surface.</li>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#a1cf3052df0fd42ec03b74023fdcb75cc">DigitalSurface::computeFace</a> ( <a class="el" href="structDGtal_1_1UmbrellaComputer_1_1State.html">UmbrellaComputer::State</a> ): compute the face from a given umbrella state.</li>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#af8d56d3ecef5728a2c490e70043883fe">DigitalSurface::separator</a> ( Arc ): the separator of a given arc (the n-2-cell between the two surfels forming the arc).</li>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html#a5818ec49a075b0463c257ca844bf6012">DigitalSurface::pivot</a> ( Face ): the positively oriented n-3-cell that is the pivot of the face.</li>
</ul>
<h2><a class="anchor" id="dgtal_digsurf_sec4_3"></a>
Application to export surface in OFF format</h2>
<p>In 3D, you may use faces to transform an arbitrary digital surface into a polygonal manifold (closed or open). You can for instance directly the method <a class="el" href="classDGtal_1_1DigitalSurface.html#a4a80e0e3e71a6aa9e9bcbc888ff30c11">DigitalSurface::exportSurfaceAs3DOFF</a> to do so, or look at its code to see how it works.</p>
<p>The following snippets of file <a class="el" href="volToOFF_8cpp.html">volToOFF.cpp</a> show how to extract all surfels in an image and then how to export the surface in OFF format. The output is a surface that is very much the classical <b>marching-cube</b> surface, except that vertices lies in the middle of the edge.</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a>( <span class="stringliteral">&quot;Extracting boundary by scanning the space. &quot;</span> );</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a0a02413be83a0f38f23ed5cb45c2bcc4">KSpace::SurfelSet</a> <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a9e248ca0929052a040e6dfa7018611c2">SurfelSet</a>;</div>
<div class="line">  <span class="keyword">typedef</span> SetOfSurfels&lt; KSpace, SurfelSet &gt; MySetOfSurfels;</div>
<div class="line">  <span class="keyword">typedef</span> DigitalSurface&lt; MySetOfSurfels &gt; <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a03d731f44ed1110acdbefdc2357f84cf">MyDigitalSurface</a>;</div>
<div class="line"> </div>
<div class="line">  MySetOfSurfels theSetOfSurfels( <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, surfAdj );</div>
<div class="line">  <a class="code" href="classDGtal_1_1Surfaces.html#af61619b3dbd948aea387202369bddd6f">Surfaces&lt;KSpace&gt;::sMakeBoundary</a>( theSetOfSurfels.surfelSet(),</div>
<div class="line">                                   <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, set3d,</div>
<div class="line">                                   image.domain().<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#abdaa80d0d0b08137a355602d087fee46">lowerBound</a>(),</div>
<div class="line">                                   image.domain().upperBound() );</div>
<div class="line">  <a class="code" href="classDGtal_1_1DigitalSurface.html">MyDigitalSurface</a> digSurf( theSetOfSurfels );</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;Digital surface has &quot;</span> &lt;&lt; digSurf.size() &lt;&lt; <span class="stringliteral">&quot; surfels.&quot;</span></div>
<div class="line">               &lt;&lt; std::endl;</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">endBlock</a>();</div>
</div><!-- fragment --><div class="fragment"><div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a>( <span class="stringliteral">&quot;Making OFF surface &lt;marching-cube.off&gt;. &quot;</span> );</div>
<div class="line">  ofstream out( <span class="stringliteral">&quot;marching-cube.off&quot;</span> );</div>
<div class="line">  <span class="keywordflow">if</span> ( out.good() )</div>
<div class="line">    digSurf.exportSurfaceAs3DOFF( out );</div>
<div class="line">  out.close();</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">endBlock</a>();</div>
</div><!-- fragment --> <div class="image">
<img src="digital-surface-mc-cat10.png" alt=""/>
<div class="caption">
Marching-cube surface of cat10.vol file.</div></div>
  <div class="image">
<img src="digital-surface-mc-lobster.png" alt=""/>
<div class="caption">
Marching-cube surface of lobster.vol file.</div></div>
 <h1><a class="anchor" id="dgtal_digsurf_sec5"></a>
Precomputed 3D digital surface with IndexedDigitalSurface</h1>
<p>Digital surfaces are built upon digital surface containers. Although containers may be very differnt, digital surfaces provide a uniform interface to visit them and to explore their topology. But they are merely just an interface. Hence neighbors, umbrellas, and sometimes even vertices are recomputed on-the-fly as needed.</p>
<p>In some cases, it is a better idea to compute the topology once and for all and to store it as fixed arrays. This is the purpose of class <a class="el" href="classDGtal_1_1IndexedDigitalSurface.html">IndexedDigitalSurface</a>.</p>
<dl class="section note"><dt>Note</dt><dd>For now, the class <a class="el" href="classDGtal_1_1IndexedDigitalSurface.html" title="Aim: Represents a digital surface with the topology of its dual surface. Its aim is to mimick the sta...">IndexedDigitalSurface</a> can only handle 3D digital surface containers. It is because the topology is stored in a half-edge data structure (<a class="el" href="classDGtal_1_1HalfEdgeDataStructure.html">HalfEdgeDataStructure</a>), which can only represents 2D combinatorial manifolds.</dd></dl>
<h2><a class="anchor" id="dgtal_digsurf_sec5_1"></a>
Creating an IndexedDigitalSurface</h2>
<p>Similarly to a <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>, one creates an <a class="el" href="classDGtal_1_1IndexedDigitalSurface.html" title="Aim: Represents a digital surface with the topology of its dual surface. Its aim is to mimick the sta...">IndexedDigitalSurface</a> with a model of digital surface container (<a class="el" href="structDGtal_1_1concepts_1_1CDigitalSurfaceContainer.html" title="Aim: The digital surface container concept describes a minimal set of inner types and methods so as t...">concepts::CDigitalSurfaceContainer</a>). The following snippet creates it from a <a class="el" href="classDGtal_1_1DigitalSetBoundary.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of a given...">DigitalSetBoundary</a> (the boundary of a ball of radius 3 here).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/helpers/StdDefs.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/topology/DigitalSetBoundary.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/topology/IndexedDigitalSurface.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/shapes/Shapes.h&quot;</span></div>
<div class="line">...</div>
<div class="line">using <span class="keyword">namespace </span><a class="code" href="namespaceDGtal.html">DGtal</a>;</div>
<div class="line"><span class="keyword">using namespace </span>Z3i;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> DigitalSetBoundary&lt; KSpace, DigitalSet &gt; DSContainer;</div>
<div class="line"><span class="keyword">typedef</span> IndexedDigitalSurface&lt; DSContainer &gt;     IDSurface;</div>
<div class="line"><span class="comment">// Creating the ball</span></div>
<div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> p1( -5, -5, -5 );</div>
<div class="line"><a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> p2(  5,  5,  5 );</div>
<div class="line"><a class="code" href="classDGtal_1_1KhalimskySpaceND.html">KSpace</a> <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>;</div>
<div class="line"><a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>.<a class="code" href="classDGtal_1_1KhalimskySpaceND.html#a15dcbcaae831dd1c36090e6336c177d4">init</a>( p1, p2, <span class="keyword">true</span> );</div>
<div class="line"><a class="code" href="namespaceDGtal_1_1Z3i.html#a7b7028f23aee23f64730fb2300dc1ecf">DigitalSet</a> aSet( <a class="code" href="namespaceDGtal_1_1Z3i.html#a39a69f8da09f1094df563ca067927c61">Domain</a>( p1, p2 ) );</div>
<div class="line"><a class="code" href="classDGtal_1_1Shapes.html#acde0e74411f8d24da89c93f6df58a84f">Shapes&lt;Domain&gt;::addNorm2Ball</a>( aSet, <a class="code" href="namespaceDGtal_1_1Z3i.html#a8d69892de6b10119a8070bd5d0871bf5">Point</a>( 0, 0, 0 ), 3 );</div>
<div class="line"><span class="comment">// Creating the IndexedDigitalSurface by handling it a container</span></div>
<div class="line">DSContainer dsc( <a class="code" href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a>, aSet ) );</div>
<div class="line">IDSurface   idx_dig_surf( dsc );</div>
<div class="line"><span class="comment">// The surface topology is now completely built.</span></div>
<div class="line">std::cout &lt;&lt; dsurf.nbVertices() &lt;&lt; std::endl; <span class="comment">// 174 </span></div>
<div class="line">std::cout &lt;&lt; dsurf.nbEdges()    &lt;&lt; std::endl; <span class="comment">// 348 </span></div>
<div class="line">std::cout &lt;&lt; dsurf.nbFaces()    &lt;&lt; std::endl; <span class="comment">// 176 </span></div>
<div class="line">std::cout &lt;&lt; dsurf.Euler()      &lt;&lt; std::endl; <span class="comment">//   2 </span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>We recall that, as for a <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>, an <a class="el" href="classDGtal_1_1IndexedDigitalSurface.html" title="Aim: Represents a digital surface with the topology of its dual surface. Its aim is to mimick the sta...">IndexedDigitalSurface</a> represents the topology of the dual of the cubical cell complex formed by the surfels and their incident cells. Hence vertices are surfels, edges correspond to linels (more precisely a couple of surfels sharing an edge) and faces correspond to pointels (more precisely an umbrella of surfels around this pointels). It is because the topology of the primal digital surface seen as a 2-dimensional cubical complex is not a 2-manifold in general. However, for its dual, we are able to define a 2-manifold.</dd></dl>
<h2><a class="anchor" id="dgtal_digsurf_sec5_2"></a>
Guide for using an IndexedDigitalSurface</h2>
<p>Once the indexed surface is created, you may use it as a <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>. First it is a model of graph (<a class="el" href="structDGtal_1_1concepts_1_1CUndirectedSimpleGraph.html" title="Aim: Represents the concept of local graph: each vertex has neighboring vertices, but we do not neces...">concepts::CUndirectedSimpleGraph</a>). Hence traversal operations and visitors apply. The main difference is that vertices, arcs and faces are now numbered consecutively starting from 0. Therefore you have methods to get a surfel from its vertex index, a linel from its arc index, a pointel from its face index.</p>
<ul>
<li><a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#a28d6dc6460a9394a828a6dd899018715">IndexedDigitalSurface::surfel</a> : gets the surfel associated with a given vertex index.</li>
<li><a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#ab215c7e9d040d23b9c900d1acc77fd92">IndexedDigitalSurface::linel</a> : gets the linel associated with a given arc index.</li>
<li><a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#a1beb39c1ba3070131a824fac88ffd4b4">IndexedDigitalSurface::pointel</a> : gets the pointel associated with a given face index.</li>
<li><a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#abc681a60d1b6b37d4c518e51b3a91303">IndexedDigitalSurface::surfels</a> : gets the whole mapping vertex index -&gt; surfel.</li>
<li><a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#ad38fd4ba5b92d75796569725e4b7d9ee">IndexedDigitalSurface::linels</a> : gets the whole mapping arc index -&gt; surfel.</li>
<li><a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#ae1c51a2ed7dc9d8f8b0bd6335c6f491e">IndexedDigitalSurface::pointels</a>: gets the whole mapping face index -&gt; surfel.</li>
<li><a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#a62afec51975aed8a419958baf63bf7e1">IndexedDigitalSurface::getVertex</a>: gets the vertex index of the given (oriented) surfel.</li>
<li><a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#ae69a193ace280d2976c26c9aa2fbafe5">IndexedDigitalSurface::getArc</a>: gets the arc index of the given (oriented) linel (i.e. its separator).</li>
<li><a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#afbb040584c9e78d34e974f9c1bb1882a">IndexedDigitalSurface::getFace</a>: gets a face index of the given pointel (i.e. its pivot). Note that several faces may have the same pivot (up to four).</li>
</ul>
<p>An indexed digital surface associates positions to its vertices (see <a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#a3b13f4f3589b004ad956cd0f3b0e1c80">IndexedDigitalSurface::position</a> and <a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#aef0e92ad88bab17061e25404b565df15">IndexedDigitalSurface::positions</a>).</p>
<p>Then, most the services of <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a> described in <a class="el" href="moduleDigitalSurfaces.html#dgtal_digsurf_sec4">The digital surface graph is a combinatorial manifold</a> are available in <a class="el" href="classDGtal_1_1IndexedDigitalSurface.html" title="Aim: Represents a digital surface with the topology of its dual surface. Its aim is to mimick the sta...">IndexedDigitalSurface</a>.</p>
<ul>
<li><a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#a0a62dc75ff97ef2973bb02e374f92d02">IndexedDigitalSurface::outArcs</a> (Vertex): the vector of outgoing arcs from the given vertex.</li>
<li><a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#a7d8f44fb7d7de3a1209791598084ad7a">IndexedDigitalSurface::inArcs</a> (Vertex): the vector of ingoing arcs from the given vertex.</li>
<li><a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#ac7be8eeff91ce598aa144a464ca3f2e5">IndexedDigitalSurface::facesAroundVertex</a> (Vertex): the vector of faces containing this vertex [v]: 4 faces in 3D.</li>
<li><a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#ac1fbe8cef174d045febaa170229a1648">IndexedDigitalSurface::head</a> (Arc): the head vertex of the given arc</li>
<li><a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#a3f699e2810d920d5d55f9ab6b06379a4">IndexedDigitalSurface::tail</a> (Arc): the tail vertex of the given arc</li>
<li><a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#a9dcc4db920d18f6a32ebfa12c714ee3d">IndexedDigitalSurface::opposite</a> (Arc): the opposite arc of the given arc (may not exist if the arc lies on some boundary).</li>
<li><a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#aa174c0e7251e3f5e71650bb5a0de6cca">IndexedDigitalSurface::arc</a> (Vertex,Vertex): the arc from the first vertex toward the second.</li>
<li><a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#a1446621505aa27afd388dde1441dcaae">IndexedDigitalSurface::facesAroundArc</a> (Arc): the vector of faces incident to a given arc. Only 1 face in 3D. Returned face may be open.</li>
<li><a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#af449258ba19587bd9979c383bfc73eec">IndexedDigitalSurface::verticesAroundFace</a> (Face): the sequence of vertices that touches this face. The order follows the order of incident arcs.</li>
<li><a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#ac151a6c2008c9830472ef0b4596bf59e">IndexedDigitalSurface::allFaces</a> (): the vector of all faces of the digital surface, i.e. an array containing 0, 1, 2, ..., <a class="el" href="testCubicalComplex_8cpp.html#a5c0ba477286ae5bd1ff494a61e6eae4a">nbFaces()</a>-1.</li>
</ul>
<p>The following services are also provided:</p>
<ul>
<li><a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#a903cb9d74d775339dad92b06f4ef929b">IndexedDigitalSurface::allArcs</a> (): the vector of all arcs of the digital surface, i.e. an array containing 0, 1, 2, ..., nbArcs()-1.</li>
<li><a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#a03e9e7eca96083a5a6db4b10bffae4f1">IndexedDigitalSurface::allVertices</a> (): the vector of all vertices of the digital surface, i.e. an array containing 0, 1, 2, ..., nbVertices()-1.</li>
<li><a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#ade2258961d83ea5b63af005c5acbd3e0">IndexedDigitalSurface::allBoundaryArcs</a> (): the vector of all arcs of the digital surface lying on its boundary.</li>
<li><a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#aff9219c75d9652d644d3d67551db8dbb">IndexedDigitalSurface::allBoundaryVertices</a> (): the vector of all vertices of the digital surface lying on its boundary.</li>
<li><a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#ad1fc83ea6b55afe97033199b32d225a5">IndexedDigitalSurface::next</a> (Arc): the next arc along the (only) incident face.</li>
<li><a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#adb53ffb78be41227a216709385c61aef">IndexedDigitalSurface::faceAroundArc</a> (Arc): the (only) face incident to a given arc (in 3D). Returned face may be open.</li>
<li><a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#a6478abc7798577e248f2f2fea9fd4489">IndexedDigitalSurface::isVertexBoundary</a> (Vertex): true iff it lies on the boundary.</li>
<li><a class="el" href="classDGtal_1_1IndexedDigitalSurface.html#a99d40784dea55667358c5212c39e4773">IndexedDigitalSurface::isArcBoundary</a> (Arc): true iff it lies on the boundary.</li>
</ul>
<h2><a class="anchor" id="dgtal_digsurf_sec5_3"></a>
When using an IndexedDigitalSurface instead of a DigitalSurface ?</h2>
<p>You should use an <a class="el" href="classDGtal_1_1IndexedDigitalSurface.html" title="Aim: Represents a digital surface with the topology of its dual surface. Its aim is to mimick the sta...">IndexedDigitalSurface</a> when:</p><ul>
<li>the digital surface is never modified</li>
<li>you use a lot traversal operations (like computing k-neighborhoods everywhere)</li>
<li>you use a lot surface operations (order of faces around a vertex)</li>
<li>you do not use too much the cell geometry and topology but just their combinatorial relations</li>
<li>or you need to number your cells consecutively.</li>
</ul>
<p>You should use a <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a> when</p><ul>
<li>you use a lot the geometry and topology of cells</li>
<li>the digital surface is sometimes modified (then use light containers)</li>
<li>you just iterate over surfels and perform few neighborhood operations.</li>
</ul>
<p>Examples <a class="el" href="area-estimation-with-digital-surface_8cpp.html">area-estimation-with-digital-surface.cpp</a> and <a class="el" href="area-estimation-with-indexed-digital-surface_8cpp.html">area-estimation-with-indexed-digital-surface.cpp</a> illustrate the similarities of classes <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a> and <a class="el" href="classDGtal_1_1IndexedDigitalSurface.html" title="Aim: Represents a digital surface with the topology of its dual surface. Its aim is to mimick the sta...">IndexedDigitalSurface</a> as well as their slight differences. They show how to estimate the area of a digital sphere. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="aclassDGtal_1_1Trace_html_afa3a2874289734884107b1ce68ccb93d"><div class="ttname"><a href="classDGtal_1_1Trace.html#afa3a2874289734884107b1ce68ccb93d">DGtal::Trace::endBlock</a></div><div class="ttdeci">double endBlock()</div></div>
<div class="ttc" id="aclassDGtal_1_1DigitalSurface_html_a7bbab2b7e1bedf06738f5151d1157b37"><div class="ttname"><a href="classDGtal_1_1DigitalSurface.html#a7bbab2b7e1bedf06738f5151d1157b37">DGtal::DigitalSurface::VertexRange</a></div><div class="ttdeci">std::vector&lt; Vertex &gt; VertexRange</div><div class="ttdoc">The range of vertices is defined as a vector.</div><div class="ttdef"><b>Definition:</b> <a href="DigitalSurface_8h_source.html#l00305">DigitalSurface.h:305</a></div></div>
<div class="ttc" id="aclassDGtal_1_1KhalimskySpaceND_html_a0a02413be83a0f38f23ed5cb45c2bcc4"><div class="ttname"><a href="classDGtal_1_1KhalimskySpaceND.html#a0a02413be83a0f38f23ed5cb45c2bcc4">DGtal::KhalimskySpaceND::SurfelSet</a></div><div class="ttdeci">std::set&lt; SCell &gt; SurfelSet</div><div class="ttdoc">Preferred type for defining a set of surfels (always signed cells).</div><div class="ttdef"><b>Definition:</b> <a href="KhalimskySpaceND_8h_source.html#l00450">KhalimskySpaceND.h:450</a></div></div>
<div class="ttc" id="aclassDGtal_1_1DigitalSurface_html"><div class="ttname"><a href="classDGtal_1_1DigitalSurface.html">DGtal::DigitalSurface</a></div><div class="ttdoc">Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...</div><div class="ttdef"><b>Definition:</b> <a href="DigitalSurface_8h_source.html#l00139">DigitalSurface.h:140</a></div></div>
<div class="ttc" id="aclassDGtal_1_1KhalimskySpaceND_html_a15dcbcaae831dd1c36090e6336c177d4"><div class="ttname"><a href="classDGtal_1_1KhalimskySpaceND.html#a15dcbcaae831dd1c36090e6336c177d4">DGtal::KhalimskySpaceND::init</a></div><div class="ttdeci">bool init(const Point &amp;lower, const Point &amp;upper, bool isClosed)</div><div class="ttdoc">Specifies the upper and lower bounds for the maximal cells in this space.</div></div>
<div class="ttc" id="anamespaceDGtal_html_a8fc7012708b0416880a5c8b12dfdf9dd"><div class="ttname"><a href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">DGtal::trace</a></div><div class="ttdeci">Trace trace</div><div class="ttdef"><b>Definition:</b> <a href="Common_8h_source.html#l00150">Common.h:150</a></div></div>
<div class="ttc" id="aclassDGtal_1_1DigitalSetBoundary_html"><div class="ttname"><a href="classDGtal_1_1DigitalSetBoundary.html">DGtal::DigitalSetBoundary</a></div><div class="ttdoc">Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of a given...</div><div class="ttdef"><b>Definition:</b> <a href="DigitalSetBoundary_8h_source.html#l00069">DigitalSetBoundary.h:70</a></div></div>
<div class="ttc" id="atestCubicalComplex_8cpp_html_a2b87ed989d2519d025bd5d4fbcbac062"><div class="ttname"><a href="testCubicalComplex_8cpp.html#a2b87ed989d2519d025bd5d4fbcbac062">K</a></div><div class="ttdeci">KSpace K</div><div class="ttdef"><b>Definition:</b> <a href="testCubicalComplex_8cpp_source.html#l00062">testCubicalComplex.cpp:62</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1Z3i_html_a8d69892de6b10119a8070bd5d0871bf5"><div class="ttname"><a href="namespaceDGtal_1_1Z3i.html#a8d69892de6b10119a8070bd5d0871bf5">DGtal::Z3i::Point</a></div><div class="ttdeci">Space::Point Point</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00168">StdDefs.h:168</a></div></div>
<div class="ttc" id="aclassDGtal_1_1Trace_html_a352b7160bf722e2f0bcbee5d0bad6ef3"><div class="ttname"><a href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">DGtal::Trace::beginBlock</a></div><div class="ttdeci">void beginBlock(const std::string &amp;keyword=&quot;&quot;)</div></div>
<div class="ttc" id="aclassDGtal_1_1KhalimskySpaceND_html_abdaa80d0d0b08137a355602d087fee46"><div class="ttname"><a href="classDGtal_1_1KhalimskySpaceND.html#abdaa80d0d0b08137a355602d087fee46">DGtal::KhalimskySpaceND::lowerBound</a></div><div class="ttdeci">const Point &amp; lowerBound() const</div><div class="ttdoc">Return the lower bound for digital points in this space.</div></div>
<div class="ttc" id="aclassDGtal_1_1Color_html_ac26d8585885e7a354893b7e93c6a9dda"><div class="ttname"><a href="classDGtal_1_1Color.html#ac26d8585885e7a354893b7e93c6a9dda">DGtal::Color::Black</a></div><div class="ttdeci">static const Color Black</div><div class="ttdef"><b>Definition:</b> <a href="Color_8h_source.html#l00397">Color.h:397</a></div></div>
<div class="ttc" id="aclassDGtal_1_1KhalimskySpaceND_html_a7d5231f241513f15be0a1ee092db2590"><div class="ttname"><a href="classDGtal_1_1KhalimskySpaceND.html#a7d5231f241513f15be0a1ee092db2590">DGtal::KhalimskySpaceND::sSpel</a></div><div class="ttdeci">SCell sSpel(Point p, Sign sign=POS) const</div><div class="ttdoc">From the digital coordinates of a point in Zn, builds the corresponding spel (cell of maximal dimensi...</div></div>
<div class="ttc" id="astructDGtal_1_1SignedKhalimskyCell_html"><div class="ttname"><a href="structDGtal_1_1SignedKhalimskyCell.html">DGtal::SignedKhalimskyCell</a></div><div class="ttdoc">Represents a signed cell in a cellular grid space by its Khalimsky coordinates and a boolean value.</div><div class="ttdef"><b>Definition:</b> <a href="KhalimskySpaceND_8h_source.html#l00208">KhalimskySpaceND.h:209</a></div></div>
<div class="ttc" id="aclassDGtal_1_1DigitalSurface_html_aca5daf921da1f67b921cfc109f2dbb20"><div class="ttname"><a href="classDGtal_1_1DigitalSurface.html#aca5daf921da1f67b921cfc109f2dbb20">DGtal::DigitalSurface::FaceSet</a></div><div class="ttdeci">std::set&lt; Face &gt; FaceSet</div><div class="ttdoc">The set of faces is defined as set.</div><div class="ttdef"><b>Definition:</b> <a href="DigitalSurface_8h_source.html#l00307">DigitalSurface.h:307</a></div></div>
<div class="ttc" id="atestHalfEdgeDataStructure_8cpp_html_a1aba5499fd29449181365ce424303a10"><div class="ttname"><a href="testHalfEdgeDataStructure_8cpp.html#a1aba5499fd29449181365ce424303a10">Size</a></div><div class="ttdeci">HalfEdgeDataStructure::Size Size</div><div class="ttdef"><b>Definition:</b> <a href="testHalfEdgeDataStructure_8cpp_source.html#l00050">testHalfEdgeDataStructure.cpp:50</a></div></div>
<div class="ttc" id="aclassDGtal_1_1KhalimskySpaceND_html_ae6cf442a7d0a46d254f9fbdd7237ab11"><div class="ttname"><a href="classDGtal_1_1KhalimskySpaceND.html#ae6cf442a7d0a46d254f9fbdd7237ab11">DGtal::KhalimskySpaceND::SCellSet</a></div><div class="ttdeci">std::set&lt; SCell &gt; SCellSet</div><div class="ttdoc">Preferred type for defining a set of SCell(s).</div><div class="ttdef"><b>Definition:</b> <a href="KhalimskySpaceND_8h_source.html#l00447">KhalimskySpaceND.h:447</a></div></div>
<div class="ttc" id="aclassDGtal_1_1Color_html_ab7b17778033da4f2ce2825d385e53d90"><div class="ttname"><a href="classDGtal_1_1Color.html#ab7b17778033da4f2ce2825d385e53d90">DGtal::Color::White</a></div><div class="ttdeci">static const Color White</div><div class="ttdef"><b>Definition:</b> <a href="Color_8h_source.html#l00399">Color.h:399</a></div></div>
<div class="ttc" id="aclassDGtal_1_1Surfaces_html_a274dbb659f269382154035ae61d7e7b3"><div class="ttname"><a href="classDGtal_1_1Surfaces.html#a274dbb659f269382154035ae61d7e7b3">DGtal::Surfaces::trackBoundary</a></div><div class="ttdeci">static void trackBoundary(SCellSet &amp;surface, const KSpace &amp;K, const SurfelAdjacency&lt; KSpace::dimension &gt; &amp;surfel_adj, const PointPredicate &amp;pp, const SCell &amp;start_surfel)</div></div>
<div class="ttc" id="aclassDGtal_1_1Trace_html_ad054990834d2763627166540087a2980"><div class="ttname"><a href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">DGtal::Trace::info</a></div><div class="ttdeci">std::ostream &amp; info()</div></div>
<div class="ttc" id="aclassDGtal_1_1Surfaces_html_af61619b3dbd948aea387202369bddd6f"><div class="ttname"><a href="classDGtal_1_1Surfaces.html#af61619b3dbd948aea387202369bddd6f">DGtal::Surfaces::sMakeBoundary</a></div><div class="ttdeci">static void sMakeBoundary(SCellSet &amp;aBoundary, const KSpace &amp;aKSpace, const PointPredicate &amp;pp, const Point &amp;aLowerBound, const Point &amp;aUpperBound)</div></div>
<div class="ttc" id="aclassDGtal_1_1Color_html_aa5e8679bd0da49f95d13cd95a17b619b"><div class="ttname"><a href="classDGtal_1_1Color.html#aa5e8679bd0da49f95d13cd95a17b619b">DGtal::Color::Red</a></div><div class="ttdeci">static const Color Red</div><div class="ttdef"><b>Definition:</b> <a href="Color_8h_source.html#l00400">Color.h:400</a></div></div>
<div class="ttc" id="aclassDGtal_1_1KhalimskySpaceND_html_aaa60ad137a7aa68627cd86b0d76c3693"><div class="ttname"><a href="classDGtal_1_1KhalimskySpaceND.html#aaa60ad137a7aa68627cd86b0d76c3693">DGtal::KhalimskySpaceND::sDirectIncident</a></div><div class="ttdeci">SCell sDirectIncident(const SCell &amp;p, Dimension k) const</div><div class="ttdoc">Return the direct incident cell of [p] along [k] (the incident cell along [k])</div></div>
<div class="ttc" id="aclassDGtal_1_1Surfaces_html_a48e3a0e7c4728f6a6f23ec6f468a41b8"><div class="ttname"><a href="classDGtal_1_1Surfaces.html#a48e3a0e7c4728f6a6f23ec6f468a41b8">DGtal::Surfaces::findABel</a></div><div class="ttdeci">static SCell findABel(const KSpace &amp;K, const PointPredicate &amp;pp, unsigned int nbtries=1000)</div></div>
<div class="ttc" id="anamespaceDGtal_html"><div class="ttname"><a href="namespaceDGtal.html">DGtal</a></div><div class="ttdoc">DGtal is the top-level namespace which contains all DGtal functions and types.</div><div class="ttdef"><b>Definition:</b> <a href="ClosedIntegerHalfPlane_8h_source.html#l00048">ClosedIntegerHalfPlane.h:49</a></div></div>
<div class="ttc" id="aclassDGtal_1_1KhalimskySpaceND_html_a52197498d5f2961b2ced5b7cb821ec40"><div class="ttname"><a href="classDGtal_1_1KhalimskySpaceND.html#a52197498d5f2961b2ced5b7cb821ec40">DGtal::KhalimskySpaceND::sKCoords</a></div><div class="ttdeci">const Point &amp; sKCoords(const SCell &amp;c) const</div><div class="ttdoc">Return its Khalimsky coordinates.</div></div>
<div class="ttc" id="anamespaceDGtal_1_1Z3i_html_a39a69f8da09f1094df563ca067927c61"><div class="ttname"><a href="namespaceDGtal_1_1Z3i.html#a39a69f8da09f1094df563ca067927c61">DGtal::Z3i::Domain</a></div><div class="ttdeci">HyperRectDomain&lt; Space &gt; Domain</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00172">StdDefs.h:172</a></div></div>
<div class="ttc" id="agreedy-plane-segmentation-ex2_8cpp_html_ac9ee7087e3a195e77c3d27a1b002d6d6"><div class="ttname"><a href="greedy-plane-segmentation-ex2_8cpp.html#ac9ee7087e3a195e77c3d27a1b002d6d6">MyDigitalSurfaceContainer</a></div><div class="ttdeci">DigitalSetBoundary&lt; KSpace, DigitalSet &gt; MyDigitalSurfaceContainer</div><div class="ttdef"><b>Definition:</b> <a href="greedy-plane-segmentation-ex2_8cpp_source.html#l00091">greedy-plane-segmentation-ex2.cpp:91</a></div></div>
<div class="ttc" id="aclassDGtal_1_1KhalimskySpaceND_html_a30ed0a752d1e58dfd12f4f905dba38aa"><div class="ttname"><a href="classDGtal_1_1KhalimskySpaceND.html#a30ed0a752d1e58dfd12f4f905dba38aa">DGtal::KhalimskySpaceND::POS</a></div><div class="ttdeci">static constexpr const Sign POS</div><div class="ttdef"><b>Definition:</b> <a href="KhalimskySpaceND_8h_source.html#l00432">KhalimskySpaceND.h:432</a></div></div>
<div class="ttc" id="aclassDGtal_1_1KhalimskySpaceND_html_adcda490970c3962a731a5ad604ef5ce6"><div class="ttname"><a href="classDGtal_1_1KhalimskySpaceND.html#adcda490970c3962a731a5ad604ef5ce6">DGtal::KhalimskySpaceND::sIncident</a></div><div class="ttdeci">SCell sIncident(const SCell &amp;c, Dimension k, bool up) const</div><div class="ttdoc">Return the forward or backward signed cell incident to [c] along axis [k], depending on [up].</div></div>
<div class="ttc" id="aclassDGtal_1_1KhalimskySpaceND_html_a22d8a0b3bf9ab0c07596ff57af908f92"><div class="ttname"><a href="classDGtal_1_1KhalimskySpaceND.html#a22d8a0b3bf9ab0c07596ff57af908f92">DGtal::KhalimskySpaceND::unsigns</a></div><div class="ttdeci">Cell unsigns(const SCell &amp;p) const</div><div class="ttdoc">Creates an unsigned cell from a signed one.</div></div>
<div class="ttc" id="aclassDGtal_1_1Shapes_html_acde0e74411f8d24da89c93f6df58a84f"><div class="ttname"><a href="classDGtal_1_1Shapes.html#acde0e74411f8d24da89c93f6df58a84f">DGtal::Shapes::addNorm2Ball</a></div><div class="ttdeci">static void addNorm2Ball(TDigitalSet &amp;aSet, const Point &amp;aCenter, UnsignedInteger aRadius)</div></div>
<div class="ttc" id="atestClone2_8cpp_html_a15e9592ccc512dc691b46185e6814758"><div class="ttname"><a href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a></div><div class="ttdeci">MyPointD Point</div><div class="ttdef"><b>Definition:</b> <a href="testClone2_8cpp_source.html#l00383">testClone2.cpp:383</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1Z3i_html_a7b7028f23aee23f64730fb2300dc1ecf"><div class="ttname"><a href="namespaceDGtal_1_1Z3i.html#a7b7028f23aee23f64730fb2300dc1ecf">DGtal::Z3i::DigitalSet</a></div><div class="ttdeci">DigitalSetSelector&lt; Domain, BIG_DS+HIGH_BEL_DS &gt;::Type DigitalSet</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00173">StdDefs.h:173</a></div></div>
<div class="ttc" id="agreedy-plane-segmentation-ex2_8cpp_html_a03d731f44ed1110acdbefdc2357f84cf"><div class="ttname"><a href="greedy-plane-segmentation-ex2_8cpp.html#a03d731f44ed1110acdbefdc2357f84cf">MyDigitalSurface</a></div><div class="ttdeci">DigitalSurface&lt; MyDigitalSurfaceContainer &gt; MyDigitalSurface</div><div class="ttdef"><b>Definition:</b> <a href="greedy-plane-segmentation-ex2_8cpp_source.html#l00092">greedy-plane-segmentation-ex2.cpp:92</a></div></div>
<div class="ttc" id="agreedy-plane-segmentation-ex2_8cpp_html_a9e248ca0929052a040e6dfa7018611c2"><div class="ttname"><a href="greedy-plane-segmentation-ex2_8cpp.html#a9e248ca0929052a040e6dfa7018611c2">SurfelSet</a></div><div class="ttdeci">MyDigitalSurface::SurfelSet SurfelSet</div><div class="ttdef"><b>Definition:</b> <a href="greedy-plane-segmentation-ex2_8cpp_source.html#l00095">greedy-plane-segmentation-ex2.cpp:95</a></div></div>
<div class="ttc" id="aclassDGtal_1_1KhalimskySpaceND_html"><div class="ttname"><a href="classDGtal_1_1KhalimskySpaceND.html">DGtal::KhalimskySpaceND</a></div><div class="ttdoc">Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex,...</div><div class="ttdef"><b>Definition:</b> <a href="KhalimskySpaceND_8h_source.html#l00392">KhalimskySpaceND.h:394</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 6 2020 14:17:10 for DGtal by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
