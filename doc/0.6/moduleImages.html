<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>DGtal: Images</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">0.6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Images </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#dgtalImagesAbstract">Overview</a></li>
<li class="level1"><a href="#dgtalImagesDetails">Let us go into details</a><ul><li class="level2"><a href="#dgtalImagesConcepts">Concepts</a></li>
<li class="level2"><a href="#dgtalImagesMainMethods">Main methods</a></li>
<li class="level2"><a href="#dgtalImagesRanges">Ranges of values</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtalImagesModels">Main models</a><ul><li class="level2"><a href="#dgtalImagesModelsVector">ImageContainerBySTLVector</a></li>
<li class="level2"><a href="#dgtalImagesModelsMap">ImageContainerBySTLMap</a></li>
<li class="level2"><a href="#dgtalImagesModelsHashTree">ImageContainerByHashTree</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtalImagesAdapters">Image Adapter classes</a><ul><li class="level2"><a href="#constimage">ConstImageAdapter</a></li>
<li class="level2"><a href="#imageadat">ImageAdapter</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtalImagesFunctions">Useful classes and functions</a></li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Authors</dt><dd>Tristan Roussillon, David Coeurjolly, Martial Tola </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2012/12/05</dd></dl>
<h1><a class="anchor" id="dgtalImagesAbstract"></a>
Overview</h1>
<p>The concept of <em>point</em> functor describe a mapping between the points of a digital space and a set of values. The only method of a point functor is the <code>operator()</code>, which must take a point as input parameter and must return a value.</p>
<p>The concept of <em>constant</em> image is a point functor bounded by a domain. It is thus a refinement of the concept of point functor, describing a mapping between points and values, but having in addition a domain, returned by the <code>domain</code> method, and a range of values (for each point of the domain), returned by the <code>constRange</code> method.</p>
<p>The concept of <em>image</em>, which is a refinement of the concept of constant image, provides extra services to update values. Any model of image must have a method <code>setValue</code> taking a point and a value as input parameters and updating the value associated with the given point with the given value. In addition, they must have a range, returned by the <code>range</code> method, providing output iterators.</p>
<p>Different models of images are available: <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>, <a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a>, and &mdash; coming soon &mdash; <a class="el" href="classDGtal_1_1experimental_1_1ImageContainerByHashTree.html" title="Model of CImageContainer implementing the association key&lt;-&gt;Value using a hash tree. This class provides a built-in iterator.">experimental::ImageContainerByHashTree</a>, <a class="el" href="classDGtal_1_1experimental_1_1ImageContainerByITKImage.html" title="Aim: implements a model of CImageContainer using a ITK Image.">experimental::ImageContainerByITKImage</a>, a wrapper for ITK images.</p>
<h1><a class="anchor" id="dgtalImagesDetails"></a>
Let us go into details</h1>
<p>In this section, the concepts and the main services to read and write values in images are detailed.</p>
<h2><a class="anchor" id="dgtalImagesConcepts"></a>
Concepts</h2>
<p>Any model of the concept <a class="el" href="structDGtal_1_1CPointFunctor.html" title="Aim: Defines a functor on points.">CPointFunctor</a> must have two nested types:</p>
<ul>
<li>Point, which specifies the type for a point.</li>
<li>Value, which specifies the type for a value.</li>
</ul>
<p>Moreover, it must have the following method:</p>
<ul>
<li><code>operator()</code>, which takes a point as input parameter and returns a value, like a function.</li>
</ul>
<p>The concept <a class="el" href="structDGtal_1_1CConstImage.html" title="Aim: Defines the concept describing a read-only image, which is a refinement of CPointFunctor.">CConstImage</a> is a refinement of <a class="el" href="structDGtal_1_1CPointFunctor.html" title="Aim: Defines a functor on points.">CPointFunctor</a>. Its models must have two extra nested types:</p>
<ul>
<li>Domain, a model of <a class="el" href="structDGtal_1_1CDomain.html" title="Aim: This concept represents a digital domain, i.e. a non mutable subset of points of the given digit...">CDomain</a></li>
<li>ConstRange, a model of CConstBidirectionnalRangeFromPoint</li>
</ul>
<p>Obviously, there are two methods that return instances of these two types:</p>
<ul>
<li><code>domain</code>, which returns a constant reference on the image domain</li>
<li><code>constRange</code>, which returns a range providing constant bidirectional iterators on the image values (associated to each point of the image domain)</li>
</ul>
<p>You can see <a class="el" href="moduleSpacePointVectorDomain.html">Digital Spaces, Points, Vectors and Domains</a> for more details about spaces and domains and <a class="el" href="moduleImages.html#dgtalImagesRanges">Ranges of values</a> for more details about ranges in images.</p>
<p>The concept <a class="el" href="structDGtal_1_1CImage.html" title="Aim: Defines the concept describing a read/write image, having an output iterator.">CImage</a> is refinement of <a class="el" href="structDGtal_1_1CConstImage.html" title="Aim: Defines the concept describing a read-only image, which is a refinement of CPointFunctor.">CConstImage</a>. Images, instead of constant ones, provide services to update values. The main way of assigning values to points is the following method:</p>
<ul>
<li><code>setValue</code>, which updates a given value at a given point.</li>
</ul>
<p>Moreover, in addition to the ConstRange, images must have the following inner type:</p>
<ul>
<li>Range, a model of <a class="el" href="structDGtal_1_1CConstBidirectionalRangeFromPoint.html" title="Aim: refined concept of const bidirectional range with a begin() method from a point.">CConstBidirectionalRangeFromPoint</a>, like ConstRange, and a model of <a class="el" href="structDGtal_1_1CBidirectionalOutputRangeFromPoint.html" title="Aim: refined concept of single pass range with an routputIterator() method from a point...">CBidirectionalOutputRangeFromPoint</a>, which must provide output iterators for incrementally updating a (sub)range of values.</li>
</ul>
<p>Obviously, you can get an instance of this type using the following method:</p>
<ul>
<li><code>range</code>, which returns a range providing both constant bidirectional iterators and output iterators.</li>
</ul>
<p>Lastly, note that the Value type in the (constant) images is expected to be at least a model of <a class="el" href="structDGtal_1_1CLabel.html" title="Aim: Define the concept of DGtal labels. Models of CLabel can be default-constructible, assignable and equality comparable.">CLabel</a>, ie. to be default-constructible, assignable and equality comparable.</p>
<dl class="section note"><dt>Note</dt><dd>In the snippets of the following subsections, the type of image used is <code><a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a></code> and its instances are <code>image</code>, <code>image1</code>, <code>image2</code>.</dd></dl>
<h2><a class="anchor" id="dgtalImagesMainMethods"></a>
Main methods</h2>
<p>All models of images have a domain returned by the method <code>domain</code>. This domain is the set of points for which the image is defined and has values. Since a domain is a range, you can straightforwardly use it in order to iterate over the points of an image.</p>
<p>iterate over the points <a class="el" href="classDGtal_1_1Image.html#ace481f886b37a80824817b5f1494df58">Image::Domain</a> d = image.domain(); for (Image::Domain::ConstIterator it = d.begin(), itEnd = d.end(); it != itEnd; ++it) {}</p>
<p>Models of images have also two main methods in order to read or write values at a given point:</p>
<ul>
<li><code>operator()</code> to get the value associated to a given point</li>
<li><code>setValue</code> to assign a value to a given point.</li>
</ul>
<p>process the values <a class="el" href="classDGtal_1_1Image.html#ace481f886b37a80824817b5f1494df58">Image::Domain</a> d = image.domain(); for (Image::Domain::ConstIterator it = d.begin(), itEnd = d.end(); it != itEnd; ++it) { <a class="el" href="classDGtal_1_1Image.html#ad56b43a36c897e64398934c8f7a3b01c">Image::Value</a> v = image( *it ); v += 5; //adding 5 to all values image.setValue( v ); }</p>
<p>Note that this method of iterating over the values of an image is not always the fastest and that is why we also provide ranges.</p>
<h2><a class="anchor" id="dgtalImagesRanges"></a>
Ranges of values</h2>
<p>Constant images provide a constant range of values returned by the <code>constRange</code> method. As every model of <a class="el" href="structDGtal_1_1CConstBidirectionalRange.html" title="Aim: Defines the concept describing a bidirectional const range.">CConstBidirectionalRange</a>, it provides <code>begin</code>, <code>end</code>, <code>rbegin</code> and <code>rend</code> methods returning constant iterators to iterate over the values in the forward or backward direction.</p>
<p>iterate over the values <a class="el" href="classDGtal_1_1Image.html#a0f2c0b68fdedee9231353fc0900e94b6">Image::ConstRange</a> r = image.constRange(); for (<a class="el" href="classDGtal_1_1SimpleRandomAccessConstRangeFromPoint.html#a8795e5e07c00b939bb6ace6589b73713">Image::ConstRange::ConstIterator</a> it = r.begin(), itEnd = r.end(); it != itEnd; ++it) {}</p>
<p>However, this range is also a model of <a class="el" href="structDGtal_1_1CConstBidirectionalRangeFromPoint.html" title="Aim: refined concept of const bidirectional range with a begin() method from a point.">CConstBidirectionalRangeFromPoint</a>, which is a refinement of <a class="el" href="structDGtal_1_1CConstBidirectionalRange.html" title="Aim: Defines the concept describing a bidirectional const range.">CConstBidirectionalRange</a>. That is why it also has overloaded versions of the <code>begin</code> and <code>rbegin</code> methods taking a point as input argument. This provides a way of iterating on sub-ranges defined from points.</p>
<p>iterator on the origin (0, ... , 0) <a class="el" href="classDGtal_1_1SimpleRandomAccessConstRangeFromPoint.html#a8795e5e07c00b939bb6ace6589b73713">Image::ConstRange::ConstIterator</a> it = r.begin( Image::Point::diagonal(0) )</p>
<p>Note that if the point does not belong to the domain, the returned iterators (resp. reverse iterators) must be equal to the <code>end</code> (resp. <code>rend</code>) methods. </p>
<pre class="fragment">ASSERT( image.constRange().begin( image.domain().end() ) == image.constRange().end() )
</pre><p>Images provide in addition to a constant range, a richer range returned by the <code>range</code> method. This range is not only a model of <a class="el" href="structDGtal_1_1CBidirectionalRangeFromPoint.html" title="Aim: refined concept of single pass range with a begin() method from a point.">CBidirectionalRangeFromPoint</a>, but also a model of <a class="el" href="structDGtal_1_1CBidirectionalOutputRangeFromPoint.html" title="Aim: refined concept of single pass range with an routputIterator() method from a point...">CBidirectionalOutputRangeFromPoint</a>. That is why, it must have two methods: <code>outputIterator</code> and <code>routputIterator</code> returning output iterators. Moreover, it must have overloaded versions of these methods taking a point as input argument. Thus, these output iterators are useful in order to incrementaly fill (a part of) an image. For instance, you can fill an image from the values of another one (assumed to have the same domain) as follows: </p>
<pre class="fragment">Image::Range r1 = image1.range(); 
Image::ConstRange r2 = image2.constRange(); 
std::copy( r2.begin(), r2.end(), r1.outputIterator() ); 
</pre><h1><a class="anchor" id="dgtalImagesModels"></a>
Main models</h1>
<p>Different models of images are available: <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>, <a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a>, and &mdash; coming soon &mdash; <a class="el" href="classDGtal_1_1experimental_1_1ImageContainerByHashTree.html" title="Model of CImageContainer implementing the association key&lt;-&gt;Value using a hash tree. This class provides a built-in iterator.">experimental::ImageContainerByHashTree</a>, <a class="el" href="classDGtal_1_1experimental_1_1ImageContainerByITKImage.html" title="Aim: implements a model of CImageContainer using a ITK Image.">experimental::ImageContainerByITKImage</a>, a wrapper for ITK images.</p>
<h2><a class="anchor" id="dgtalImagesModelsVector"></a>
ImageContainerBySTLVector</h2>
<p><a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a> is a model of <a class="el" href="structDGtal_1_1CImage.html" title="Aim: Defines the concept describing a read/write image, having an output iterator.">CImage</a> that inherits the STL vector class. The hyper-rectangular domain, which the only model of domain accepted, is linearized so that each point is mapped, from its coordinates, into an index and each index is mapped into a unique value, as in any one-dimensional array.</p>
<p>Let \( n \) be the domain size (the number of points). At construction all the needed space is allocated and filled with a default value (0) in \( O(n) \) space and time. After that, you can access to the value associated to any point at any time. Each access for reading (<code>operator()</code>) or writing ('setValue`) values is in \( O(1) \).</p>
<p>The (constant) range of this class only used the built-in iterators of the underlying STL vector. It is therefore a fast way of iterating over the values of the image.</p>
<h2><a class="anchor" id="dgtalImagesModelsMap"></a>
ImageContainerBySTLMap</h2>
<p><a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a> is a model of <a class="el" href="structDGtal_1_1CImage.html" title="Aim: Defines the concept describing a read/write image, having an output iterator.">CImage</a> that inherits the STL map class. The domain can be any set of points. Values are stored and associated to points in pairs point-value. The set of points stored in this way may be any domain subset. A default value (user-defined) is automatically associated to each point of the domain that does not belong the subset for which values are known. Once constructed (in \( O(1) \)), the image is valid and every point of the image domain has a value, which can be read and overwritten.</p>
<p>The pairs point-value are stored in a red-black tree, where the points are used as keys, so that each access for reading (<code>operator()</code>) or writing (<code>setValue</code>) values is in \( O(log m) \), where \( m \) is the cardinal of the subset for which values are known (less or equal to the domain size \( n \)).</p>
<p>The (constant) range of this class adapts the domain iterators in order to deal with values instead of points. The <code>operator*</code> of the iterators provided by the range calls the <code>operator()</code> and use the <code>setValue</code> method of the class.</p>
<h2><a class="anchor" id="dgtalImagesModelsHashTree"></a>
ImageContainerByHashTree</h2>
<p><a class="el" href="classDGtal_1_1experimental_1_1ImageContainerByHashTree.html" title="Model of CImageContainer implementing the association key&lt;-&gt;Value using a hash tree. This class provides a built-in iterator.">experimental::ImageContainerByHashTree</a> is an experimental image container implementing a pointerless nD-tree structure. In dimension 2 and 3, this structure is similar to quadtree and octree repsectively in which hierarchical links between a node and its children is given by prefix of a binary representation of the node coordinates using <a class="el" href="classDGtal_1_1Morton.html" title="Aim: Implements the binary Morton code construction in nD.">Morton</a> keys. Finally, data values are stored in the structure in a hash table whose hash function is a suffix on the <a class="el" href="classDGtal_1_1Morton.html" title="Aim: Implements the binary Morton code construction in nD.">Morton</a> key code.</p>
<p>Such container is well adapted for high resolution sparse images.</p>
<p>For more details, please refer to<a class="el" href="citelist.html#CITEREF_Lewiner2009a">[15]</a></p>
<h1><a class="anchor" id="dgtalImagesAdapters"></a>
Image Adapter classes</h1>
<p><a class="el" href="classDGtal_1_1ImageAdapter.html" title="Aim: implements an image adapter with a given domain (i.e. a subdomain) and 3 functors : g for domain...">ImageAdapter</a>, <a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a> are perfect swiss-nifes to transform and adapt images (change their domain definition, change their value types, ...). These classses are parametrized by several types and functor in order to adapt the behavior of image getters/setters (<em>operator()</em> and <em>setValue</em> methods). These adapted behaviors are computed on-the-fly when calling these methods.</p>
<p><a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a> requires several types and functors to create a "read-only" adapted image (operator(), constRange(), ...)</p>
<p><a class="el" href="classDGtal_1_1ImageAdapter.html" title="Aim: implements an image adapter with a given domain (i.e. a subdomain) and 3 functors : g for domain...">ImageAdapter</a> requires a supplementary functor and allows write access to the image (<em>setValue</em> methods, range(), ... )</p>
<dl class="section note"><dt>Note</dt><dd>Functors used to convert domains or values may be complex. Keep in mind that each time operator() or setValue() methods are called, such functors are evaluated (with potential side-effects depending on the functors).</dd></dl>
<h2><a class="anchor" id="constimage"></a>
ConstImageAdapter</h2>
<p><a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a> is a small class that adapts any (constant or not) image into a constant one, which provides a virtual view (so read-only) of the true values contained in the adapted image. The class is parametrized by several template arguments: <em>TImageContainer:</em> the type of image to adapt. <em>TNewDomain:</em> the type of the new domain. <em>TFunctorD:</em> type of functor used to convert image domain points to new domain points <em>TNewValue:</em> type of the new image value type. <em>TFucntorV:</em> functor to convert values.</p>
<p>The values associated to access the point values are adapted with a functor <em>g</em> and a functor <em>f</em> given at construction so that operator() calls <em>f</em>(img(g(aPoint))), instead of calling directly img.operator() of the underlying image <em>img</em>.</p>
<p>Functor g (and/or functor f) can be a default functor, i.e. a simple functor that just returns its argument.</p>
<p>In order to illustrate the next <a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a> usage samples, we are going a) to use these includes:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/io/colormaps/HueShadeColorMap.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/io/colormaps/GrayscaleColorMap.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/images/ImageContainerBySTLVector.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/images/ConstImageAdapter.h&quot;</span></div>
</div><!-- fragment --><p> b) then define these types and variables:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> HueShadeColorMap&lt;unsigned char&gt; HueShade;     <span class="comment">// a simple HueShadeColorMap varying on &#39;unsigned char&#39; values</span></div>
<div class="line">  <span class="keyword">typedef</span> HueShadeColorMap&lt;double&gt; HueShadeDouble;      <span class="comment">// a simple HueShadeColorMap varying on &#39;double&#39; values</span></div>
<div class="line">  <span class="keyword">typedef</span> GrayscaleColorMap&lt;unsigned char&gt; Gray;        <span class="comment">// a simple GrayscaleColorMap varying on &#39;unsigned char&#39; values</span></div>
<div class="line">  </div>
<div class="line">  DefaultFunctor df;                                    <span class="comment">// a simple functor that just returns its argument</span></div>
</div><!-- fragment --><p> c) then define a simple 16x16 (1,1) to (16,16) image (of 'unsigned char' type):</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> ImageContainerBySTLVector&lt;Domain, unsigned char&gt; Image;</div>
<div class="line">  <a class="code" href="namespaceDGtal_1_1Z2i.html#aca523bebdae58eb19385aaefffff8bc5">Domain</a> domain(Point(1,1), Point(16,16));</div>
<div class="line">  Image image(domain);</div>
</div><!-- fragment --><p> filled with 0 to 255 values like that:</p>
<div class="fragment"><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> i = 0;</div>
<div class="line">  <span class="keywordflow">for</span> (<a class="code" href="classDGtal_1_1ImageContainerBySTLVector.html#a7cd7b0da52697b0d0f1f5f65781d8a52">Image::Iterator</a> it = image.begin(); it != image.end(); ++it)</div>
<div class="line">      *it = i++;</div>
</div><!-- fragment --><p> which looks like that with a simple <a class="el" href="classDGtal_1_1HueShadeColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into a colo...">HueShadeColorMap</a> varying from 0 to 255 and with (1,1) the first bottom-left point:</p>
<div class="image">
<img src="image.png" alt="image.png"/>
<div class="caption">
(1) simple 16x16 image: (1,1) to (16,16) drawn with a simple HueShadeColorMap varying from 0 to 255.</div></div>
 <p>Here is now the construction of a simple image adapter that use a subdomain of the initial image domain to access the first bottom-left 8x8 image:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> ConstImageAdapter&lt;Image, Domain, DefaultFunctor, Image::Value, DefaultFunctor &gt; ConstImageAdapterForSubImage;</div>
<div class="line">  <a class="code" href="namespaceDGtal_1_1Z2i.html#aca523bebdae58eb19385aaefffff8bc5">Domain</a> subDomain(Point(1,1), Point(8,8));</div>
<div class="line">  ConstImageAdapterForSubImage subImage(image, subDomain, df, df);</div>
</div><!-- fragment --><p> and here is the result: </p>
<div class="image">
<img src="subImage.png" alt="subImage.png"/>
<div class="caption">
(2) first bottom-left 8x8 image: (1,1) to (8,8) adapted from image (1) with a subdomain.</div></div>
 <p>Here is then the construction of an image adapter that use a specific domain: here, only one pixel on two in x and y coordinates, created like that:</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceDGtal_1_1Z2i.html#a371252c324e496cf8650757c1a2b4eb0">DigitalSet</a> <span class="keyword">set</span>(domain);</div>
<div class="line">  <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y=0; y &lt; 17; y++)</div>
<div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x=0; x &lt; 17; x++)</div>
<div class="line">        <span class="keywordflow">if</span> ((x%2) &amp;&amp; (y%2))</div>
<div class="line">          <span class="keyword">set</span>.insertNew(Point(x,y));</div>
<div class="line">        </div>
<div class="line">  DigitalSetDomain&lt;DigitalSet&gt; specificDomain(<span class="keyword">set</span>);</div>
</div><!-- fragment --><p> from the initial image domain.</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> ConstImageAdapter&lt;Image, DigitalSetDomain&lt;DigitalSet&gt;, DefaultFunctor, <a class="code" href="classDGtal_1_1Image.html#ad56b43a36c897e64398934c8f7a3b01c">Image::Value</a>, DefaultFunctor &gt; ConstImageAdapterForSpecificImage;</div>
<div class="line">  ConstImageAdapterForSpecificImage specificImage(image, specificDomain, df, df);</div>
</div><!-- fragment --><p> Here is the result:</p>
<div class="image">
<img src="specificImage.png" alt="specificImage.png"/>
<div class="caption">
(3) 16x16 image: (1,1) to (16,16) adapted from image (1) with a specific domain.</div></div>
 <p>Here is now the construction of an image adapter that is a thresholded view of the initial scalar image:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> ConstImageAdapter&lt;Image, Domain, DefaultFunctor, bool, Thresholder&lt;Image::Value&gt; &gt; ConstImageAdapterForThresholderImage;</div>
<div class="line">  Thresholder&lt;Image::Value&gt; t(127);</div>
<div class="line">  ConstImageAdapterForThresholderImage thresholderImage(image, domain, df, t);</div>
</div><!-- fragment --><p> and here is the result with a simple <a class="el" href="classDGtal_1_1GrayscaleColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into gray l...">GrayscaleColorMap</a> varying from 0 to 1:</p>
<div class="image">
<img src="thresholderImage.png" alt="thresholderImage.png"/>
<div class="caption">
(4) 16x16 image: (1,1) to (16,16) adapted from image (1) with a thresholder set to 127.</div></div>
 <p>Here is finally the construction of an image adapter that use a functor to change 'unsigned char' values to 'double' values using a log scale functor defined like that:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Scalar&gt;</div>
<div class="line"><span class="keyword">struct </span>LogScaleFunctor {</div>
<div class="line"></div>
<div class="line">  LogScaleFunctor() {};</div>
<div class="line">  <span class="keywordtype">double</span> operator()(<span class="keyword">const</span> Scalar &amp;a)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> std::log( 1 + NumberTraits&lt;Scalar&gt;::castToDouble(a) );</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">};</div>
</div><!-- fragment --><p> defined from the initial image:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> ConstImageAdapter&lt;Image, Domain, DefaultFunctor, double, LogScaleFunctor&lt;Image::Value&gt; &gt; ConstImageAdapterForLogScale;</div>
<div class="line">  LogScaleFunctor&lt;Image::Value&gt; logScale;</div>
<div class="line">  ConstImageAdapterForLogScale logImage(image, domain, df, logScale);</div>
</div><!-- fragment --><p> and here is the result with a simple <a class="el" href="classDGtal_1_1HueShadeColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into a colo...">HueShadeColorMap</a> varying from 0. to logScale(255):</p>
<div class="image">
<img src="logImage.png" alt="logImage.png"/>
<div class="caption">
(5) 16x16 image: (1,1) to (16,16) adapted from image (1) with a log scale functor.</div></div>
 <h2><a class="anchor" id="imageadat"></a>
ImageAdapter</h2>
<p><a class="el" href="classDGtal_1_1ImageAdapter.html" title="Aim: implements an image adapter with a given domain (i.e. a subdomain) and 3 functors : g for domain...">ImageAdapter</a> is a small class that adapts an image (like <a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a>) but provides a virtual access (reading and writing) of the true values contained in the adapted image. It uses a given Domain (i.e. a subdomain) but work directly (for reading and writing processes) thanks to an alias (i.e. a pointer) on the original <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a> given in argument.</p>
<p>This class requires an additional templare paremter: <em>TFunctoVm1:</em> functor to convert adapted image values to the original image values.</p>
<p>The values associated to accessing the point values are adapted with a functor g and a functor f given at construction so that operator() calls f(img(g(aPoint))), instead of calling directly operator() of the underlying image img.</p>
<p>The values associated to writing the points are adapted with a functor <em>g</em> and a functor \( f^{-1}\) given at construction so that setValue() is <em>img.setValue</em>(g(aPoint), f-1(aValue)).</p>
<p>The use is the same that for <a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a const image adapter with a given domain (i.e. a subdomain) and 2 functors : g for d...">ConstImageAdapter</a>.</p>
<h1><a class="anchor" id="dgtalImagesFunctions"></a>
Useful classes and functions</h1>
<p>In addition to the image containers and the image adapters described in the previous sections, there are also image proxys:</p>
<p><a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a> is a light proxy on image containers based on a COW pointer. It can be constructed, copied, assigned, deleted without any special care.</p>
<p>Moreover, in <a class="el" href="ImageHelper_8h_source.html">ImageHelper.h</a>, many useful functions are provided.</p>
<ol type="1">
<li>Conversely, others convert images into digital sets with value comparators: setFromPointsRangeAndPredicate, setFromPointsRangeAndFunctor, setFromImage.</li>
</ol>
<ol type="1">
<li>Some of them convert digital sets into images, imageFromRangeAndValue assigns a given value in an image to each point of a given range.</li>
</ol>
<ol type="1">
<li>Lastly, some functions are available to fastly fill images from point functors or other images: imageFromFunctor and imageFromImage. </li>
</ol>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 22 2013 14:15:45 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
