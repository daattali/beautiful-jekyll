<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Digital straight lines and segments   &lt;br&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Digital straight lines and segments <br  />
 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#moduleArithDSSReco-DSL">Digital straight lines</a><ul><li class="level2"><a href="#moduleArithDSSReco-DSL-Ex">Short example</a></li>
<li class="level2"><a href="#moduleArithDSSReco-DSL-Orientation">Orientation</a></li>
<li class="level2"><a href="#moduleArithDSSReco-DSL-Members">Data members</a></li>
<li class="level2"><a href="#moduleArithDSSReco-DSL-Features">Main features</a></li>
<li class="level2"><a href="#moduleArithDSSReco-DSL-Overflows">Avoiding overflows</a></li>
<li class="level2"><a href="#moduleArithDSSReco-DSL-Further">To go further</a></li>
</ul>
</li>
<li class="level1"><a href="#moduleArithDSSReco-DSS">Digital straight segments</a><ul><li class="level2"><a href="#moduleArithDSSReco-DSS-Ex">Short example</a></li>
<li class="level2"><a href="#moduleArithDSSReco-DSS-Features">Main features</a></li>
<li class="level2"><a href="#moduleArithDSSReco-DSS-Ctors">Different ways of constructing DSSs</a></li>
</ul>
</li>
<li class="level1"><a href="#moduleArithDSSReco-DSSRec">Recognition of digital straight segments</a><ul><li class="level2"><a href="#moduleArithDSSReco-DSSRec-Extension">Extension</a></li>
<li class="level2"><a href="#moduleArithDSSReco-DSSRec-Retraction">Retraction</a></li>
<li class="level2"><a href="#moduleArithDSSReco-DSSRec-Computers">NaiveDSS8Computer and StandardDSS4Computer</a></li>
<li class="level2"><a href="#moduleArithDSSReco-DSSRec-Computers3D">Naive3DDSSComputer</a></li>
</ul>
</li>
<li class="level1"><a href="#moduleArithDSSReco-DSSRecAppli">Application of the straight line segment recognition</a><ul><li class="level2"><a href="#moduleArithDSSReco-DSSRec-Computers3DTangent">Estimation of tangent direction</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Tristan Roussillon and Kacper Pluta</dd></dl>
<p>Part of the <a class="el" href="packageGeometry.html">Geometry package</a>.</p>
<p>This module gathers classes that represent and recognize digital straight segments. To dynamically recognize DSSs along a sequence of points, the basic class is <a class="el" href="classDGtal_1_1ArithmeticalDSSComputer.html" title="Aim: This class is a wrapper around ArithmeticalDSS that is devoted to the dynamic recognition of dig...">ArithmeticalDSSComputer</a>, which is a model of <a class="el" href="structDGtal_1_1concepts_1_1CDynamicBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie....">concepts::CDynamicBidirectionalSegmentComputer</a>. Each instance of <a class="el" href="classDGtal_1_1ArithmeticalDSSComputer.html" title="Aim: This class is a wrapper around ArithmeticalDSS that is devoted to the dynamic recognition of dig...">ArithmeticalDSSComputer</a> has an instance of <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a>, which represents the recognized digital straight segment. <br  />
 Moreover, any instance of <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a> has an instance of <a class="el" href="classDGtal_1_1ArithmeticalDSL.html" title="Aim: This class represents a naive (resp. standard) digital straight line (DSL), ie....">ArithmeticalDSL</a>, which represents the bounding digital straight line of minimal parameters. <br  />
 We detail below these three classes in a reverse order.</p>
<p>Related examples are <a class="el" href="exampleArithmeticalDSL_8cpp.html">exampleArithmeticalDSL.cpp</a>, <a class="el" href="exampleArithmeticalDSS_8cpp.html">exampleArithmeticalDSS.cpp</a>, and <a class="el" href="exampleArithmeticalDSSComputer_8cpp.html">exampleArithmeticalDSSComputer.cpp</a></p>
<h1><a class="anchor" id="moduleArithDSSReco-DSL"></a>
Digital straight lines</h1>
<p>A <b>digital</b> <b>straight</b> <b>line</b> (DSL) of <b>slope</b> \( a/b \) (with \( a,b, \in \mathbb{Z} \), \( \gcd(a,b) = 1 \)), <b>intercept</b> \( \mu \in \mathbb{Z} \) and <b>thickness</b> \( \omega \in \mathbb{Z} \), which is conveniently denoted by \( D(a,b,\mu,\omega) \), is the set of digital points \( (x,y) \in \mathbb{Z}^2 \) such that \( \mu \leq ax - by &lt; \mu + \omega \) (Reveilles, 1991 <a class="el" href="citelist.html#CITEREF_Reveilles_1991_thesis">[85]</a>).</p>
<p>Any DSL such that \( \omega = \max(|a|,|b|) \) (resp. \( \omega = |a| + |b| \)) is said to be naive (resp. standard) and is simply 8-connected (resp. 4-connected) (Reveilles, 1991 <a class="el" href="citelist.html#CITEREF_Reveilles_1991_thesis">[85]</a>).</p>
<p>For instance, the naive DSL \( D(2,5,0,5) \) is depicted below: </p><div class="image">
<img src="NaiveDSL.png" alt=""/>
<div class="caption">
Example of Naive DSL</div></div>
 <p>The standard DSL \( D(2,5,0,7) \) is thicker: </p><div class="image">
<img src="StandardDSL.png" alt=""/>
<div class="caption">
Standard DSL of same slope and same intercept</div></div>
 <p>From now on, let us assume that \( \omega \) is either equal to \(\max(|a|,|b|) \) (naive case) or to \( |a| + |b| \) (standard case). <br  />
 Then, any DSL is merely denoted by \( D(a,b,\mu) \).</p>
<h2><a class="anchor" id="moduleArithDSSReco-DSL-Ex"></a>
Short example</h2>
<p>A naive DSL can be declared and constructed as follows: </p><div class="fragment"><div class="line">  <span class="comment">// Construct a naive DSL from a, b, mu</span></div>
<div class="line">  NaiveDSL&lt;Integer&gt; line( 2, 5, 0 ); </div>
</div><!-- fragment --><p> Then, within a window defined by two points (called firstPoint and lastPoint below), you can iterate over the DSL points: </p><div class="fragment"><div class="line">  <span class="comment">// Draw the DSL points between firstPoint and lastPoint</span></div>
<div class="line">  <span class="keywordflow">for</span> ( <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">NaiveDSL&lt;Integer&gt;::ConstIterator</a> </div>
<div class="line">          it = line.begin(firstPoint), </div>
<div class="line">          ite = line.end(lastPoint);</div>
<div class="line">        it != ite; ++it )</div>
<div class="line">    {</div>
<div class="line">      board &lt;&lt; SetMode( it-&gt;className(), <span class="stringliteral">&quot;Paving&quot;</span> )</div>
<div class="line">            &lt;&lt; *it; <span class="comment">//Draw the point</span></div>
<div class="line">    }</div>
<div class="ttc" id="agreedy-plane-segmentation-ex2_8cpp_html_a6d06fad433cff067dfcbbbf16d6e2dbf"><div class="ttname"><a href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a></div><div class="ttdeci">MyDigitalSurface::ConstIterator ConstIterator</div><div class="ttdef"><b>Definition:</b> <a href="greedy-plane-segmentation-ex2_8cpp_source.html#l00093">greedy-plane-segmentation-ex2.cpp:93</a></div></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Note the difference of semantic between method <a class="el" href="classDGtal_1_1ArithmeticalDSL.html#a77d7a71038b06da712b576056fcd7b7c">ArithmeticalDSL.begin()</a>, which returns an iterator pointing to the input point, and method <a class="el" href="classDGtal_1_1ArithmeticalDSL.html#ab9d136b29b4a28e53617f6f534d1b756">ArithmeticalDSL.end()</a>, which returns an iterator pointing <b>past</b> to the input point.</dd></dl>
<p>In the standard case, it is enough to replace <b>Naive</b> by <b>Standard</b>. </p><div class="fragment"><div class="line">  <span class="comment">// Construct a standard DSL from a, b, mu</span></div>
<div class="line">  StandardDSL&lt;Integer&gt; line( 2, 5, 0 ); </div>
</div><!-- fragment --><p> In order to use classes <a class="el" href="classDGtal_1_1NaiveDSL.html" title="Aim: This class is an alias of ArithmeticalDSS for naive DSL. It represents a naive digital straight ...">NaiveDSL</a> and <a class="el" href="classDGtal_1_1StandardDSL.html" title="Aim: This class is an alias of ArithmeticalDSS for standard DSL. It represents a standard digital str...">StandardDSL</a>, you must include the following file: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/curves/ArithmeticalDSL.h&quot;</span></div>
</div><!-- fragment --><p> Classes <a class="el" href="classDGtal_1_1NaiveDSL.html" title="Aim: This class is an alias of ArithmeticalDSS for naive DSL. It represents a naive digital straight ...">NaiveDSL</a> and <a class="el" href="classDGtal_1_1StandardDSL.html" title="Aim: This class is an alias of ArithmeticalDSS for standard DSL. It represents a standard digital str...">StandardDSL</a> are both aliases of the class <a class="el" href="classDGtal_1_1ArithmeticalDSL.html" title="Aim: This class represents a naive (resp. standard) digital straight line (DSL), ie....">ArithmeticalDSL</a>, which represents either a naive or a standard DSL. It gathers the generic code that represents a DSL in any octant.</p>
<h2><a class="anchor" id="moduleArithDSSReco-DSL-Orientation"></a>
Orientation</h2>
<p>The arithmetical representation \( (a, b, \mu) \) is redondant. Exactly two representations describe one DSL. For instance, \( D(2,5,0) \) and \( D(-2,-5,-5) \) corresponds to the same set of points. This representation is thus interesting, since it includes an orientation preferably chosen to iterate over the DSL points from any point belonging to the DSL. </p><div class="image">
<img src="StandardDSL.png" alt=""/>
<div class="caption">
D(2,5,0) and D(-2,-5,-5) represents the same set of points</div></div>
 <dl class="section note"><dt>Note</dt><dd>Note that you must use method <a class="el" href="classDGtal_1_1ArithmeticalDSL.html#a2ee30d830c7210a1b1bf512ba68127a6">ArithmeticalDSL.negate()</a> to get a representation from another one. Note also that method <a class="el" href="classDGtal_1_1ArithmeticalDSL.html#a1dff8286f73a0ae2175256af3f447a88">ArithmeticalDSL.equalsTo()</a> compare two representations and returns 'true' iff the parameters \( a, b \) and \( \mu \) of the two representations are equal. However, the equality operator <a class="el" href="classDGtal_1_1ArithmeticalDSL.html#aa191b7c3ccd6e56f841bffc36bd1b9ab">ArithmeticalDSL.operator==</a> compare two sets of points and returns 'true' iff the two sets of points are equal, whatever the orientation.</dd></dl>
<h2><a class="anchor" id="moduleArithDSSReco-DSL-Members"></a>
Data members</h2>
<p><a class="el" href="classDGtal_1_1ArithmeticalDSL.html" title="Aim: This class represents a naive (resp. standard) digital straight line (DSL), ie....">ArithmeticalDSL</a> stores as data members not only the parameters \( a, b \) and \( \mu \), but also redondant parameters described below. These extra parameters are useful to efficiently iterate over the DSL points.</p>
<ul>
<li>myA of type <a class="el" href="classDGtal_1_1ArithmeticalDSL.html#ae694c0b4c1dab86eb1fb7a78ffc96e39">ArithmeticalDSL::Coordinate</a>: \( a \) -parameter of the DSL, (equal to the y-component of the direction vector).</li>
<li>myB of type <a class="el" href="classDGtal_1_1ArithmeticalDSL.html#ae694c0b4c1dab86eb1fb7a78ffc96e39">ArithmeticalDSL::Coordinate</a>: \( b \) -parameter of the DSL, (equal to the x-component of the direction vector). <br  />
</li>
<li>myLowerBound of type <a class="el" href="classDGtal_1_1ArithmeticalDSL.html#a532df7f0b3b5bc27d5189114a4b33b96">ArithmeticalDSL::Integer</a>: \( \mu \) -parameter of the DSL that defines the <b>lower</b> <b>leaning</b> <b>line</b> \( ax - by = \mu \).</li>
<li>myUpperBound of type <a class="el" href="classDGtal_1_1ArithmeticalDSL.html#a532df7f0b3b5bc27d5189114a4b33b96">ArithmeticalDSL::Integer</a>: integer equal to \( \mu + \omega - 1 \) that defines the <b>upper</b> <b>leaning</b> <b>line</b>.</li>
<li>myShift of type <a class="el" href="classDGtal_1_1ArithmeticalDSL.html#a20707ddf87c3b55d3fdb2f6ee86320d3">ArithmeticalDSL::Vector</a>: vector \( s \) that translates any point of remainder \( r = ax - by \) to a point of remainder \( r + \omega \). Note that \( s \) is equal to 0 if \( \omega = 0 \), ie. if \( a \) and \( b \) are both null. <br  />
</li>
<li>mySteps of type <a class="el" href="classDGtal_1_1ArithmeticalDSL.html#a381082e991db1a7ff272c0c7a68a0396">ArithmeticalDSL::Steps</a> (STL pair of Vector): couple of vectors \( v \) and \( w \) used to iterate over the DSL points so that a given DSL point \( p \) is followed by its unique neighbor point \( q \) belonging to the DSL in the orientation given by \( a \) and \( b \). Obviously, these two vectors are equal to 0 in the invalid case where \( \omega = 0 \). Moreover, the first vector is equal to the direction vector, while the second one is equal to 0, if \( \omega = 1 \), ie. if the lower leaning line and the upper leaning line are counfounded. Though, in the general case, the first vector translates any point \( p \) of remainder \( r \) to its neighbor point \( q \) of remainder greater than or equal to \( r \), while the second one is such that \( v - w = s \).</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Data member myShift (resp. mySteps) is computed with respect to myA and myB in <a class="el" href="structDGtal_1_1ArithmeticalDSLKernel.html#ae57c3c03da193f97ada09b39f42d23ee">ArithmeticalDSLKernel::steps()</a> (resp. <a class="el" href="structDGtal_1_1ArithmeticalDSLKernel.html#aca1e2b6438120978c88649f7994c5e43">ArithmeticalDSLKernel::shift()</a>). <a class="el" href="structDGtal_1_1ArithmeticalDSLKernel.html" title="Aim: Small class that contains the code that depends on the arithmetical thickness (either naive or s...">ArithmeticalDSLKernel</a> contains the part of the code that depends on the arithmetical thickness (either naive or standard). <br  />
</dd></dl>
<p>Below, three naive DSLs are depicted in the first three octants. Vectors mySteps.first ( \( v \)), mySteps.second ( \( w \)) and myShift ( \( s \)), are repectively depicted in blue, green and red. The two vectors of the orthonormal basis are depicted in black. <br  />
</p>
<div class="image">
<img src="ArithmeticalDSL-8-0-5-8.png" alt=""/>
<div class="caption">
Naive DSL D(5,8,0)</div></div>
 <div class="image">
<img src="ArithmeticalDSL-8-1-8-5.png" alt=""/>
<div class="caption">
Naive DSL D(8,5,0)</div></div>
 <div class="image">
<img src="ArithmeticalDSL-8-2-8-m5.png" alt=""/>
<div class="caption">
Naive DSL D(8,-5,0)</div></div>
 <p>Other octants and specific cases are generated in <a class="el" href="exampleArithmeticalDSL_8cpp.html">exampleArithmeticalDSL.cpp</a>.</p>
<h2><a class="anchor" id="moduleArithDSSReco-DSL-Features"></a>
Main features</h2>
<p><a class="el" href="classDGtal_1_1ArithmeticalDSL.html" title="Aim: This class represents a naive (resp. standard) digital straight line (DSL), ie....">ArithmeticalDSL</a> is a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointFunctor.html" title="Aim: Defines a functor on points.">CPointFunctor</a>, ie. it has a function operator ArithmeticalDSL.operator() that returns 'true' iff the input point belongs to the DSL. Note that a point \( (x,y) \) belongs to the DSL iff its remainder \( ax - by \) lies between \( \mu \) (included) and \( \mu + \omega \) (excluded). Method <a class="el" href="classDGtal_1_1ArithmeticalDSL.html#af05038708b1de5961aa62e8a6ae75b9a">ArithmeticalDSL.remainder()</a> returns the remainder of any input point.</p>
<p>On the other hand, there is a one-to-one mapping between a DSL point and its position in the DSL. For instance, for each x-coordinate \( x \), there is one and only one point \( (x,y) \in \mathbb{Z}^2 \) that belongs to the <b>naive</b> DSL \( D(2,5,0) \). Similarly, for each value \( x+y \), there is one and only one point \( (x,y) \in \mathbb{Z}^2 \) that belongs to the <b>standard</b> DSL \( D(2,5,0) \). Method <a class="el" href="classDGtal_1_1ArithmeticalDSL.html#ae78752223a1214beee6546534f26212f">ArithmeticalDSL.position()</a> returns the position of any input point, whereas method <a class="el" href="classDGtal_1_1ArithmeticalDSL.html#a9d1bcaed045a8973572b8c1f41210a7b">ArithmeticalDSL.getPoint()</a> returns the point located at the specified position. Methods <a class="el" href="classDGtal_1_1ArithmeticalDSL.html#a38deb27e787baab848d49a61f012dbbb">ArithmeticalDSL.before()</a> and <a class="el" href="classDGtal_1_1ArithmeticalDSL.html#a8bebdaedc951f9b74c520d93b1571bfd">ArithmeticalDSL.beforeOrEqual()</a> provide a way of comparing the position of two given points, with respect to the orientation given by \( a \) and \( b \).</p>
<p><a class="el" href="classDGtal_1_1ArithmeticalDSL.html" title="Aim: This class represents a naive (resp. standard) digital straight line (DSL), ie....">ArithmeticalDSL</a> also provides services to iterate over the DSL points from any point belonging to the DSL. <a class="el" href="classDGtal_1_1ArithmeticalDSL.html" title="Aim: This class represents a naive (resp. standard) digital straight line (DSL), ie....">ArithmeticalDSL</a> is a model of <a class="el" href="structDGtal_1_1concepts_1_1CConstBidirectionalRange.html" title="Aim: Defines the concept describing a bidirectional const range.">CConstBidirectionalRange</a> that has inner types called <a class="el" href="classDGtal_1_1ArithmeticalDSL_1_1ConstIterator.html" title="Aim: This class aims at representing an iterator that provides a way to scan the points of a DSL....">ArithmeticalDSL::ConstIterator</a> and <a class="el" href="classDGtal_1_1ArithmeticalDSL.html#aa0d224bda6f569f22b3836ad86e67279">ArithmeticalDSL::ConstReverseIterator</a>, both models of readable iterator and random access iterator. The reader may have a look at the increment and decrement operator of <a class="el" href="classDGtal_1_1ArithmeticalDSL_1_1ConstIterator.html" title="Aim: This class aims at representing an iterator that provides a way to scan the points of a DSL....">ArithmeticalDSL::ConstIterator</a> (ie. <a class="el" href="classDGtal_1_1ArithmeticalDSL_1_1ConstIterator.html#ade0811784ecc88a06bc2ccb735e98455">ArithmeticalDSL::ConstIterator.increment</a> and <a class="el" href="classDGtal_1_1ArithmeticalDSL_1_1ConstIterator.html#abe3d337e0a527b8ffcb612403bae3101">ArithmeticalDSL::ConstIterator.decrement</a>) to see that the code is generic. <br  />
</p>
<p>We list below the main methods of <a class="el" href="classDGtal_1_1ArithmeticalDSL.html" title="Aim: This class represents a naive (resp. standard) digital straight line (DSL), ie....">ArithmeticalDSL</a>:</p><ul>
<li>accessors to data members:<ul>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSL.html#af860d391483feadd985f5853af1b3e20">ArithmeticalDSL::a()</a></li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSL.html#a48b3b515783d4affa383ee694b2b6596">ArithmeticalDSL::b()</a></li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSL.html#ac6c92e11f135d90590643a2b71a4c633">ArithmeticalDSL::mu()</a></li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSL.html#a9e1b99a80ca979e9f28b1690ff196c96">ArithmeticalDSL::omega()</a></li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSL.html#aa06fce59fa7ed011408d1959c37daa69">ArithmeticalDSL::shift()</a></li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSL.html#aa140d80df60231d2f6a5b6574e2742ea">ArithmeticalDSL::steps()</a></li>
</ul>
</li>
<li>iteration services<ul>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a7c59b606b5814eadf12bb73e9d09b10a">ArithmeticalDSS::begin()</a></li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSS.html#afdf8aad06839405eb69acda640847361">ArithmeticalDSS::end()</a></li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSS.html#ace7a23044581b65ba689bbd8546c6a69">ArithmeticalDSS::rbegin()</a></li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSS.html#af6299888ec88759f479e253f72631cc0">ArithmeticalDSS::rend()</a> <br  />
</li>
</ul>
</li>
<li>helpers<ul>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSL.html#a2ee30d830c7210a1b1bf512ba68127a6">ArithmeticalDSL::negate()</a></li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSL.html#af05038708b1de5961aa62e8a6ae75b9a">ArithmeticalDSL::remainder()</a></li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSL.html#a945a05e1040d5cc6a9e8789a1ce84ff7">ArithmeticalDSL::isInDSL()</a> (called in ArithmeticalDSL::operator())</li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSL.html#ae78752223a1214beee6546534f26212f">ArithmeticalDSL::position()</a></li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSL.html#a9d1bcaed045a8973572b8c1f41210a7b">ArithmeticalDSL::getPoint()</a></li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSL.html#a38deb27e787baab848d49a61f012dbbb">ArithmeticalDSL::before()</a></li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSL.html#a8bebdaedc951f9b74c520d93b1571bfd">ArithmeticalDSL::beforeOrEqual()</a></li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="moduleArithDSSReco-DSL-Overflows"></a>
Avoiding overflows</h2>
<p>You may have noticed that myLowerBound ( \( \mu \)) is a member of type <a class="el" href="classDGtal_1_1ArithmeticalDSL.html#a532df7f0b3b5bc27d5189114a4b33b96">ArithmeticalDSL::Integer</a>, whereas myA ( \( a \)) and myB ( \( b \)) are members of type <a class="el" href="classDGtal_1_1ArithmeticalDSL.html#ae694c0b4c1dab86eb1fb7a78ffc96e39">ArithmeticalDSL::Coordinate</a>. <br  />
 For any lower leaning point of coordinates \( (x, y) \) such that \( ax - by = \mu \), myLowerBound may require \( 2n+1 \) bits if \( a \) and \( b \) are stored with \( n \) bits. Therefore, <a class="el" href="classDGtal_1_1NaiveDSL.html" title="Aim: This class is an alias of ArithmeticalDSS for naive DSL. It represents a naive digital straight ...">NaiveDSL</a> and <a class="el" href="classDGtal_1_1StandardDSL.html" title="Aim: This class is an alias of ArithmeticalDSS for standard DSL. It represents a standard digital str...">StandardDSL</a> have not only one template parameter, but two. The first one for the coordinates and the slope, the second one, which should represent a larger domain of integers, for the intercepts and the remainders.</p>
<p>You can set the second template parameter as follows in order to avoid any overflow:</p>
<div class="fragment"><div class="line">  NaiveDSL&lt;DGtal::int16_t, DGtal::int32_t&gt; line2( 17711, 28657, 1607895256 ); </div>
<div class="line">  <span class="comment">//NB: 1 607 895 256 is the remainder of the point (32 767,-32 767), </span></div>
<div class="line">  <span class="comment">//whose coordinates are representable by the type DGtal::int16_t</span></div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; line2 &lt;&lt; line2.isValid(); <span class="comment">//ok </span></div>
<div class="ttc" id="aclassDGtal_1_1Trace_html_ad054990834d2763627166540087a2980"><div class="ttname"><a href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">DGtal::Trace::info</a></div><div class="ttdeci">std::ostream &amp; info()</div></div>
<div class="ttc" id="anamespaceDGtal_html_a8fc7012708b0416880a5c8b12dfdf9dd"><div class="ttname"><a href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">DGtal::trace</a></div><div class="ttdeci">Trace trace</div><div class="ttdef"><b>Definition:</b> <a href="Common_8h_source.html#l00154">Common.h:154</a></div></div>
</div><!-- fragment --><p> Note that an instance of <a class="el" href="classDGtal_1_1ArithmeticalDSL.html" title="Aim: This class represents a naive (resp. standard) digital straight line (DSL), ie....">ArithmeticalDSL</a> is valid iff parameters \( a \) and \( b \) are not both null, are relatively prime, and all the redondant parameters are consistents (see <a class="el" href="classDGtal_1_1ArithmeticalDSL.html#a28914556eea4aebdadf3ded6e133e118">ArithmeticalDSL.isValid()</a> and <a class="el" href="classDGtal_1_1ArithmeticalDSL.html#a81eb705a370f31ac4e2a704534edf148">ArithmeticalDSL.checkShiftAndSteps()</a>).</p>
<h2><a class="anchor" id="moduleArithDSSReco-DSL-Further"></a>
To go further</h2>
<p>In order to perform operations on the continued fraction expansion of the slope, you may consider the usage of the class <a class="el" href="classDGtal_1_1StandardDSLQ0.html" title="Aim: Represents a digital straight line with slope in the first quadrant (Q0: x &gt;= 0,...">StandardDSLQ0</a> (see <a class="el" href="moduleDigitalStraightness.html">Patterns, digital straight lines and subsegments</a>). The main differences between <a class="el" href="classDGtal_1_1ArithmeticalDSL.html" title="Aim: This class represents a naive (resp. standard) digital straight line (DSL), ie....">ArithmeticalDSL</a> and <a class="el" href="classDGtal_1_1StandardDSLQ0.html" title="Aim: Represents a digital straight line with slope in the first quadrant (Q0: x &gt;= 0,...">StandardDSLQ0</a> are listed below:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Class   </th><th class="markdownTableHeadNone">-ArithmeticalDSL-   </th><th class="markdownTableHeadNone">-StandardDSLQ0-    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Slope representation   </td><td class="markdownTableBodyNone">two signed integers   </td><td class="markdownTableBodyNone">an irreductible fraction, whose type is a model of <a class="el" href="structDGtal_1_1concepts_1_1CPositiveIrreducibleFraction.html" title="Aim: Defines positive irreducible fractions, i.e. fraction p/q, p and q non-negative integers,...">CPositiveIrreducibleFraction</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Orientation   </td><td class="markdownTableBodyNone">any octant   </td><td class="markdownTableBodyNone">first quadrant only    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Thickness   </td><td class="markdownTableBodyNone">naive and standard   </td><td class="markdownTableBodyNone">standard only   </td></tr>
</table>
<h1><a class="anchor" id="moduleArithDSSReco-DSS"></a>
Digital straight segments</h1>
<p>We have seen that the points of a DSL may be visited within a range bounded by two points. A <b>digital</b> <b>straight</b> <b>segment</b> (DSS) represents such a set of points.</p>
<h2><a class="anchor" id="moduleArithDSSReco-DSS-Ex"></a>
Short example</h2>
<p>A 8-connected naive DSS can be declared and constructed as follows: </p><div class="fragment"><div class="line">  <span class="comment">// Construct a naive DSS</span></div>
<div class="line">  NaiveDSS8&lt;Integer&gt; segment( 5, 8,                   <span class="comment">//slope</span></div>
<div class="line">                              <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,0), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(8,5), <span class="comment">//ending points </span></div>
<div class="line">                              <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,0), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(8,5), <span class="comment">//upper points</span></div>
<div class="line">                              <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(3,1), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(3,1)  <span class="comment">//lower points</span></div>
<div class="line">                              );</div>
<div class="ttc" id="atestClone2_8cpp_html_a15e9592ccc512dc691b46185e6814758"><div class="ttname"><a href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a></div><div class="ttdeci">MyPointD Point</div><div class="ttdef"><b>Definition:</b> <a href="testClone2_8cpp_source.html#l00383">testClone2.cpp:383</a></div></div>
</div><!-- fragment --><p> You can iterate over the whole set of DSS points as follows: <br  />
 </p><div class="fragment"><div class="line">  <span class="comment">// Trace the position and remainder of each point</span></div>
<div class="line">  <span class="keywordflow">for</span> (<a class="code" href="classDGtal_1_1ArithmeticalDSS.html#a85cecf9843e48285ae3c25342c39f6f7">NaiveDSS8&lt;Integer&gt;::ConstIterator</a> </div>
<div class="line">         it = segment.begin(), </div>
<div class="line">         ite = segment.end(); </div>
<div class="line">       it != ite; ++it )</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> </div>
<div class="line">                   &lt;&lt; segment.position( *it ) &lt;&lt; <span class="stringliteral">&quot;,&quot;</span></div>
<div class="line">                   &lt;&lt; segment.remainder( *it ) </div>
<div class="line">                   &lt;&lt; <span class="stringliteral">&quot;) &quot;</span>; </div>
<div class="line">    }</div>
<div class="ttc" id="aclassDGtal_1_1ArithmeticalDSS_html_a85cecf9843e48285ae3c25342c39f6f7"><div class="ttname"><a href="classDGtal_1_1ArithmeticalDSS.html#a85cecf9843e48285ae3c25342c39f6f7">DGtal::ArithmeticalDSS&lt; TCoordinate, TCoordinate, 8 &gt;::ConstIterator</a></div><div class="ttdeci">DSL::ConstIterator ConstIterator</div><div class="ttdef"><b>Definition:</b> <a href="ArithmeticalDSS_8h_source.html#l00148">ArithmeticalDSS.h:148</a></div></div>
</div><!-- fragment --><p> In addition, you can draw either the points of a DSS or its bounding box with <a class="el" href="classDGtal_1_1Board2D.html" title="Aim: This class specializes a &#39;Board&#39; class so as to display DGtal objects more naturally (with &lt;&lt;)....">Board2D</a> (there are two drawing modes: "Points" and "BoundingBox"). <br  />
 </p><div class="fragment"><div class="line">  Board2D board;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Draw the grid</span></div>
<div class="line">  <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a> <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,0), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(8,5) );</div>
<div class="line">  board &lt;&lt; SetMode(<a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>.className(), <span class="stringliteral">&quot;Grid&quot;</span>)</div>
<div class="line">        &lt;&lt; <a class="code" href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a>;    </div>
<div class="line">  </div>
<div class="line">  <span class="comment">//Draw the points of the DSS</span></div>
<div class="line">  board &lt;&lt; SetMode(<span class="stringliteral">&quot;PointVector&quot;</span>, <span class="stringliteral">&quot;Both&quot;</span>);</div>
<div class="line">  board &lt;&lt; SetMode(segment.className(), <span class="stringliteral">&quot;Points&quot;</span>) </div>
<div class="line">        &lt;&lt; segment;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Draw the bounding box</span></div>
<div class="line">  board &lt;&lt; SetMode(segment.className(), <span class="stringliteral">&quot;BoundingBox&quot;</span>) </div>
<div class="line">        &lt;&lt; segment;</div>
<div class="ttc" id="atestProjection_8cpp_html_a1f1a69f8d8b037b72c2160ed12b3ef51"><div class="ttname"><a href="testProjection_8cpp.html#a1f1a69f8d8b037b72c2160ed12b3ef51">domain</a></div><div class="ttdeci">Domain domain</div><div class="ttdef"><b>Definition:</b> <a href="testProjection_8cpp_source.html#l00088">testProjection.cpp:88</a></div></div>
<div class="ttc" id="atestSimpleRandomAccessRangeFromPoint_8cpp_html_acd532b318489cd93df57e0b3d136d050"><div class="ttname"><a href="testSimpleRandomAccessRangeFromPoint_8cpp.html#acd532b318489cd93df57e0b3d136d050">Domain</a></div><div class="ttdeci">HyperRectDomain&lt; Space &gt; Domain</div><div class="ttdef"><b>Definition:</b> <a href="testSimpleRandomAccessRangeFromPoint_8cpp_source.html#l00044">testSimpleRandomAccessRangeFromPoint.cpp:44</a></div></div>
</div><!-- fragment --><p> The result of this short example taken from <a class="el" href="exampleArithmeticalDSS_8cpp.html">exampleArithmeticalDSS.cpp</a> is presented below:</p>
<div class="image">
<img src="NaiveDSS8.png" alt=""/>
<div class="caption">
A simply 8-connected naive DSS with its bounding box</div></div>
 <p>See <a class="el" href="moduleBoard2D.html">Board2D: a stream mechanism for displaying 2D digital objects</a> to read more about the drawing mechanism.</p>
<p>Similarly, in the standard case, you may write: <br  />
 </p><div class="fragment"><div class="line">  <span class="comment">// Construct a standard DSS</span></div>
<div class="line">  StandardDSS4&lt;Integer&gt; segment( 5, 8,                   <span class="comment">//slope</span></div>
<div class="line">                                 <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,0), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(8,5), <span class="comment">//ending points </span></div>
<div class="line">                                 <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,0), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(8,5), <span class="comment">//upper points</span></div>
<div class="line">                                 <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(4,1), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(4,1)  <span class="comment">//lower points</span></div>
<div class="line">                                 );</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>According to the drawing mode that is chosen for the <b>points</b>, the DSS points can be either drawn as a sequence of edge-connected squares ("Paving" or "Both" mode) or as a polygonal line ("Grid" mode).</dd></dl>
<div class="image">
<img src="StandardDSS4bis.png" alt=""/>
<div class="caption">
A simply 4-standard DSS with its bounding box</div></div>
 <div class="image">
<img src="StandardDSS4.png" alt=""/>
<div class="caption">
Another view of the same DSS</div></div>
 <p>In order to use classes <a class="el" href="classDGtal_1_1NaiveDSS8.html" title="Aim: This class represents a standard digital straight segment (DSS), ie. the sequence of simply 8-co...">NaiveDSS8</a> and <a class="el" href="classDGtal_1_1StandardDSS4.html" title="Aim: This class represents a standard digital straight segment (DSS), ie. the sequence of simply 4-co...">StandardDSS4</a>, you must include the following file: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/curves/ArithmeticalDSS.h&quot;</span></div>
</div><!-- fragment --> <h2><a class="anchor" id="moduleArithDSSReco-DSS-Features"></a>
Main features</h2>
<p>Classes <a class="el" href="classDGtal_1_1NaiveDSS8.html" title="Aim: This class represents a standard digital straight segment (DSS), ie. the sequence of simply 8-co...">NaiveDSS8</a> and <a class="el" href="classDGtal_1_1StandardDSS4.html" title="Aim: This class represents a standard digital straight segment (DSS), ie. the sequence of simply 4-co...">StandardDSS4</a> are both aliases of the class <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a>, which gathers the generic code to represent both a simply 8-connected sequence of points belonging to a naive DSL and a simply 4-connected sequence of points belonging to a standard DSL. As <a class="el" href="classDGtal_1_1ArithmeticalDSL.html" title="Aim: This class represents a naive (resp. standard) digital straight line (DSL), ie....">ArithmeticalDSL</a>, <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a> is a model of <a class="el" href="structDGtal_1_1concepts_1_1CPointFunctor.html" title="Aim: Defines a functor on points.">CPointFunctor</a>, ie. it has a function operator ArithmeticalDSS.operator() that returns 'true' iff the input point belongs to the DSS. As <a class="el" href="classDGtal_1_1ArithmeticalDSL.html" title="Aim: This class represents a naive (resp. standard) digital straight line (DSL), ie....">ArithmeticalDSL</a>, it provides services to iterate over the DSS points. Indeed, <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a> is a model of <a class="el" href="structDGtal_1_1concepts_1_1CConstBidirectionalRange.html" title="Aim: Defines the concept describing a bidirectional const range.">concepts::CConstBidirectionalRange</a>. It has two inner types called <a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a85cecf9843e48285ae3c25342c39f6f7">ArithmeticalDSS::ConstIterator</a> and <a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a8c99c0366976313da68dc7a50592dcc7">ArithmeticalDSS::ConstReverseIterator</a>, which are both models of readable iterator and bidirectional iterator.</p>
<p>Obviously, a given DSS belongs to infinitely many DSLs, but one of them has minimal parameters, ie has a minimal \( \omega \). <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a> uses this minimal bounding DSL to represent its slope and its intercept. <br  />
 Note that an instance of <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a> is oriented with respect to the orientation of its minimal bounding DSL. In addition, <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a> stores as data members not only its minimal bounding DSL, but also its ending points as well as the first and last lower and upper leaning points, due to the role that these points play in the recognition algorithm [Debled and Reveilles, 1995 : <a class="el" href="citelist.html#CITEREF_Debled_1995_ijprai">[39]</a>]. <br  />
</p>
<p>We list below the main methods of <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a>:</p><ul>
<li>accessor to the bounding DSL of minimal parameters<ul>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a46893d97ec508b144868991fa76db933">ArithmeticalDSS::dsl()</a></li>
</ul>
</li>
<li>iteration services<ul>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a7c59b606b5814eadf12bb73e9d09b10a">ArithmeticalDSS::begin()</a></li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSS.html#afdf8aad06839405eb69acda640847361">ArithmeticalDSS::end()</a></li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSS.html#ace7a23044581b65ba689bbd8546c6a69">ArithmeticalDSS::rbegin()</a></li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSS.html#af6299888ec88759f479e253f72631cc0">ArithmeticalDSS::rend()</a> <br  />
</li>
</ul>
</li>
<li>accessors to ending and leaning points<ul>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a549eda29dad4d1ff557564121f4b14e7">ArithmeticalDSS::back()</a> (equal to the first point of the range, ie. * <a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a7c59b606b5814eadf12bb73e9d09b10a">ArithmeticalDSS::begin()</a>)</li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSS.html#af7a7c7ef102364a76b683dbfde766f73">ArithmeticalDSS::front()</a> (equal to the last point of the range, ie. * - - <a class="el" href="classDGtal_1_1ArithmeticalDSS.html#afdf8aad06839405eb69acda640847361">ArithmeticalDSS::end()</a>)</li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a062bc2b071cbede2200ca9ea532999f4">ArithmeticalDSS::Uf()</a></li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSS.html#abf306ebcb6d436cf61425fc0d26bc31d">ArithmeticalDSS::Ul()</a></li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a3e1441933cdd1f0c0f84e4d92fea02ef">ArithmeticalDSS::Lf()</a></li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a05a06a56b09ae6fcb46f6b3a33560d34">ArithmeticalDSS::Ll()</a></li>
</ul>
</li>
<li>helpers<ul>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a11d64f0e6371a510b56563a276f24f77">ArithmeticalDSS::negate()</a></li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a90cc692b945729af2ac3829431d372eb">ArithmeticalDSS::isInDSS()</a> (called in ArithmeticalDSS::operator())</li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Note that the first lower leaning point, the last lower leaning point and the first (or last) upper leaning points are always clockwise-oriented. In other words, with respect to the orientation of the bounding DSL (and its parameters \( a \) and \( b \)), the lower leaning points are always on the left, while the upper leaning points are always on the right of the bounding DSL. This invariant is an important feature of <a class="el" href="classDGtal_1_1ArithmeticalDSL.html" title="Aim: This class represents a naive (resp. standard) digital straight line (DSL), ie....">ArithmeticalDSL</a> and <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a> that may be used to link DSS leaning points and convex hull vertices in a convex part. It is used in the computation of the <b>Faithful</b> <b>Polygon</b> (<a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a>) (see Roussillon and Sivignon, 2011 <a class="el" href="citelist.html#CITEREF_RoussillonSivignonPR2011">[90]</a>).</dd></dl>
<h2><a class="anchor" id="moduleArithDSSReco-DSS-Ctors"></a>
Different ways of constructing DSSs</h2>
<p>You can construct a DSS by specifying the value of all its data members. Though, the resulting DSS may be not valid and you should test its validity before using it. An instance of <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a> is valid iff the DSL parameters, the ending points and the leaning points are consistent.</p>
<p>There are five extra ways of constructing an instance of <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a>:</p><ul>
<li>from the minimal set of data members required to build the DSS in constant time. <br  />
 <div class="fragment"><div class="line">    <span class="comment">// Custom a naive DSS </span></div>
<div class="line">    NaiveDSS8&lt;Integer&gt; segment( 5, 8,                   <span class="comment">//slope</span></div>
<div class="line">                                <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,0), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(8,5), <span class="comment">//ending points </span></div>
<div class="line">                                <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,0), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(8,5), <span class="comment">//upper points</span></div>
<div class="line">                                <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(3,1), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(3,1)  <span class="comment">//lower points</span></div>
<div class="line">                                );</div>
<div class="line">    <span class="comment">//You should be sure that your object is valid before using it</span></div>
<div class="line">    <span class="keywordflow">if</span> (!segment.isValid()) <span class="keywordflow">throw</span> std::exception(); </div>
</div><!-- fragment --></li>
<li>from two points, considered either as two upper or two lower leaning points. The construction runs in logarithmic-time (because of the computation of the irreductible slope and the computation of the opposite leaning points). <div class="fragment"><div class="line">    <span class="comment">// Construct a naive DSS from two upper leaning points</span></div>
<div class="line">    NaiveDSS8&lt;Integer&gt; segment( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,0), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(8,5), <span class="keyword">true</span> ); </div>
<div class="line">    <span class="comment">//or simply NaiveDSS8&lt;Integer&gt; segment( Point(0,0), Point(8,5) ); </span></div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">// Construct a naive DSS from two lower leaning points</span></div>
<div class="line">    NaiveDSS8&lt;Integer&gt; segment( <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,0), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(8,5), <span class="keyword">false</span> ); </div>
</div><!-- fragment --></li>
<li>as a subsegment of a given DSL. The construction is based on the smartCH algorithm and runs in logarithmic-time (see Roussillon 2014 <a class="el" href="citelist.html#CITEREF_RoussillonDGCI2014">[91]</a>). <div class="fragment"><div class="line">    <span class="comment">// Construct a naive DSS as a DSL subsegment</span></div>
<div class="line">    NaiveDSS8&lt;Integer&gt; segment( NaiveDSL&lt;Integer&gt;(5,8,0), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,0), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(8,5) ); </div>
</div><!-- fragment --></li>
<li>as a subsegment of a greater DSS (with known leaning points). The construction is based on the reversedSmartCH algorithm and runs in logarithmic-time (see Roussillon 2014 <a class="el" href="citelist.html#CITEREF_RoussillonDGCI2014">[91]</a>). <div class="fragment"><div class="line">    <span class="comment">// Construct a naive DSS as a subsegment of a greater DSS</span></div>
<div class="line">    NaiveDSS8&lt;Integer&gt; segment( bigDSS, <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,0), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(8,5) ); </div>
</div><!-- fragment --></li>
<li>from a sequence of simply connected points. The construction runs in linear-time, using the recognition algorithm of [Debled and Reveilles, 1995 : <a class="el" href="citelist.html#CITEREF_Debled_1995_ijprai">[39]</a>], which is detailed in the next section. <div class="fragment"><div class="line">    <span class="comment">// Construct a DSS from a range of points  </span></div>
<div class="line">    NaiveDSS8&lt;Integer&gt; segment( r.begin(), r.end() );</div>
</div><!-- fragment --> </li>
</ul>
<h1><a class="anchor" id="moduleArithDSSReco-DSSRec"></a>
Recognition of digital straight segments</h1>
<p>Debled and Reveilles <a class="el" href="citelist.html#CITEREF_Debled_1995_ijprai">[39]</a> present an algorithm to incrementally recognize a naive DSS. Even if their algorithm originally deals with naive DSSs only, it is trivial to extend it to standard DSSs.</p>
<h2><a class="anchor" id="moduleArithDSSReco-DSSRec-Extension"></a>
Extension</h2>
<p>Let us assume that we have a DSS \( S \). The problem consists in deciding whether the union between \( S \) and a point \( M \) is still a DSS or not. If it is a DSS, we want to have the parameters of the bounding DSL of minimal parameters. <br  />
 The point \( M \) is assumed to be simply connected to the front (resp. back) point of \( S \). <br  />
 <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a> provides two methods for this purpose: <a class="el" href="classDGtal_1_1ArithmeticalDSS.html#ae73dc5dc84c087877ef1fd6af323fd59">ArithmeticalDSS::extendFront()</a> (resp. <a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a6e4a8f4ddcf27b6cf0c92dd3599e9a8d">ArithmeticalDSS::extendBack()</a>), based on <a class="el" href="citelist.html#CITEREF_Debled_1995_ijprai">[39]</a>. <br  />
</p>
<p>Method <a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a575c863a3ab1dd7489e6563bbbb106b5">ArithmeticalDSS::isExtendableFront()</a> (resp. <a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a172fcdfc0b6be3fa8cb361d0bd334ed1">ArithmeticalDSS::isExtendableBack()</a>), tells if \( S \cup M \) is still a DSS and how to update \( S \) in this case, whereas method <a class="el" href="classDGtal_1_1ArithmeticalDSS.html#ae73dc5dc84c087877ef1fd6af323fd59">ArithmeticalDSS::extendFront()</a> (resp. <a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a6e4a8f4ddcf27b6cf0c92dd3599e9a8d">ArithmeticalDSS::extendBack()</a>) calls method <a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a575c863a3ab1dd7489e6563bbbb106b5">ArithmeticalDSS::isExtendableFront()</a> (resp. <a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a172fcdfc0b6be3fa8cb361d0bd334ed1">ArithmeticalDSS::isExtendableBack()</a>) and performs the update accordingly. <br  />
</p>
<dl class="section note"><dt>Note</dt><dd>Only <a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a575c863a3ab1dd7489e6563bbbb106b5">ArithmeticalDSS::isExtendableFront()</a> and <a class="el" href="classDGtal_1_1ArithmeticalDSS.html#ae73dc5dc84c087877ef1fd6af323fd59">ArithmeticalDSS::extendFront()</a> share the implementation of the recognition algorithm. <a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a172fcdfc0b6be3fa8cb361d0bd334ed1">ArithmeticalDSS::isExtendableBack()</a> and <a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a6e4a8f4ddcf27b6cf0c92dd3599e9a8d">ArithmeticalDSS::extendBack()</a> respectively calls <a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a575c863a3ab1dd7489e6563bbbb106b5">ArithmeticalDSS::isExtendableFront()</a> and <a class="el" href="classDGtal_1_1ArithmeticalDSS.html#ae73dc5dc84c087877ef1fd6af323fd59">ArithmeticalDSS::extendFront()</a> after having negated the DSS representation (see <a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a11d64f0e6371a510b56563a276f24f77">ArithmeticalDSS::negate()</a>). <br  />
</dd></dl>
<p>Let us consider that \( S \) and \( M \) are defined as follows: </p><div class="fragment"><div class="line">  <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> M(11, 7); </div>
<div class="line">  NaiveDSS8&lt;Integer&gt; S( 5, 8,       <span class="comment">//slope </span></div>
<div class="line">                        <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,0), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(10,6), <span class="comment">//ending points </span></div>
<div class="line">                        <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,0), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(8,5), <span class="comment">//upper points</span></div>
<div class="line">                        <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(3,1), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(3,1)  <span class="comment">//lower points</span></div>
<div class="line">                        );</div>
</div><!-- fragment --> <div class="image">
<img src="NaiveDSS8ExtInit.png" alt=""/>
<div class="caption">
Extension to the red point</div></div>
 <p>The extention is simply done as follows: </p><div class="fragment"><div class="line">  <span class="keywordtype">bool</span> resExtention = S.extendFront( M ); </div>
</div><!-- fragment --><p> In this case, the return value is true and the resulting DSS is: </p><div class="image">
<img src="NaiveDSS8ExtDone.png" alt=""/>
<div class="caption">
Extended DSS</div></div>
 <h2><a class="anchor" id="moduleArithDSSReco-DSSRec-Retraction"></a>
Retraction</h2>
<p><a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a> can also perform the converse operation, ie. removing the front (resp. back) point of a given DSS \( S \) and computing the parameters of the resulting DSS (Feschet and Tougne <a class="el" href="citelist.html#CITEREF_FeschetTougneDGCI1999">[45]</a>, Lachaud et. al. <a class="el" href="citelist.html#CITEREF_LachaudIVC2007">[62]</a>). <br  />
</p>
<p>For instance, the following code just undoes the previous extension: </p><div class="fragment"><div class="line">  <span class="keywordtype">bool</span> resRetraction = S.retractFront(); </div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd><a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a619ab2bab18c6967df376858ad6a25aa">ArithmeticalDSS::retractFront()</a> reverts the extension performed by <a class="el" href="classDGtal_1_1ArithmeticalDSS.html#ae73dc5dc84c087877ef1fd6af323fd59">ArithmeticalDSS::extendFront()</a> to the front of the DSS. Conversely, <a class="el" href="classDGtal_1_1ArithmeticalDSS.html#aaf1473297c53a47ac348e31e4ea6454a">ArithmeticalDSS::retractBack()</a> reverts the extension performed by <a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a6e4a8f4ddcf27b6cf0c92dd3599e9a8d">ArithmeticalDSS::extendBack()</a> to the back of the DSS. You can keep in mind the following diagram to remember the rationale of the methods name. <br  />
 <div class="image">
<img src="BackFrontFigure.png" alt=""/>
<div class="caption">
Operations applied to the back and front of a DSS</div></div>
 </dd></dl>
<p>To sum up, we list below the update methods of <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a>:</p><ul>
<li>extension tests:<ul>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a575c863a3ab1dd7489e6563bbbb106b5">ArithmeticalDSS::isExtendableFront()</a></li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a172fcdfc0b6be3fa8cb361d0bd334ed1">ArithmeticalDSS::isExtendableBack()</a></li>
</ul>
</li>
<li>extension:<ul>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSS.html#ae73dc5dc84c087877ef1fd6af323fd59">ArithmeticalDSS::extendFront()</a></li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a6e4a8f4ddcf27b6cf0c92dd3599e9a8d">ArithmeticalDSS::extendBack()</a></li>
</ul>
</li>
<li>retraction:<ul>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSS.html#a619ab2bab18c6967df376858ad6a25aa">ArithmeticalDSS::retractFront()</a></li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSS.html#aaf1473297c53a47ac348e31e4ea6454a">ArithmeticalDSS::retractBack()</a></li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="moduleArithDSSReco-DSSRec-Computers"></a>
NaiveDSS8Computer and StandardDSS4Computer</h2>
<p><a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a> is an arithmetical representation of the DSS primitive. As we have just seen, some methods are available to update the representation in some cases. <br  />
 However, the <a class="el" href="packageGeometry.html">Geometry package</a> provides objects, called <b>segment</b> <b>computers</b>, devoted to the recognition of primitives (See <a class="el" href="moduleGridCurveAnalysis.html">Analysis of one-dimensional discrete structures</a>). In this framework, <a class="el" href="classDGtal_1_1ArithmeticalDSSComputer.html" title="Aim: This class is a wrapper around ArithmeticalDSS that is devoted to the dynamic recognition of dig...">ArithmeticalDSSComputer</a> is a wrapper around <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: This class represents a naive (resp. standard) digital straight segment (DSS),...">ArithmeticalDSS</a> devoted to the dynamic recognition of DSSs along any sequence of points. <a class="el" href="classDGtal_1_1ArithmeticalDSSComputer.html" title="Aim: This class is a wrapper around ArithmeticalDSS that is devoted to the dynamic recognition of dig...">ArithmeticalDSSComputer</a> has two aliases: NaiveDSS8Computer and StandardDSS4Computer. <br  />
</p>
<p>As a model of <a class="el" href="structDGtal_1_1concepts_1_1CDynamicBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie....">CDynamicBidirectionalSegmentComputer</a>, its main methods are:</p><ul>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSSComputer.html#afeb5f56f9b0d7d0ef1be0ca58e83543e">ArithmeticalDSSComputer.init()</a></li>
<li>iteration services<ul>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSSComputer.html#ae348de684636eec784457e9bd44ad32b">ArithmeticalDSSComputer::begin()</a></li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSSComputer.html#ab300209819ed35ddfa269fb2955bee14">ArithmeticalDSSComputer::end()</a></li>
</ul>
</li>
<li>extension tests:<ul>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSSComputer.html#a21e6c1fc56c21790609d05768f9b81e2">ArithmeticalDSSComputer::isExtendableFront()</a></li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSSComputer.html#a1e9faff4651f5021e6ce69ee0898403c">ArithmeticalDSSComputer::isExtendableBack()</a></li>
</ul>
</li>
<li>extension:<ul>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSSComputer.html#ab73f30352cadba398ae8e526974ec474">ArithmeticalDSSComputer::extendFront()</a></li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSSComputer.html#ab1ef856b00dbbb900e450abdb99ed490">ArithmeticalDSSComputer::extendBack()</a></li>
</ul>
</li>
<li>retraction:<ul>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSSComputer.html#a8fdf4ec3102394c4f5b86e1d8dee872a">ArithmeticalDSSComputer::retractFront()</a></li>
<li><a class="el" href="classDGtal_1_1ArithmeticalDSSComputer.html#a550ad8bf204be891674785add8d9d83f">ArithmeticalDSSComputer::retractBack()</a></li>
</ul>
</li>
</ul>
<p>Moreover, <a class="el" href="classDGtal_1_1ArithmeticalDSSComputer.html#a9d942d641717c71e424d537b7c8c81a3">ArithmeticalDSSComputer::primitive()</a> returns an object of type <a class="el" href="classDGtal_1_1ArithmeticalDSSComputer.html#ab19587fa8a568d88514d3342dda50d76">ArithmeticalDSSComputer::Primitive</a> that is actually one of 2D DSSs.</p>
<p>Before using a DSS Computer, you must include the following header: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/curves/ArithmeticalDSSComputer.h&quot;</span></div>
</div><!-- fragment --><p> Then, you can construct a DSS computer as follows: </p><div class="fragment"><div class="line">  <span class="comment">// Container of digital points</span></div>
<div class="line">  <span class="keyword">typedef</span> std::vector&lt;Z2::Point&gt; Container;</div>
<div class="line">  <span class="comment">// Iterator on the container</span></div>
<div class="line">  <span class="keyword">typedef</span> Container::const_iterator <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a>;</div>
<div class="line">  <span class="comment">// StandardDSS4 computer</span></div>
<div class="line">  <span class="keyword">typedef</span> StandardDSS4Computer&lt;ConstIterator&gt; DSSComputer;  </div>
<div class="line">  <span class="comment">// Construction of the computer</span></div>
<div class="line">  DSSComputer theDSSComputer;    </div>
</div><!-- fragment --><p> The extension is simply done as follows: </p><div class="fragment"><div class="line">  <span class="comment">// Add points while it is possible</span></div>
<div class="line">  theDSSComputer.init( contour.begin() );</div>
<div class="line">  <span class="keywordflow">while</span> ( ( theDSSComputer.end() != contour.end() ) &amp;&amp;</div>
<div class="line">          ( theDSSComputer.extendFront() ) ) {}</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You don't need to provide the next point, because <a class="el" href="classDGtal_1_1ArithmeticalDSSComputer.html" title="Aim: This class is a wrapper around ArithmeticalDSS that is devoted to the dynamic recognition of dig...">ArithmeticalDSSComputer</a> can access to the points by iterators.</dd></dl>
<p>Finally, you can get the resulting DSS as follows: </p><div class="fragment"><div class="line">  DSSComputer::Primitive theDSS = theDSSComputer.primitive();  </div>
</div><!-- fragment --><p> The whole example may be found in <a class="el" href="exampleArithmeticalDSSComputer_8cpp.html">exampleArithmeticalDSSComputer.cpp</a>. The use of NaiveDSS8Computer is quite similar.</p>
<h2><a class="anchor" id="moduleArithDSSReco-DSSRec-Computers3D"></a>
Naive3DDSSComputer</h2>
<p>Recognition of a 3D straight line segments is based on a projection of the corresponding 3D digital curve onto three base planes. Then these projections are segmented iteratively as long as at least two such 2D segmentation remains valid. By valid we understand that there are no two points of 3D curve which have the same projection onto a 2D plane.</p>
<p>As a model of <a class="el" href="structDGtal_1_1concepts_1_1CForwardSegmentComputer.html" title="Aim: Defines the concept describing a forward segment computer. Like any model of CIncrementalSegment...">concepts::CForwardSegmentComputer</a>, its main methods are:</p><ul>
<li><a class="el" href="classDGtal_1_1Naive3DDSSComputer.html#a0f21a44b2fe965fce916211330e5a2c4">Naive3DDSSComputer.init()</a></li>
<li>iteration services<ul>
<li><a class="el" href="classDGtal_1_1Naive3DDSSComputer.html#a4e26483e297cc5578c7bbaa59535a19b">Naive3DDSSComputer::begin()</a></li>
<li><a class="el" href="classDGtal_1_1Naive3DDSSComputer.html#ac375f66e996ff660246a1f650360bb9b">Naive3DDSSComputer::end()</a></li>
</ul>
</li>
<li>extension tests:<ul>
<li><a class="el" href="classDGtal_1_1Naive3DDSSComputer.html#a6e7293a1ed8c8299ec788b834ed5d3a0">Naive3DDSSComputer::isExtendableFront()</a></li>
</ul>
</li>
<li>extension:<ul>
<li><a class="el" href="classDGtal_1_1Naive3DDSSComputer.html#a4c0ae0c373a6cb1b74529ec9233f10f5">Naive3DDSSComputer::extendFront()</a></li>
</ul>
</li>
</ul>
<p>Moreover, Naive3DDSSComputer::arithmeticalDSS2d( Dimension ) returns an object of type <a class="el" href="classDGtal_1_1Naive3DDSSComputer.html#a5060a3f1d4eee15419510d9f18e13cf4" title="2D arithmetical DSS recognition algorithm">Naive3DDSSComputer::ArithmeticalDSSComputer2d</a> that is actually the current 2D DSS in a given projection.</p>
<p>Before using a 3D DSS Computer, you must include the following header: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/curves/Naive3DDSSComputer.h&quot;</span></div>
</div><!-- fragment --><p> Then, you can construct a 3D DSS computer as follows: </p><div class="fragment"><div class="line">  <span class="comment">// Container of digital points</span></div>
<div class="line">  <span class="keyword">typedef</span> std::vector&lt;Z3::Point&gt; Container;</div>
<div class="line">  <span class="comment">// Iterator on the container</span></div>
<div class="line">  <span class="keyword">typedef</span> Container::const_iterator <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a>;</div>
<div class="line">  <span class="comment">// Naive3DDSS computer</span></div>
<div class="line">  <span class="keyword">typedef</span> Naive3DDSSComputer&lt; ConstIterator, int, 8 &gt; DSSComputer;  </div>
<div class="line">  <span class="comment">// Construction of the computer</span></div>
<div class="line">  DSSComputer theDSSComputer;    </div>
</div><!-- fragment --><p> The extension is simply done as follows: </p><div class="fragment"><div class="line">  <span class="comment">// Add points while it is possible</span></div>
<div class="line">  theDSSComputer.init( contour.begin() );</div>
<div class="line">  <span class="keywordflow">while</span> ( ( theDSSComputer.end() != contour.end() ) &amp;&amp;</div>
<div class="line">    ( theDSSComputer.extendFront() ) ) {}</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You don't need to provide the next point, because <a class="el" href="classDGtal_1_1Naive3DDSSComputer.html" title="Aim: Dynamic recognition of a 3d-digital straight segment (DSS)">Naive3DDSSComputer</a> can access to the points by iterators.</dd></dl>
<p>You can check which 2D DSS are valid as follows ( 0 - YZ, 1 - XZ, 2 - XY ): </p><div class="fragment"><div class="line">  theDSSComputer.validArithmeticalDSS2d( 0 );  </div>
</div><!-- fragment --><p> And access them: </p><div class="fragment"><div class="line">  DSSComputer::ArithmeticalDSSComputer2d theDSS = theDSSComputer.arithmeticalDSS2d( 0 );  </div>
</div><!-- fragment --><p> Finally to obtain the parameters of 3D DSS </p><div class="fragment"><div class="line">  DSSComputer::Point3d directionZ3;</div>
<div class="line">  DSSComputer::PointR3d intercept;</div>
<div class="line">  DSSComputer::PointR3d thikness;</div>
<div class="line">  theDSSComputer.getParameters ( directionZ3, intercept, thikness );</div>
</div><!-- fragment --><p> The whole example may be found in <a class="el" href="exampleNaive3DDSSComputer_8cpp.html">exampleNaive3DDSSComputer.cpp</a>.</p>
<h1><a class="anchor" id="moduleArithDSSReco-DSSRecAppli"></a>
Application of the straight line segment recognition</h1>
<p>This section contains several examples of application of straight line recognition.</p>
<h2><a class="anchor" id="moduleArithDSSReco-DSSRec-Computers3DTangent"></a>
Estimation of tangent direction</h2>
<p>Example below shows how to estimate tangent directions of a digital curve while using Lambda Maximal Segment Tangent estimation introduced by Lachaud et. al. <a class="el" href="citelist.html#CITEREF_LachaudIVC2007">[62]</a>.</p>
<p>Before using the LMST 2D estimator, you must include the following headers: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/curves/ArithmeticalDSSComputer.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/curves/SaturatedSegmentation.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/curves/estimation/LambdaMST2D.h&quot;</span></div>
</div><!-- fragment --><p> Then, you can construct estimator as follows: </p><div class="fragment"><div class="line">  <span class="keyword">typedef</span> vector &lt; Point &gt; Container;</div>
<div class="line">  <span class="keyword">typedef</span> Container::const_iterator <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a>;</div>
<div class="line">  <span class="keyword">typedef</span> ArithmeticalDSSComputer &lt; ConstIterator, int, 8 &gt; <a class="code" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#a51bb21fda3840e1eff0ee53753ebcbc3">SegmentComputer</a>;</div>
<div class="line">  <span class="keyword">typedef</span> SaturatedSegmentation&lt;SegmentComputer&gt; <a class="code" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#a96c42548d4922d4ea4da9d0a61b746d2">Segmentation</a>;</div>
<div class="line">  LambdaMST2D &lt; Segmentation &gt; lmst;</div>
<div class="ttc" id="atestArithmeticalDSSComputerOnSurfels_8cpp_html_a51bb21fda3840e1eff0ee53753ebcbc3"><div class="ttname"><a href="testArithmeticalDSSComputerOnSurfels_8cpp.html#a51bb21fda3840e1eff0ee53753ebcbc3">SegmentComputer</a></div><div class="ttdeci">ArithmeticalDSSComputer&lt; std::vector&lt; Z2i::Point &gt;::const_iterator, int, 4 &gt; SegmentComputer</div><div class="ttdef"><b>Definition:</b> <a href="testArithmeticalDSSComputerOnSurfels_8cpp_source.html#l00055">testArithmeticalDSSComputerOnSurfels.cpp:55</a></div></div>
<div class="ttc" id="atestArithmeticalDSSComputerOnSurfels_8cpp_html_a96c42548d4922d4ea4da9d0a61b746d2"><div class="ttname"><a href="testArithmeticalDSSComputerOnSurfels_8cpp.html#a96c42548d4922d4ea4da9d0a61b746d2">Segmentation</a></div><div class="ttdeci">SaturatedSegmentation&lt; SegmentComputer &gt; Segmentation</div><div class="ttdef"><b>Definition:</b> <a href="testArithmeticalDSSComputerOnSurfels_8cpp_source.html#l00056">testArithmeticalDSSComputerOnSurfels.cpp:56</a></div></div>
</div><!-- fragment --><p> Notice that by default polynomial lambda function is used. Another ones are implemented in <a class="el" href="FunctorsLambdaMST_8h_source.html">FunctorsLambdaMST.h</a> <br  />
</p>
<p>We need also to generate a tangential cover: </p><div class="fragment"><div class="line">  <span class="comment">// Initialization of tangential cover</span></div>
<div class="line">  <a class="code" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#a96c42548d4922d4ea4da9d0a61b746d2">Segmentation</a> segmenter ( contour.begin(), contour.end(), <a class="code" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#a51bb21fda3840e1eff0ee53753ebcbc3">SegmentComputer</a>() );</div>
<div class="line">  lmst.attach ( segmenter );</div>
</div><!-- fragment --><p> Finally, we can estimate tangent direction point-by-point: </p><div class="fragment"><div class="line">  <span class="keywordflow">for</span> ( <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a> it = contour.begin(); it != contour.end(); ++it )</div>
<div class="line">    lmst.eval ( *it );</div>
</div><!-- fragment --><p> or when we want to calculate tangent directions for a range of points better choice is to do this in following way: </p><div class="fragment"><div class="line">  lmst.init ( contour.begin(), contour.end() );</div>
<div class="line">  std::vector &lt; RealVector &gt; tangent;</div>
<div class="line">  lmst.eval &lt; back_insert_iterator&lt; vector &lt; RealVector &gt; &gt; &gt; ( contour.begin(), contour.end(),  back_inserter ( tangent ) );</div>
</div><!-- fragment --><p>Note that the 3D extension provides a similar interface, but also allows for filtration of DSSes. In the below example, each DSS of length lower equal 7 is not taken into account durin the estimation:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/curves/Naive3DDSSComputer.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/curves/SaturatedSegmentation.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/curves/estimation/LambdaMST3D.h&quot;</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line">  <span class="keyword">typedef</span> vector &lt; Point &gt; Container;</div>
<div class="line">  <span class="keyword">typedef</span> Container::const_iterator <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a>;</div>
<div class="line">  <span class="keyword">typedef</span> Naive3DDSSComputer &lt; ConstIterator, int, 8 &gt; <a class="code" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#a51bb21fda3840e1eff0ee53753ebcbc3">SegmentComputer</a>;</div>
<div class="line">  <span class="keyword">typedef</span> SaturatedSegmentation &lt; SegmentComputer &gt; <a class="code" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#a96c42548d4922d4ea4da9d0a61b746d2">Segmentation</a>;</div>
<div class="line">  LambdaMST3D &lt; Segmentation, Lambda64Function, DSSLengthLessEqualFilter &lt; SegmentComputer &gt; &gt; lmst;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">  <span class="comment">// Initialization of tangential cover</span></div>
<div class="line">  <a class="code" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#a96c42548d4922d4ea4da9d0a61b746d2">Segmentation</a> segmenter ( contour.begin(), contour.end(), <a class="code" href="testArithmeticalDSSComputerOnSurfels_8cpp.html#a51bb21fda3840e1eff0ee53753ebcbc3">SegmentComputer</a>() );</div>
<div class="line">  lmst.attach ( segmenter );</div>
</div><!-- fragment --> <div class="fragment"><div class="line">  lmst.getDSSFilter ( ).init ( 7 );</div>
</div><!-- fragment --> <div class="fragment"><div class="line">  <span class="keywordflow">for</span> ( <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a> it = contour.begin(); it != contour.end(); ++it )</div>
<div class="line">    lmst.eval ( *it );</div>
</div><!-- fragment --> <div class="fragment"><div class="line">    lmst.init ( contour.begin(), contour.end() );</div>
<div class="line">    std::vector &lt; RealVector &gt; tangent;</div>
<div class="line">    lmst.eval &lt; std::back_insert_iterator&lt; std::vector &lt; RealVector &gt; &gt; &gt; ( contour.begin(), contour.end(), std::back_insert_iterator&lt; vector &lt; RealVector &gt; &gt; ( tangent ) );</div>
</div><!-- fragment --><p> Notice that both <a class="el" href="classDGtal_1_1LambdaMST2D.html" title="Aim: Simplify creation of Lambda MST tangent estimator.">LambdaMST2D</a> and <a class="el" href="classDGtal_1_1LambdaMST3D.html" title="Aim: Simplify creation of Lambda MST tangent estimator.">LambdaMST3D</a> are models of <a class="el" href="structDGtal_1_1concepts_1_1CCurveLocalGeometricEstimator.html" title="Aim: This concept describes an object that can process a range so as to return one estimated quantity...">CCurveLocalGeometricEstimator</a>.</p>
<p>Both examples are in <a class="el" href="exampleLMST2D_8cpp.html">exampleLMST2D.cpp</a> and <a class="el" href="exampleLMST3D_8cpp.html">exampleLMST3D.cpp</a></p>
<p>Moreover, there exists a version of LamdaMST3D that uses only 2D projections of the 3D curve (see <a class="el" href="LambdaMST3DBy2D_8h_source.html">LambdaMST3DBy2D.h</a>). This version detects maximal axes during segmentation of the 2D projections, and then the 3D tangent is reconstructed from two 2D tangents that were computed for valid 2D projections. This version does not provide meaningful information in the curve's regions that do not have unique main axis i.e., there exist points such that at least two DSSes passing thru the points have different main axes. Note that, this version has only a research value, and for any application <a class="el" href="classDGtal_1_1LambdaMST3D.html" title="Aim: Simplify creation of Lambda MST tangent estimator.">LambdaMST3D</a> should be used.</p>
<p>Note that this 3D by 2D tangent estimator provides a similar interface to the two other versions:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/curves/estimation/LambdaMST3DBy2D.h&quot;</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line">  <span class="keyword">typedef</span> vector &lt; Point &gt; Container;</div>
<div class="line">  <span class="keyword">typedef</span> Container::const_iterator <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a>;</div>
<div class="line">  LambdaMST3DBy2D &lt; ConstIterator &gt; lmst;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">  <span class="keywordflow">for</span> ( <span class="keyword">const</span> <span class="keyword">auto</span> &amp; p : contour )</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a> ( ) &lt;&lt; lmst.eval ( p ) &lt;&lt; std::endl;</div>
</div><!-- fragment --> <div class="fragment"><div class="line">  lmst.init ( contour.cbegin ( ), contour.cend ( ), LambdaMST3DBy2D &lt; ConstIterator &gt;::MAIN_AXIS::X );</div>
<div class="line">  vector &lt; RealVector &gt; tangent;</div>
<div class="line">  lmst.eval ( contour.cbegin ( ), contour.cend ( ), back_insert_iterator &lt; vector &lt; RealVector &gt; &gt; ( tangent ) );</div>
</div><!-- fragment --><p> See <a class="el" href="exampleLMST3DBy2D_8cpp_source.html">exampleLMST3DBy2D.cpp</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 1 2021 17:06:25 for DGtal by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
