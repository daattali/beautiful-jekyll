<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: DGtal::functors::FunctorHolder&lt; FunctorStorage, NeedDereference &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceDGtal.html">DGtal</a></li><li class="navelem"><a class="el" href="namespaceDGtal_1_1functors.html">functors</a></li><li class="navelem"><a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">DGtal::functors::FunctorHolder&lt; FunctorStorage, NeedDereference &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Aim: hold any callable object (function, functor, lambda, ...) as a C(Unary)Functor model.  
 <a href="classDGtal_1_1functors_1_1FunctorHolder.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="FunctorHolder_8h_source.html">DGtal/base/FunctorHolder.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a26dfd98a1474f56f9cd9ef645350bff5"><td class="memTemplParams" colspan="2">template&lt;typename Function , typename std::enable_if&lt;!std::is_base_of&lt; FunctorHolder, typename std::decay&lt; Function &gt;::type &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a26dfd98a1474f56f9cd9ef645350bff5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html#a26dfd98a1474f56f9cd9ef645350bff5">FunctorHolder</a> (Function &amp;&amp;fn)</td></tr>
<tr class="memdesc:a26dfd98a1474f56f9cd9ef645350bff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classDGtal_1_1functors_1_1FunctorHolder.html#a26dfd98a1474f56f9cd9ef645350bff5">More...</a><br /></td></tr>
<tr class="separator:a26dfd98a1474f56f9cd9ef645350bff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83746a652bfc9b3dab9ffce3e59832f7"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a83746a652bfc9b3dab9ffce3e59832f7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html#a83746a652bfc9b3dab9ffce3e59832f7">operator()</a> (T &amp;&amp;... args) const -&gt; decltype(Invoker&lt; NeedDereference &gt;::apply(this-&gt;<a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html#aff0ae4e9c98d8e105377733f05e25582">myFunctor</a>, std::forward&lt; T &gt;(args)...))</td></tr>
<tr class="memdesc:a83746a652bfc9b3dab9ffce3e59832f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the stored callable object in a constant context.  <a href="classDGtal_1_1functors_1_1FunctorHolder.html#a83746a652bfc9b3dab9ffce3e59832f7">More...</a><br /></td></tr>
<tr class="separator:a83746a652bfc9b3dab9ffce3e59832f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d1a0d66921b249e906bdae7a31f4e7"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ad1d1a0d66921b249e906bdae7a31f4e7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html#ad1d1a0d66921b249e906bdae7a31f4e7">operator()</a> (T &amp;&amp;... args) -&gt; decltype(Invoker&lt; NeedDereference &gt;::apply(this-&gt;<a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html#aff0ae4e9c98d8e105377733f05e25582">myFunctor</a>, std::forward&lt; T &gt;(args)...))</td></tr>
<tr class="memdesc:ad1d1a0d66921b249e906bdae7a31f4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the stored callable object in a mutable context.  <a href="classDGtal_1_1functors_1_1FunctorHolder.html#ad1d1a0d66921b249e906bdae7a31f4e7">More...</a><br /></td></tr>
<tr class="separator:ad1d1a0d66921b249e906bdae7a31f4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5261bdac5ef478ba79c578b4d90e6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html#a2c5261bdac5ef478ba79c578b4d90e6b">selfDisplay</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a2c5261bdac5ef478ba79c578b4d90e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes/Displays the object on an output stream.  <a href="classDGtal_1_1functors_1_1FunctorHolder.html#a2c5261bdac5ef478ba79c578b4d90e6b">More...</a><br /></td></tr>
<tr class="separator:a2c5261bdac5ef478ba79c578b4d90e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da3405b4d0952ef20f48df577125c89"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html#a4da3405b4d0952ef20f48df577125c89">isValid</a> () const</td></tr>
<tr class="memdesc:a4da3405b4d0952ef20f48df577125c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the validity/consistency of the object.  <a href="classDGtal_1_1functors_1_1FunctorHolder.html#a4da3405b4d0952ef20f48df577125c89">More...</a><br /></td></tr>
<tr class="separator:a4da3405b4d0952ef20f48df577125c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aff0ae4e9c98d8e105377733f05e25582"><td class="memItemLeft" align="right" valign="top">FunctorStorage&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html#aff0ae4e9c98d8e105377733f05e25582">myFunctor</a></td></tr>
<tr class="memdesc:aff0ae4e9c98d8e105377733f05e25582"><td class="mdescLeft">&#160;</td><td class="mdescRight">The callable object.  <a href="classDGtal_1_1functors_1_1FunctorHolder.html#aff0ae4e9c98d8e105377733f05e25582">More...</a><br /></td></tr>
<tr class="separator:aff0ae4e9c98d8e105377733f05e25582"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename FunctorStorage, bool NeedDereference&gt;<br />
class DGtal::functors::FunctorHolder&lt; FunctorStorage, NeedDereference &gt;</h3>

<p>Aim: hold any callable object (function, functor, lambda, ...) as a C(Unary)Functor model. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctorStorage</td><td>Type used to store the given callable object. </td></tr>
    <tr><td class="paramname">NeedDereference</td><td>true if the object must be dereferenced before calls.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This class is not meant to be directly constructed by the user. As explained below, you should use instead the <a class="el" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f">holdFunctor</a> helper that will choose the more appropriate storage type depending on the given callable object.</dd></dl>
<p>Given any type of callable object (function, functor and lambda) passed by value, reference or pointer, stores it in the most appropriate way so that the returned object is compatible with <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> functor concept (<a class="el" href="structDGtal_1_1concepts_1_1CUnaryFunctor.html">concepts::CUnaryFunctor</a> so far), and especially the <a class="el" href="structboost_1_1Assignable.html">boost::Assignable</a> concept.</p>
<p>More precisely, the storage mode depends on the lifetime of the given object, deduced from its passing mode :</p><ul>
<li>if the given object is passed by left-value reference (long lifetime), it will be stored as a reference (using <code>std::reference_wrapper</code>).</li>
<li>otherwise (short lifetime, like right-value references), it will be moved to a dynamically allocated memory place (<code>std::shared_ptr</code>) so that the object lifetime matches the <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html" title="Aim: hold any callable object (function, functor, lambda, ...) as a C(Unary)Functor model.">FunctorHolder</a> lifetime.</li>
</ul>
<p>In both case, the returned object is copy/move constructible and copy/move assignable so that it can be used as a functor in all <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> library.</p>
<dl class="section remark"><dt>Remarks</dt><dd>It is important to not explicitly specify the given object type so that it's real lifetime can be deduced using universal reference. However, you can transfer ownership of the object to <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html" title="Aim: hold any callable object (function, functor, lambda, ...) as a C(Unary)Functor model.">FunctorHolder</a> by moving it using <code>std::move</code>. As a consequence, the type of the returned <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html" title="Aim: hold any callable object (function, functor, lambda, ...) as a C(Unary)Functor model.">FunctorHolder</a> cannot be guessed easily and the use of the <code>auto</code> keyword is thus mandatory.</dd></dl>
<p>More informations can be found in the dedicate module page about <a class="el" href="moduleFunctors.html">Using functions, functors and lambdas in DGtal</a> .</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceDGtal_1_1functors.html#a6de5bf68b79330b1bf1b18c5d527538f" title="Hold any callable object (function, functor, lambda, ...) as a C(Unary)Functor model.">holdFunctor</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="FunctorHolder_8h_source.html#l00152">152</a> of file <a class="el" href="FunctorHolder_8h_source.html">FunctorHolder.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a26dfd98a1474f56f9cd9ef645350bff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26dfd98a1474f56f9cd9ef645350bff5">&#9670;&nbsp;</a></span>FunctorHolder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctorStorage , bool NeedDereference&gt; </div>
<div class="memtemplate">
template&lt;typename Function , typename std::enable_if&lt;!std::is_base_of&lt; FunctorHolder, typename std::decay&lt; Function &gt;::type &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">DGtal::functors::FunctorHolder</a>&lt; FunctorStorage, NeedDereference &gt;::<a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">FunctorHolder</a> </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Function</td><td>The type of the callable object (auto-deduced). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>The callable object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="FunctorHolder_8h_source.html#l00172">172</a> of file <a class="el" href="FunctorHolder_8h_source.html">FunctorHolder.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;      : <a class="code" href="classDGtal_1_1functors_1_1FunctorHolder.html#aff0ae4e9c98d8e105377733f05e25582">myFunctor</a>(std::forward&lt;Function&gt;(fn))</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;  {</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;  }</div>
<div class="ttc" id="aclassDGtal_1_1functors_1_1FunctorHolder_html_aff0ae4e9c98d8e105377733f05e25582"><div class="ttname"><a href="classDGtal_1_1functors_1_1FunctorHolder.html#aff0ae4e9c98d8e105377733f05e25582">DGtal::functors::FunctorHolder::myFunctor</a></div><div class="ttdeci">FunctorStorage myFunctor</div><div class="ttdoc">The callable object.</div><div class="ttdef"><b>Definition:</b> <a href="FunctorHolder_8h_source.html#l00157">FunctorHolder.h:157</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4da3405b4d0952ef20f48df577125c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da3405b4d0952ef20f48df577125c89">&#9670;&nbsp;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctorStorage , bool NeedDereference&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">DGtal::functors::FunctorHolder</a>&lt; FunctorStorage, NeedDereference &gt;::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the validity/consistency of the object. </p>
<dl class="section return"><dt>Returns</dt><dd>'true' if the object is valid, 'false' otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="FunctorHolder_8h_source.html#l00225">225</a> of file <a class="el" href="FunctorHolder_8h_source.html">FunctorHolder.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;    {</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad1d1a0d66921b249e906bdae7a31f4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d1a0d66921b249e906bdae7a31f4e7">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctorStorage , bool NeedDereference&gt; </div>
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">DGtal::functors::FunctorHolder</a>&lt; FunctorStorage, NeedDereference &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; decltype(Invoker&lt;NeedDereference&gt;::apply(this-&gt;<a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html#aff0ae4e9c98d8e105377733f05e25582">myFunctor</a>, std::forward&lt;T&gt;(args)...))
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes the stored callable object in a mutable context. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Arguments's types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The arguments. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="FunctorHolder_8h_source.html#l00198">198</a> of file <a class="el" href="FunctorHolder_8h_source.html">FunctorHolder.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    {</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;      <span class="keywordflow">return</span> Invoker&lt;NeedDereference&gt;::apply(<a class="code" href="classDGtal_1_1functors_1_1FunctorHolder.html#aff0ae4e9c98d8e105377733f05e25582">myFunctor</a>, std::forward&lt;T&gt;(args)...);</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="FunctorHolder_8h_source.html#l00157">DGtal::functors::FunctorHolder&lt; FunctorStorage, NeedDereference &gt;::myFunctor</a>.</p>

</div>
</div>
<a id="a83746a652bfc9b3dab9ffce3e59832f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83746a652bfc9b3dab9ffce3e59832f7">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctorStorage , bool NeedDereference&gt; </div>
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">DGtal::functors::FunctorHolder</a>&lt; FunctorStorage, NeedDereference &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> const -&gt; decltype(Invoker&lt;NeedDereference&gt;::apply(this-&gt;<a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html#aff0ae4e9c98d8e105377733f05e25582">myFunctor</a>, std::forward&lt;T&gt;(args)...))
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes the stored callable object in a constant context. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Arguments's types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The arguments. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="FunctorHolder_8h_source.html#l00186">186</a> of file <a class="el" href="FunctorHolder_8h_source.html">FunctorHolder.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    {</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;      <span class="keywordflow">return</span> Invoker&lt;NeedDereference&gt;::apply(<a class="code" href="classDGtal_1_1functors_1_1FunctorHolder.html#aff0ae4e9c98d8e105377733f05e25582">myFunctor</a>, std::forward&lt;T&gt;(args)...);</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="FunctorHolder_8h_source.html#l00157">DGtal::functors::FunctorHolder&lt; FunctorStorage, NeedDereference &gt;::myFunctor</a>.</p>

</div>
</div>
<a id="a2c5261bdac5ef478ba79c578b4d90e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5261bdac5ef478ba79c578b4d90e6b">&#9670;&nbsp;</a></span>selfDisplay()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctorStorage , bool NeedDereference&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">DGtal::functors::FunctorHolder</a>&lt; FunctorStorage, NeedDereference &gt;::selfDisplay </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes/Displays the object on an output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="FunctorHolder_8h_source.html#l00209">209</a> of file <a class="el" href="FunctorHolder_8h_source.html">FunctorHolder.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;    {</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;      out &lt;&lt; <span class="stringliteral">&quot;[FunctorHolder]&quot;</span>;</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;      <span class="keywordflow">if</span> ( SharedPtrTrait::apply(<a class="code" href="classDGtal_1_1functors_1_1FunctorHolder.html#aff0ae4e9c98d8e105377733f05e25582">myFunctor</a>) )</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;        out &lt;&lt; <span class="stringliteral">&quot; using std::shared_ptr storage (rvalue)&quot;</span>;</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ReferenceWrapperTrait::apply(<a class="code" href="classDGtal_1_1functors_1_1FunctorHolder.html#aff0ae4e9c98d8e105377733f05e25582">myFunctor</a>) )</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;        out &lt;&lt; <span class="stringliteral">&quot; using std::reference_wrapper storage (lvalue)&quot;</span>;</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;        out &lt;&lt; <span class="stringliteral">&quot; using custom storage&quot;</span>;</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="FunctorHolder_8h_source.html#l00157">DGtal::functors::FunctorHolder&lt; FunctorStorage, NeedDereference &gt;::myFunctor</a>.</p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="aff0ae4e9c98d8e105377733f05e25582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0ae4e9c98d8e105377733f05e25582">&#9670;&nbsp;</a></span>myFunctor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctorStorage , bool NeedDereference&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FunctorStorage <a class="el" href="classDGtal_1_1functors_1_1FunctorHolder.html">DGtal::functors::FunctorHolder</a>&lt; FunctorStorage, NeedDereference &gt;::myFunctor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The callable object. </p>

<p class="definition">Definition at line <a class="el" href="FunctorHolder_8h_source.html#l00157">157</a> of file <a class="el" href="FunctorHolder_8h_source.html">FunctorHolder.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="FunctorHolder_8h_source.html#l00186">DGtal::functors::FunctorHolder&lt; FunctorStorage, NeedDereference &gt;::operator()()</a>, and <a class="el" href="FunctorHolder_8h_source.html#l00209">DGtal::functors::FunctorHolder&lt; FunctorStorage, NeedDereference &gt;::selfDisplay()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="FunctorHolder_8h_source.html">FunctorHolder.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 1 2021 17:07:09 for DGtal by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
