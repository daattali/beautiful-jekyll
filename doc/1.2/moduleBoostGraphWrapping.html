<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Interfacing with boost::graph library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Interfacing with boost::graph library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#dgtal_graph_boost_1">The Boost Graph library.</a></li>
<li class="level1"><a href="#dgtal_graph_boost_2">Wrapping DigitalSurface as a boost graph</a><ul><li class="level2"><a href="#dgtal_graph_boost_2_1">Making DigitalSurface a boost graph model</a></li>
<li class="level2"><a href="#dgtal_graph_boost_2_2">The boost graph way of visiting vertices</a></li>
<li class="level2"><a href="#dgtal_graph_boost_2_3">The boost graph way of visiting edges</a></li>
<li class="level2"><a href="#dgtal_graph_boost_2_4">The boost graph way of getting adjacent vertices</a></li>
<li class="level2"><a href="#dgtal_graph_boost_2_5">Property maps for more elaborate algorithms</a></li>
<li class="level2"><a href="#dgtal_graph_boost_2_6">A breadth-first visit with the Boost Graph Library</a></li>
<li class="level2"><a href="#dgtal_graph_boost_2_7">More complex algorithms</a></li>
<li class="level2"><a href="#dgtal_graph_boost_3">Wrapping Object as a boost graph</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>by Jacques-Olivier Lachaud</dd></dl>
<p>Part of the <a class="el" href="packageGraph.html">Graph package</a>.</p>
<p>This module shows how to use the Boost Graph library in <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>.</p>
<h1><a class="anchor" id="dgtal_graph_boost_1"></a>
The Boost Graph library.</h1>
<p>The Boost Graph Library (<a href="http://www.boost.org/doc/libs/1_52_0/libs/graph/doc/index.html">http://www.boost.org/doc/libs/1_52_0/libs/graph/doc/index.html</a>) is a very rich library for handling graph concepts, structures and algorithms. It uses a lot generic programming to define a typology of graphs through a hierarchy of concept, and then it provides many generic algorithms on these graphs. Standard implementation of graphs are also provided (adjacency list, incidence matrix). Furthermore this library uses the Boost Property Map Library (<a href="http://www.boost.org/doc/libs/1_52_0/libs/property_map/doc/property_map.html">http://www.boost.org/doc/libs/1_52_0/libs/property_map/doc/property_map.html</a>) to associate data with vertices or edges in a very efficient and generic way.</p>
<p>For these reasons, it would be interesting that <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> graphs match boost graph concepts. However, this cannot be done in full genericity with the present <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> graph concepts. For instance, only finite graphs are handled by boost graphs. Furthermore, it is tricky to have light boost graphs (i.e. graphs constructed on-the-fly), because boost graphs require multipass iterators on vertices and edges.</p>
<p>For now, the only models that are wrapped to satisfy boost graph concepts are:</p><ul>
<li><a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>.</li>
<li><a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a>, since 0.9.2.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>A natural question is why <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> graph concepts do not match exactly boost graph concepts. This is for mainly three reasons:<ul>
<li><a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> graph concepts are very light compared to boost graph, and new models are thus easier to define.</li>
<li>boost graphs only handle finite graphs and we would like to see the adjacency graph of digital spaces as a graph.</li>
<li>boost graphs do not handle implicitly defined graphs, like graphs discover on-the-fly. If you really need boost graph, a copy / conversion is still possible.</li>
</ul>
</dd></dl>
<h1><a class="anchor" id="dgtal_graph_boost_2"></a>
Wrapping DigitalSurface as a boost graph</h1>
<p>The file <a class="el" href="DigitalSurfaceBoostGraphInterface_8h_source.html">DigitalSurfaceBoostGraphInterface.h</a> defines the boost graph traits for any kind of digital surface (see <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>). With these definitions, a <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a> is a model of <a class="el" href="structboost_1_1VertexListGraphConcept.html" title="Go to http://www.boost.org/doc/libs/1_52_0/libs/graph/doc/VertexListGraph.html.">boost::VertexListGraphConcept</a>, <a class="el" href="structboost_1_1AdjacencyGraphConcept.html" title="Go to http://www.boost.org/doc/libs/1_52_0/libs/graph/doc/AdjacencyGraph.html.">boost::AdjacencyGraphConcept</a>, <a class="el" href="structboost_1_1IncidenceGraphConcept.html" title="Go to http://www.boost.org/doc/libs/1_52_0/libs/graph/doc/IncidenceGraph.html.">boost::IncidenceGraphConcept</a>, <a class="el" href="structboost_1_1EdgeListGraphConcept.html" title="Go to http://www.boost.org/doc/libs/1_52_0/libs/graph/doc/EdgeListGraph.html.">boost::EdgeListGraphConcept</a>. You may use a <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a> as any boost graph instance in boost graph algorithms (see <a href="http://www.boost.org/doc/libs/1_52_0/libs/graph/doc/table_of_contents.html">http://www.boost.org/doc/libs/1_52_0/libs/graph/doc/table_of_contents.html</a>).</p>
<dl class="section remark"><dt>Remarks</dt><dd>Note that, for now, vertex iterators are taken as is from the <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a> container. Hence, they must be models of <a class="el" href="structboost_1_1MultiPassInputIterator.html" title="Go to http://www.boost.org/doc/libs/1_52_0/libs/utility/MultiPassInputIterator.html.">boost::MultiPassInputIterator</a>. This <b>is</b> the case for containers <a class="el" href="classDGtal_1_1SetOfSurfels.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels....">SetOfSurfels</a>, <a class="el" href="classDGtal_1_1DigitalSetBoundary.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of a given...">DigitalSetBoundary</a>, <a class="el" href="classDGtal_1_1ImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">ImplicitDigitalSurface</a>, <a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels....">ExplicitDigitalSurface</a>. Containers <a class="el" href="classDGtal_1_1LightImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">LightImplicitDigitalSurface</a> and <a class="el" href="classDGtal_1_1LightExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels....">LightExplicitDigitalSurface</a> are thus <b>not</b> valid.</dd></dl>
<h2><a class="anchor" id="dgtal_graph_boost_2_1"></a>
Making DigitalSurface a boost graph model</h2>
<p>To use a <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a> as a boost graph, you must include the header file <a class="el" href="DigitalSurfaceBoostGraphInterface_8h_source.html">DigitalSurfaceBoostGraphInterface.h</a> <b>before</b> including boost graph headers (!).</p>
<div class="fragment"><div class="line">...</div>
<div class="line">#include <span class="stringliteral">&quot;DGtal/topology/DigitalSurface.h&quot;</span></div>
<div class="line">...</div>
<div class="line">#include <span class="stringliteral">&quot;DGtal/graph/DigitalSurfaceBoostGraphInterface.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/graph/graph_concepts.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/graph/breadth_first_search.hpp&gt;</span></div>
<div class="line">...</div>
</div><!-- fragment --><p>A model of boost graph must satisfy a given number of traits (to define types) as well as functions acting on these types. This is done through specialization of boost::graph_traits. This is done for concrete realizations of template class <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>. The following snippet shows the boost graph way to get the types associated to a graph.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> DigitalSurface&lt; .... &gt; Graph; <span class="comment">// your preferred model of digital surface</span></div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Graph&gt;::vertex_descriptor vertex_descriptor;   <span class="comment">// ie DigitalSurface::Vertex</span></div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Graph&gt;::edge_descriptor edge_descriptor;       <span class="comment">// ie DigitalSurface::Arc</span></div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Graph&gt;::vertices_size_type vertices_size_type; <span class="comment">// ie DigitalSurface::Size</span></div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Graph&gt;::vertex_iterator vertex_iterator;       <span class="comment">// the iterator for visiting all vertices</span></div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Graph&gt;::out_edge_iterator out_edge_iterator;   <span class="comment">// the iterator for visiting out edges of a vertex</span></div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Graph&gt;::edge_iterator edge_iterator;           <span class="comment">// the iterator for visiting all edges</span></div>
</div><!-- fragment --><p>You may check that a <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a> satisfies several graph concepts</p>
<div class="fragment"><div class="line">BOOST_CONCEPT_ASSERT(( <a class="code" href="structboost_1_1VertexListGraphConcept.html">boost::VertexListGraphConcept&lt;Graph&gt;</a> ));</div>
<div class="line">BOOST_CONCEPT_ASSERT(( <a class="code" href="structboost_1_1AdjacencyGraphConcept.html">boost::AdjacencyGraphConcept&lt;Graph&gt;</a> ));</div>
<div class="line">BOOST_CONCEPT_ASSERT(( <a class="code" href="structboost_1_1IncidenceGraphConcept.html">boost::IncidenceGraphConcept&lt;Graph&gt;</a> ));</div>
<div class="line">BOOST_CONCEPT_ASSERT(( <a class="code" href="structboost_1_1EdgeListGraphConcept.html">boost::EdgeListGraphConcept&lt;Graph&gt;</a> ));</div>
<div class="ttc" id="astructboost_1_1AdjacencyGraphConcept_html"><div class="ttname"><a href="structboost_1_1AdjacencyGraphConcept.html">boost::AdjacencyGraphConcept</a></div><div class="ttdoc">Go to http://www.boost.org/doc/libs/1_52_0/libs/graph/doc/AdjacencyGraph.html.</div><div class="ttdef"><b>Definition:</b> <a href="Boost_8dox_source.html#l00165">Boost.dox:165</a></div></div>
<div class="ttc" id="astructboost_1_1EdgeListGraphConcept_html"><div class="ttname"><a href="structboost_1_1EdgeListGraphConcept.html">boost::EdgeListGraphConcept</a></div><div class="ttdoc">Go to http://www.boost.org/doc/libs/1_52_0/libs/graph/doc/EdgeListGraph.html.</div><div class="ttdef"><b>Definition:</b> <a href="Boost_8dox_source.html#l00171">Boost.dox:171</a></div></div>
<div class="ttc" id="astructboost_1_1IncidenceGraphConcept_html"><div class="ttname"><a href="structboost_1_1IncidenceGraphConcept.html">boost::IncidenceGraphConcept</a></div><div class="ttdoc">Go to http://www.boost.org/doc/libs/1_52_0/libs/graph/doc/IncidenceGraph.html.</div><div class="ttdef"><b>Definition:</b> <a href="Boost_8dox_source.html#l00168">Boost.dox:168</a></div></div>
<div class="ttc" id="astructboost_1_1VertexListGraphConcept_html"><div class="ttname"><a href="structboost_1_1VertexListGraphConcept.html">boost::VertexListGraphConcept</a></div><div class="ttdoc">Go to http://www.boost.org/doc/libs/1_52_0/libs/graph/doc/VertexListGraph.html.</div><div class="ttdef"><b>Definition:</b> <a href="Boost_8dox_source.html#l00162">Boost.dox:162</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="dgtal_graph_boost_2_2"></a>
The boost graph way of visiting vertices</h2>
<p>For any boost graph, there is a function <a class="el" href="namespaceboost.html#a9b4917fc7850f916bcbfec9ab2572fe9">boost::vertices</a> that returns a pair of multipass input iterator on vertices representing the range of vertices of the graph. The following snippet shows how it works.</p>
<div class="fragment"><div class="line">Graph g(...); <span class="comment">// your instance of digital surface</span></div>
<div class="line"><span class="keywordflow">for</span> ( std::pair&lt;vertex_iterator, vertex_iterator&gt; vp = <a class="code" href="namespaceboost.html#a9b4917fc7850f916bcbfec9ab2572fe9">boost::vertices</a>( g ); </div>
<div class="line">      vp.first != vp.second; ++vp.first )</div>
<div class="line">  {</div>
<div class="line">     vertex_descriptor v1 = *vp.first;</div>
<div class="line">     <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; v1 &lt;&lt; std::endl; <span class="comment">// displays each vertex</span></div>
<div class="line">  }</div>
<div class="ttc" id="aclassDGtal_1_1Trace_html_ad054990834d2763627166540087a2980"><div class="ttname"><a href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">DGtal::Trace::info</a></div><div class="ttdeci">std::ostream &amp; info()</div></div>
<div class="ttc" id="anamespaceDGtal_html_a8fc7012708b0416880a5c8b12dfdf9dd"><div class="ttname"><a href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">DGtal::trace</a></div><div class="ttdeci">Trace trace</div><div class="ttdef"><b>Definition:</b> <a href="Common_8h_source.html#l00154">Common.h:154</a></div></div>
<div class="ttc" id="anamespaceboost_html_a9b4917fc7850f916bcbfec9ab2572fe9"><div class="ttname"><a href="namespaceboost.html#a9b4917fc7850f916bcbfec9ab2572fe9">boost::vertices</a></div><div class="ttdeci">std::pair&lt; typename graph_traits&lt; DGtal::DigitalSurface&lt; TDigitalSurfaceContainer &gt; &gt;::vertex_iterator, typename graph_traits&lt; DGtal::DigitalSurface&lt; TDigitalSurfaceContainer &gt; &gt;::vertex_iterator &gt; vertices(const DGtal::DigitalSurface&lt; TDigitalSurfaceContainer &gt; &amp;digSurf)</div></div>
</div><!-- fragment --><h2><a class="anchor" id="dgtal_graph_boost_2_3"></a>
The boost graph way of visiting edges</h2>
<p>For models of EdgeListGraphConcept, there is a function <a class="el" href="namespaceboost.html#a02a2d933da658a600caa2c5031315d3a">boost::edges</a> that returns a pair of multipass input iterator on edges representing the range of (oriented) edges of the graph. The following snippet shows how it works.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbEdges = 0;</div>
<div class="line"><span class="keywordflow">for</span> ( std::pair&lt;edge_iterator, edge_iterator&gt; ve = <a class="code" href="namespaceboost.html#a02a2d933da658a600caa2c5031315d3a">boost::edges</a>( g ); </div>
<div class="line">      ve.first != ve.second; ++ve.first, ++nbEdges )</div>
<div class="line">  {</div>
<div class="line">    edge_descriptor e = *ve.first;</div>
<div class="line">    vertex_descriptor v1 = <a class="code" href="namespaceboost.html#a6ef3be04115b85579ddf40d86e3ed4d5">boost::source</a>( e, g );</div>
<div class="line">    vertex_descriptor v2 = <a class="code" href="namespaceboost.html#aa7510b90ea7550b662f26f55df9d3613">boost::target</a>( e, g );</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;Edge &quot;</span> &lt;&lt; nbEdges &lt;&lt; <span class="stringliteral">&quot; is &quot;</span> </div>
<div class="line">                 &lt;&lt; v1 &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span> &lt;&lt; v2 &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="ttc" id="anamespaceboost_html_a02a2d933da658a600caa2c5031315d3a"><div class="ttname"><a href="namespaceboost.html#a02a2d933da658a600caa2c5031315d3a">boost::edges</a></div><div class="ttdeci">std::pair&lt; typename graph_traits&lt; DGtal::DigitalSurface&lt; TDigitalSurfaceContainer &gt; &gt;::edge_iterator, typename graph_traits&lt; DGtal::DigitalSurface&lt; TDigitalSurfaceContainer &gt; &gt;::edge_iterator &gt; edges(const DGtal::DigitalSurface&lt; TDigitalSurfaceContainer &gt; &amp;digSurf)</div><div class="ttdef"><b>Definition:</b> <a href="DigitalSurfaceBoostGraphInterface_8h_source.html#l00503">DigitalSurfaceBoostGraphInterface.h:503</a></div></div>
<div class="ttc" id="anamespaceboost_html_a6ef3be04115b85579ddf40d86e3ed4d5"><div class="ttname"><a href="namespaceboost.html#a6ef3be04115b85579ddf40d86e3ed4d5">boost::source</a></div><div class="ttdeci">graph_traits&lt; DGtal::DigitalSurface&lt; TDigitalSurfaceContainer &gt; &gt;::vertex_descriptor source(typename graph_traits&lt; DGtal::DigitalSurface&lt; TDigitalSurfaceContainer &gt; &gt;::edge_descriptor edge, const DGtal::DigitalSurface&lt; TDigitalSurfaceContainer &gt; &amp;digSurf)</div><div class="ttdef"><b>Definition:</b> <a href="DigitalSurfaceBoostGraphInterface_8h_source.html#l00378">DigitalSurfaceBoostGraphInterface.h:378</a></div></div>
<div class="ttc" id="anamespaceboost_html_aa7510b90ea7550b662f26f55df9d3613"><div class="ttname"><a href="namespaceboost.html#aa7510b90ea7550b662f26f55df9d3613">boost::target</a></div><div class="ttdeci">graph_traits&lt; DGtal::DigitalSurface&lt; TDigitalSurfaceContainer &gt; &gt;::vertex_descriptor target(typename graph_traits&lt; DGtal::DigitalSurface&lt; TDigitalSurfaceContainer &gt; &gt;::edge_descriptor edge, const DGtal::DigitalSurface&lt; TDigitalSurfaceContainer &gt; &amp;digSurf)</div><div class="ttdef"><b>Definition:</b> <a href="DigitalSurfaceBoostGraphInterface_8h_source.html#l00391">DigitalSurfaceBoostGraphInterface.h:391</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="dgtal_graph_boost_2_4"></a>
The boost graph way of getting adjacent vertices</h2>
<p>For models of IncidenceGraphConcept, there is a function <a class="el" href="namespaceboost.html#a8fb99efa52f07ea4a228f1bbeedeb459">boost::out_edges</a> that returns a pair of multipass input iterator on the edges that starts at the given vertex and ends on adjacent vertices. The following snippet shows how it works.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> ( std::pair&lt;vertex_iterator, vertex_iterator&gt; vp = <a class="code" href="namespaceboost.html#a9b4917fc7850f916bcbfec9ab2572fe9">boost::vertices</a>( g ); </div>
<div class="line">      vp.first != vp.second; ++vp.first )</div>
<div class="line">  {</div>
<div class="line">    vertex_descriptor v1 = *vp.first;</div>
<div class="line">    <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;Neighbors of &quot;</span> &lt;&lt; v1 &lt;&lt; <span class="stringliteral">&quot; are&quot;</span>;</div>
<div class="line">    <span class="keywordflow">for</span> ( std::pair&lt;out_edge_iterator, out_edge_iterator&gt; ve = <a class="code" href="namespaceboost.html#a8fb99efa52f07ea4a228f1bbeedeb459">boost::out_edges</a>( v1, g ); </div>
<div class="line">          ve.first != ve.second; ++ve.first )</div>
<div class="line">      {</div>
<div class="line">        vertex_descriptor v2 = <a class="code" href="namespaceboost.html#aa7510b90ea7550b662f26f55df9d3613">boost::target</a>( *ve.first, g );</div>
<div class="line">        <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; v2;</div>
<div class="line">      }</div>
<div class="line">      <a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="ttc" id="anamespaceboost_html_a8fb99efa52f07ea4a228f1bbeedeb459"><div class="ttname"><a href="namespaceboost.html#a8fb99efa52f07ea4a228f1bbeedeb459">boost::out_edges</a></div><div class="ttdeci">std::pair&lt; typename graph_traits&lt; DGtal::DigitalSurface&lt; TDigitalSurfaceContainer &gt; &gt;::out_edge_iterator, typename graph_traits&lt; DGtal::DigitalSurface&lt; TDigitalSurfaceContainer &gt; &gt;::out_edge_iterator &gt; out_edges(typename graph_traits&lt; DGtal::DigitalSurface&lt; TDigitalSurfaceContainer &gt; &gt;::vertex_descriptor u, const DGtal::DigitalSurface&lt; TDigitalSurfaceContainer &gt; &amp;digSurf)</div><div class="ttdef"><b>Definition:</b> <a href="DigitalSurfaceBoostGraphInterface_8h_source.html#l00463">DigitalSurfaceBoostGraphInterface.h:463</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="dgtal_graph_boost_2_5"></a>
Property maps for more elaborate algorithms</h2>
<p>If you wish to use algorithms of the Boost Graph Library, most of them requires mapping from vertex or edge to some value (for instance a color for marking already visited vertices or a scalar for storing a distance or a weight). This is done very generically in Boost Graph through property maps. The system is rather complex but allows you to use indifferently in your algorithms an external map (for instance a std::map&lt; vertex_descriptor, int &gt;) or an embedded value in the vertex_descriptor type.</p>
<p>Standard boost graphs models offer simple mechanism to get a given property map for a graph. In <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>, graph models do not integrate &ndash; for now &ndash; property maps. Therefore, only external property maps can be used. The snippet below shows how to create two property maps for the digital surface <code>g</code>, using standard property map wrappers given in the Boost Property Map Library.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;boost/property_map/property_map.hpp&gt;</span></div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// get the property map for coloring vertices (used for not visiting twice the same vertex).</span></div>
<div class="line">  <span class="keyword">typedef</span> std::map&lt; vertex_descriptor, boost::default_color_type &gt; StdColorMap; <span class="comment">// the container type</span></div>
<div class="line">  StdColorMap colorMap;                                                         <span class="comment">// the container instance (will store computations).</span></div>
<div class="line">  boost::associative_property_map&lt; StdColorMap &gt; propColorMap( colorMap );      <span class="comment">// a facade aroundcolorMap </span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// get the property map for labelling vertices (the mapping Vertex -&gt; Size that stores the component label for each vertex)</span></div>
<div class="line">  <span class="keyword">typedef</span> std::map&lt; vertex_descriptor, vertices_size_type &gt; StdComponentMap;</div>
<div class="line">  StdComponentMap componentMap;</div>
<div class="line">  boost::associative_property_map&lt; StdComponentMap &gt; propComponentMap( componentMap );</div>
</div><!-- fragment --><p>We may afterwards use this property maps in boost graph algorithms. This snippet extracts the connected components of the graph <code>g</code>, and labels each vertex with its component (result is stored in <code>componentMap</code>, hence is also accessible with <code>propComponentMap</code>).</p>
<div class="fragment"><div class="line"><span class="comment">// g must be a model of VertexListGraph</span></div>
<div class="line">vertices_size_type nbComp =</div>
<div class="line">  boost::connected_components <span class="comment">// boost graph connected components algorithm.</span></div>
<div class="line">  ( g, <span class="comment">// the graph</span></div>
<div class="line">    propComponentMap, <span class="comment">// the mapping vertex -&gt; label</span></div>
<div class="line">    boost::color_map( propColorMap ) <span class="comment">// this map is used internally when computing connected components.</span></div>
<div class="line">    );</div>
<div class="line"><a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;- nbComponents = &quot;</span> &lt;&lt; nbComp &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>Note that <code>propColorMap</code> is given a <b>named</b> parameter with a call to boost::color_map. This is the method used in the Boost Graph Library to give handle parameters, especially when the algorithm requires a lot of parameters, some of them being optionnal. This is explained in section (<a href="http://www.boost.org/doc/libs/1_52_0/libs/graph/doc/bgl_named_params.html">http://www.boost.org/doc/libs/1_52_0/libs/graph/doc/bgl_named_params.html</a>).</p>
<dl class="section note"><dt>Note</dt><dd>You may of course use the VertexMap rebind mechanism when creating your property map, as follows.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Works if VertexMap is a correct model of boost::UniqueAssociativeContainer and boost::PairAssociativeContainer.</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> Graph::VertexMap&lt; vertices_size_type &gt; MyComponentMap;</div>
<div class="line">MyComponentMap componentMap;</div>
<div class="line">boost::associative_property_map&lt; MyComponentMap &gt; propComponentMap( componentMap );</div>
</div><!-- fragment --><h2><a class="anchor" id="dgtal_graph_boost_2_6"></a>
A breadth-first visit with the Boost Graph Library</h2>
<p>We need to store distances to the start vertex, therefore we create a dedicated property map (here <code>propDistanceMap</code>). The algorithm also requires a queue (here <code>Q</code>) and a first vertex (<code>start</code>).</p>
<div class="fragment"><div class="line"><span class="comment">// get the property map for storing distances</span></div>
<div class="line"><span class="keyword">typedef</span> std::map&lt; vertex_descriptor, unsigned int &gt; StdDistanceMap;</div>
<div class="line">StdDistanceMap distanceMap;</div>
<div class="line">boost::associative_property_map&lt; StdDistanceMap &gt; propDistanceMap( distanceMap );</div>
<div class="line">boost::queue&lt; vertex_descriptor &gt; Q;            <span class="comment">// std::queue does not have top().</span></div>
<div class="line">vertex_descriptor start = *( g.begin() );</div>
<div class="line">boost::breadth_first_visit                      <span class="comment">// boost graph breadth first visiting algorithm.</span></div>
<div class="line">  ( g,     <span class="comment">// the graph</span></div>
<div class="line">    start, <span class="comment">// the starting vertex</span></div>
<div class="line">    Q,     <span class="comment">// the buffer for breadth first queueing</span></div>
<div class="line">    boost::make_bfs_visitor( boost::record_distances( propDistanceMap, boost::on_tree_edge() ) ), <span class="comment">// only record distances</span></div>
<div class="line">    propColorMap  <span class="comment">// necessary for visiting vertices</span></div>
<div class="line">    );</div>
</div><!-- fragment --><p>The following snippet computes a vertex that is as far away as possible from <code>start</code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxD = 0;</div>
<div class="line">vertex_descriptor furthest = start;</div>
<div class="line"><span class="keywordflow">for</span> ( std::pair&lt;vertex_iterator, vertex_iterator&gt; vp = <a class="code" href="namespaceboost.html#a9b4917fc7850f916bcbfec9ab2572fe9">boost::vertices</a>( g ); </div>
<div class="line">      vp.first != vp.second; ++vp.first )</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = boost::get( propDistanceMap, *vp.first );</div>
<div class="line">    <span class="keywordflow">if</span> ( d &gt; maxD ) </div>
<div class="line">      {</div>
<div class="line">        maxD = d;</div>
<div class="line">        furthest = *vp.first;</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line"><a class="code" href="namespaceDGtal.html#a8fc7012708b0416880a5c8b12dfdf9dd">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#ad054990834d2763627166540087a2980">info</a>() &lt;&lt; <span class="stringliteral">&quot;- d[ &quot;</span> &lt;&lt; furthest &lt;&lt; <span class="stringliteral">&quot; ] = &quot;</span> &lt;&lt; maxD &lt;&lt; std::endl;</div>
</div><!-- fragment --><h2><a class="anchor" id="dgtal_graph_boost_2_7"></a>
More complex algorithms</h2>
<p>You may have a look at <a class="el" href="testDigitalSurfaceBoostGraphInterface_8cpp.html">graph/testDigitalSurfaceBoostGraphInterface.cpp</a> to see a few more examples of using Boost Graph algorithms (max-flow and min-cut).</p>
<h2><a class="anchor" id="dgtal_graph_boost_3"></a>
Wrapping Object as a boost graph</h2>
<p>The file <a class="el" href="ObjectBoostGraphInterface_8h_source.html">ObjectBoostGraphInterface.h</a> defines the boost graph traits for any kind of <a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a> (see <a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a>). With those definitios, an <a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a> is a model of VertexListGraphConcept, AdjacencyGraphConcept, IncidenceGraphConcept, EdgeListGraphConcept. You may use an <a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a> as a graph in any Boost Graph Library algorithm that satisfies the mentioned concepts.</p>
<p>You may have a look at <a class="el" href="testObjectBoostGraphInterface_8cpp.html">graph/testObjectBoostGraphInterface.cpp</a> for examples on how to use <a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a> as a graph. Also see <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a> section, as the interfaces are similar. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 1 2021 17:06:30 for DGtal by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
