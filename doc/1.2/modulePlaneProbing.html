<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Plane-probing based normal estimators</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Plane-probing based normal estimators </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#sectPlaneProbing1">Introduction to plane-probing algorithms</a><ul><li class="level2"><a href="#subsectPlaneProbing11">Tetrahedron-based probing methods</a></li>
<li class="level2"><a href="#subsectPlaneProbing12">Parallelpiped-based probing methods</a></li>
<li class="level2"><a href="#subsectPlaneProbing13">Summary of the different variants</a></li>
</ul>
</li>
<li class="level1"><a href="#sectPlaneProbing2">Constructing and using a plane-probing estimator</a><ul><li class="level2"><a href="#subsectPlaneProbing21">General method</a></li>
<li class="level2"><a href="#subsectPlaneProbing22">On a digital surface</a></li>
</ul>
</li>
<li class="level1"><a href="#sectPlaneProbing3">Further notes</a><ul><li class="level2"><a href="#subsectPlaneProbing31">Implementing your own candidate set</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>Jacques-Olivier Lachaud, Jocelyn Meyron, Tristan Roussillon</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.2</dd></dl>
<p>Part of the <a class="el" href="packageGeometry.html">Geometry package</a>.</p>
<p>This part of the manual describes what are plane-probing estimators, how to define and use them to estimate normals on digital surfaces.</p>
<p>The following programs are related to this documentation: <a class="el" href="examplePlaneProbingTetrahedronEstimator_8cpp.html">geometry/surfaces/examplePlaneProbingTetrahedronEstimator.cpp</a>, <a class="el" href="examplePlaneProbingParallelepipedEstimator_8cpp.html">geometry/surfaces/examplePlaneProbingParallelepipedEstimator.cpp</a>, <a class="el" href="examplePlaneProbingSurfaceLocalEstimator_8cpp.html">geometry/surfaces/examplePlaneProbingSurfaceLocalEstimator.cpp</a>, <a class="el" href="testDigitalPlanePredicate_8cpp.html">testDigitalPlanePredicate.cpp</a>, <a class="el" href="testPlaneProbingTetrahedronEstimator_8cpp.html">testPlaneProbingTetrahedronEstimator.cpp</a>, <a class="el" href="testPlaneProbingParallelepipedEstimator_8cpp.html">testPlaneProbingParallelepipedEstimator.cpp</a>.</p>
<h1><a class="anchor" id="sectPlaneProbing1"></a>
Introduction to plane-probing algorithms</h1>
<p>A plane-probing algorithm (see <a class="el" href="citelist.html#CITEREF_LPRJMIV2017">[61]</a>, <a class="el" href="citelist.html#CITEREF_RLDGCI2019">[89]</a> and <a class="el" href="citelist.html#CITEREF_LMRJMIV2020">[63]</a>) computes the normal vector of a set of digital points from a starting point and a predicate <b>InPlane:</b> "Is a point x in the set of digital points?". This predicate is used to probe the set as locally as possible and decide on-the-fly the next points to consider, in order to deform a particular set of points, which is tangent by construction. The growth direction is given by both arithmetic and geometric properties. The main characteristics of these algorithms is that <em>no</em> <em>parameter</em> is required for the analysis of the local geometry of digital surfaces. Furthermore, they present theoretical guarantees, most notably they extract the exact normal vector of any digital plane.</p>
<h2><a class="anchor" id="subsectPlaneProbing11"></a>
Tetrahedron-based probing methods</h2>
<p>The first kind of plane-probing algorithms is based on the deformation of a tetrahedron. The objective of the algorithm is to iteratively update one vertex of this tetrahedron until one of its faces is parallel to the digital set. The update procedure will consist in selecting a point inside a <em>candidate</em> <em>set</em>. Multiple candidate sets have been proposed but we will start by describing the simplest one, the so-called <em>H-neighborhood</em>. We start by illustrating its behavior when the digital set is a digital plane segment. The next image shows the initial state of the estimator. We will denote by \( (v_k)_{0 \leq k \leq 2 } \) the three vertices of the base triangle (the blue disks on the left), \( q \) a <em>fixed</em> point outside the set at the top of the tetrahedron (the blue circle). Points that are <em>inside</em> the digital set will be denoted by disks while points that are <em>outside</em> by circles.</p>
<div class="image">
<img src="plane-probing-start-frame.png" alt=""/>
<div class="caption">
Left: the base triangle. Right: the base frame at the begining.</div></div>
 <p>We now describe the update procedure in more details, see the next figure.</p>
<div class="image">
<img src="plane-probing-update-H.png" alt=""/>
<div class="caption">
From left to right: before the update, H-neighborhood in red, filtering through <b>InPlane</b>, closest criterion, after the update</div></div>
 <p>At a given iteration, the update step consists of the following substeps:</p><ol type="1">
<li>computing the candidate set (in red),</li>
<li>filtering through the <b>InPlane</b> predicate,</li>
<li>selecting the <em>closest</em> <em>one</em> according to some criterion (here we use a simple <em>Delaunay/InSphere</em> one),</li>
<li>updating one vertex of the base triangle.</li>
</ol>
<p>The algorithm stops whether one of the following criteria is verified:</p><ol type="1">
<li>the candidate set does not contain a point inside the digital set,</li>
<li>the current configuration of the H-neighborhood is <em>non-convex</em>,</li>
<li>the current configuration of the H-neighborhood is <em>non-planar</em>. For the last two, see <a class="el" href="citelist.html#CITEREF_LPRJMIV2017">[61]</a> or the enum <a class="el" href="classDGtal_1_1PlaneProbingNeighborhood.html#a7de337aa87bc093fb60c384bb1ad860f">PlaneProbingNeighborhood::HexagonState</a> for more details.</li>
</ol>
<p>Other candidate sets were proposed namely the <em>R-neighborhood</em> <a class="el" href="citelist.html#CITEREF_LPRJMIV2017">[61]</a> and an optimization that we call <em>R1-neighborhood</em> <a class="el" href="citelist.html#CITEREF_LMRJMIV2020">[63]</a>. The main difference is that instead of considering 6 points of an hexagon, they consider 6 rays. This allows to reduce the number of steps and to obtain a reduced basis at the end. We recommend to use the <em>R1-neighborhood</em>.</p>
<p>The main drawback of this category of algorithms is the fact that they return the correct normal vector on a digital plane only when starting from specific points (precisely reentrant corners of low height). In all other cases, the estimated normal is only an approximation. In the next section, we will present another kind of estimator that can be initialized on <em>any</em> <em>surfel</em> of a digital surface and which returns the correct normal on every surfel of a digital plane.</p>
<h2><a class="anchor" id="subsectPlaneProbing12"></a>
Parallelpiped-based probing methods</h2>
<p>The second kind of plane-probing algorithms is based on the deformation of a pair of tetrahedra i.e. a parallelepiped introduced in <a class="el" href="citelist.html#CITEREF_LMRJMIV2020">[63]</a>. The parallelepiped is ensured to always be <em>separating</em> (one point is always inside the digital set and one point always outside). This approach allows to start the algorithm on any surfel (at least 4 points inside the digital set) and is more general than the previous one.</p>
<div class="image">
<img src="plane-probing-illustration-cube.png" alt=""/>
<div class="caption">
The two tetrahedra are displayed in red and blue. The points p and q are the <em>bases</em> of the two tetrahedra.</div></div>
 <p>This approach is internally based on a new predicate <b>NotAbove</b> that is able to tell whether a digital point \( x \) has a height that is smaller or greater than the one of \( q \). It is easy to see that it can be implemented using ray-casting and the <b>InPlane</b> predicate. It naturally increases the number of calls to <b>InPlane</b> but has several advantages. See <a class="el" href="citelist.html#CITEREF_LMRJMIV2020">[63]</a> or <a href="https://perso.liris.cnrs.fr/tristan.roussillon/pres/2019GDMM.pdf">this presentation</a> (in French) for more details.</p>
<p>We will denote by PH, PR and PR1 the three variations of the parallelepiped estimator for the three different candidate sets.</p>
<h2><a class="anchor" id="subsectPlaneProbing13"></a>
Summary of the different variants</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Algorithm   </th><th class="markdownTableHeadCenter">Principle   </th><th class="markdownTableHeadCenter">Initialization   </th><th class="markdownTableHeadCenter">Candidate Set    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">H   </td><td class="markdownTableBodyCenter">Downward oriented tetrahedron   </td><td class="markdownTableBodyCenter">Any reentrant corner   </td><td class="markdownTableBodyCenter">6 points in a hexagon    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">R, R1   </td><td class="markdownTableBodyCenter">Downward oriented tetrahedron   </td><td class="markdownTableBodyCenter">Any reentrant corner   </td><td class="markdownTableBodyCenter">6 points + 6 rays    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">PH   </td><td class="markdownTableBodyCenter">Separating parallelepiped   </td><td class="markdownTableBodyCenter">Any point   </td><td class="markdownTableBodyCenter">6 points in a hexagon    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">PR, PR1   </td><td class="markdownTableBodyCenter">Separating parallelepiped   </td><td class="markdownTableBodyCenter">Any point   </td><td class="markdownTableBodyCenter">6 points + 6 rays   </td></tr>
</table>
<h1><a class="anchor" id="sectPlaneProbing2"></a>
Constructing and using a plane-probing estimator</h1>
<h2><a class="anchor" id="subsectPlaneProbing21"></a>
General method</h2>
<p>In <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a>, both categories of plane-probing estimators are implemented, see <a class="el" href="classDGtal_1_1PlaneProbingTetrahedronEstimator.html">PlaneProbingTetrahedronEstimator</a> for the first category and <a class="el" href="classDGtal_1_1PlaneProbingParallelepipedEstimator.html">PlaneProbingParallelepipedEstimator</a> for the second one. In the following, we explain the API for <a class="el" href="classDGtal_1_1PlaneProbingTetrahedronEstimator.html">PlaneProbingTetrahedronEstimator</a>.</p>
<p>The general way of instantiating a plane-probing estimator is the following: </p><div class="fragment"><div class="line">  <span class="comment">// The general form is ProbingEstimator&lt;Predicate, mode&gt; where</span></div>
<div class="line">  <span class="comment">// - Predicate is a model of concepts::PointPredicate, see DigitalPlanePredicate or DigitalSurfacePredicate for instance,</span></div>
<div class="line">  <span class="comment">// - mode specifies the candidate set, it is one of { ProbingMode::H, ProbingMode::R, ProbingMode::R1 }.</span></div>
<div class="line">  <span class="keyword">using</span> <a class="code" href="classDGtal_1_1DigitalPlanePredicate.html">DigitalPlane</a> = DigitalPlanePredicate&lt;Space&gt;;</div>
<div class="line">  <span class="keyword">using</span> <a class="code" href="examplePlaneProbingParallelepipedEstimator_8cpp.html#acf36ecb2b183354828ddd0b48821b752">Estimator</a>    = PlaneProbingTetrahedronEstimator&lt;DigitalPlane, ProbingMode::R1&gt;;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// We start by constructing the predicate, here a standard digital plane of normal (2, 6, 15)</span></div>
<div class="line">  <a class="code" href="testCombinDSS_8cpp.html#a609ee1808a3b4f883fb28df65e9a2ed6">Vector</a> n(2, 6, 15);</div>
<div class="line">  <a class="code" href="classDGtal_1_1DigitalPlanePredicate.html">DigitalPlane</a> plane(n, 0, n.norm1());</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Instantiation: estimator(startingPoint, initialFrame, predicate) where</span></div>
<div class="line">  <span class="comment">// (startingPoint, initialFrame) describes the initial tetrahedron.</span></div>
<div class="line">  <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> o(0, 0, 0);</div>
<div class="line">  std::array&lt;Point, 3&gt; m = { <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(1, 0, 0), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0, 1, 0), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0, 0, 1) };</div>
<div class="line">  <a class="code" href="examplePlaneProbingParallelepipedEstimator_8cpp.html#acf36ecb2b183354828ddd0b48821b752">Estimator</a> estimator(o, m, plane);</div>
<div class="ttc" id="aclassDGtal_1_1DigitalPlanePredicate_html"><div class="ttname"><a href="classDGtal_1_1DigitalPlanePredicate.html">DGtal::DigitalPlanePredicate</a></div><div class="ttdoc">Aim: Representing digital planes, which are digitizations of Euclidean planes, as point predicates.</div><div class="ttdef"><b>Definition:</b> <a href="DigitalPlanePredicate_8h_source.html#l00072">DigitalPlanePredicate.h:73</a></div></div>
<div class="ttc" id="aexamplePlaneProbingParallelepipedEstimator_8cpp_html_acf36ecb2b183354828ddd0b48821b752"><div class="ttname"><a href="examplePlaneProbingParallelepipedEstimator_8cpp.html#acf36ecb2b183354828ddd0b48821b752">Estimator</a></div><div class="ttdeci">PlaneProbingParallelepipedEstimator&lt; DigitalPlane, ProbingMode::R1 &gt; Estimator</div><div class="ttdef"><b>Definition:</b> <a href="examplePlaneProbingParallelepipedEstimator_8cpp_source.html#l00046">examplePlaneProbingParallelepipedEstimator.cpp:46</a></div></div>
<div class="ttc" id="atestClone2_8cpp_html_a15e9592ccc512dc691b46185e6814758"><div class="ttname"><a href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a></div><div class="ttdeci">MyPointD Point</div><div class="ttdef"><b>Definition:</b> <a href="testClone2_8cpp_source.html#l00383">testClone2.cpp:383</a></div></div>
<div class="ttc" id="atestCombinDSS_8cpp_html_a609ee1808a3b4f883fb28df65e9a2ed6"><div class="ttname"><a href="testCombinDSS_8cpp.html#a609ee1808a3b4f883fb28df65e9a2ed6">Vector</a></div><div class="ttdeci">FreemanChain&lt; int &gt;::Vector Vector</div><div class="ttdef"><b>Definition:</b> <a href="testCombinDSS_8cpp_source.html#l00060">testCombinDSS.cpp:60</a></div></div>
</div><!-- fragment --><p> And to use it: </p><div class="fragment"><div class="line">  <span class="keywordtype">int</span> it = 0;</div>
<div class="line">  <span class="keywordflow">while</span> (estimator.advance().first) {</div>
<div class="line">      it++;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// You can examine the current configuration of the H-neighborhood, using PlaneProbingTetrahedronEstimator::hexagonState</span></div>
<div class="line">      <span class="keyword">auto</span> state = estimator.hexagonState();</div>
<div class="line">      <span class="keywordflow">if</span> (state == Estimator::Neighborhood::HexagonState::Planar) {</div>
<div class="line">          std::cout &lt;&lt; <span class="stringliteral">&quot;Planar&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (state == Estimator::Neighborhood::HexagonState::Empty) {</div>
<div class="line">          std::cout &lt;&lt; <span class="stringliteral">&quot;Empty&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (state == Estimator::Neighborhood::HexagonState::NonPlanar) {</div>
<div class="line">          std::cout &lt;&lt; <span class="stringliteral">&quot;NonPlanar&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (state == Estimator::Neighborhood::HexagonState::NonConvex) {</div>
<div class="line">          std::cout &lt;&lt; <span class="stringliteral">&quot;NonConvex&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Here, we display the current frame (the vectors m_k) and the current estimation</span></div>
<div class="line">      std::clog &lt;&lt; <span class="stringliteral">&quot;it = &quot;</span> &lt;&lt; it &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">          &lt;&lt; estimator.m(0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; estimator.m(1) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; estimator.m(2) &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">          &lt;&lt; estimator.getNormal() &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// This loop can also be reduced to:</span></div>
<div class="line">  <span class="comment">// Point n = estimator.compute()</span></div>
</div><!-- fragment --><p> The common services shared by plane-probing estimators are the following:</p><ul>
<li><a class="el" href="classDGtal_1_1PlaneProbingTetrahedronEstimator.html#a30504e8a0b0644bf5172516735f35817">PlaneProbingTetrahedronEstimator::m</a> returns the three vectors \( (m_k)_{0 \leq k \leq 2} \) defining the tetrahedron.</li>
<li><a class="el" href="classDGtal_1_1PlaneProbingTetrahedronEstimator.html#aa7ec084b387d7f1cf0a4949a9ce0bb5d">PlaneProbingTetrahedronEstimator::q</a> returns the fixed point \( q \).</li>
<li><a class="el" href="classDGtal_1_1PlaneProbingTetrahedronEstimator.html#a572c512d154653de052d77267f1fac37">PlaneProbingTetrahedronEstimator::getOrigin</a> returns the base point of the frame \( q - (m_0 + m_1 + m_2) \).</li>
<li><a class="el" href="classDGtal_1_1PlaneProbingTetrahedronEstimator.html#adc4e58e96bbe3082ce116f9a37b39627">PlaneProbingTetrahedronEstimator::vertices</a> returns the three vertices \( (q - m_k)_{0 \leq k \leq 2} \).</li>
<li><a class="el" href="classDGtal_1_1PlaneProbingTetrahedronEstimator.html#a424a41ce3158aa2fa9485ab27799f62e">PlaneProbingTetrahedronEstimator::hexagonState</a> returns the current configuration of the H-neighborhood.</li>
</ul>
<p>Probing services:</p><ul>
<li><a class="el" href="classDGtal_1_1PlaneProbingTetrahedronEstimator.html#aa83bad21bbf69d0367957066b4a4fc22">PlaneProbingTetrahedronEstimator::advance</a> does one step of the estimation.</li>
<li><a class="el" href="classDGtal_1_1PlaneProbingTetrahedronEstimator.html#af3a6202006dcb86155e5af7000211c1c">PlaneProbingTetrahedronEstimator::compute</a> repeatedly calls advance until a final configuration is found.</li>
<li><a class="el" href="classDGtal_1_1PlaneProbingTetrahedronEstimator.html#a82ff7bf0550a40ae70ee8855c72ddc05">PlaneProbingTetrahedronEstimator::getBasis</a> returns the two shortest edges of the base triangle.</li>
<li><a class="el" href="classDGtal_1_1PlaneProbingTetrahedronEstimator.html#a0f4865449776d13b05e56a78d0df849c">PlaneProbingTetrahedronEstimator::isReduced</a> tells whether the vectors returned by getBasis form a reduced basis or not.</li>
<li><a class="el" href="classDGtal_1_1PlaneProbingTetrahedronEstimator.html#a6f6dfe2ceadf9639bf4a44d05b38d27f">PlaneProbingTetrahedronEstimator::getNormal</a> returns the current normal vector.</li>
</ul>
<p>Services specific to <a class="el" href="classDGtal_1_1PlaneProbingParallelepipedEstimator.html">PlaneProbingParallelepipedEstimator</a> :</p><ul>
<li><a class="el" href="classDGtal_1_1PlaneProbingParallelepipedEstimator.html#abd7fcea1b4507d4a194e669383f05ddc">PlaneProbingParallelepipedEstimator::getState</a> returns the number of points that are inside the digital set according to <b>InPlane</b>.</li>
<li><a class="el" href="classDGtal_1_1PlaneProbingParallelepipedEstimator.html#a027731db38c4261c65650392a687efdf">PlaneProbingParallelepipedEstimator::isSeparating</a> returns a boolean testing whether the current parallelepiped is separating or not.</li>
<li><a class="el" href="classDGtal_1_1PlaneProbingParallelepipedEstimator.html#a3a41c448a59c374b98f198fbec460abd">PlaneProbingParallelepipedEstimator::isInReverseState</a> returns a boolean saying whether the current parallelepiped is in a reverse state or not.</li>
</ul>
<h2><a class="anchor" id="subsectPlaneProbing22"></a>
On a digital surface</h2>
<p>The <a class="el" href="classDGtal_1_1PlaneProbingDigitalSurfaceLocalEstimator.html" title="Aim: Adapt a plane-probing estimator on a digital surface to estimate normal vectors.">PlaneProbingDigitalSurfaceLocalEstimator</a> adapter can use any plane-probing estimator class to estimate normals on a digital surface. It is a model of <a class="el" href="structDGtal_1_1concepts_1_1CSurfelLocalEstimator.html" title="Aim: This concept describes an object that can process a range of surfels (that are supposed to belon...">concepts::CSurfelLocalEstimator</a> and <a class="el" href="structDGtal_1_1concepts_1_1CDigitalSurfaceLocalEstimator.html" title="Aim: This concept describes an object that can process a range over some generic digital surface so a...">concepts::CDigitalSurfaceLocalEstimator</a>.</p>
<p>The definition and instantiation is done as follows: </p><div class="fragment"><div class="line">    <span class="keyword">using</span> SurfacePredicate = DigitalSurfacePredicate&lt;Surface&gt;;</div>
<div class="line">    <span class="keyword">using</span> ProbingAlgorithm = PlaneProbingParallelepipedEstimator&lt;SurfacePredicate, ProbingMode::R1&gt;;</div>
<div class="line">    <span class="comment">// The general form is PlaneProbingDigitalSurfaceLocalEstimator&lt;SurfaceType, ProbingAlgorithm&gt;</span></div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="examplePlaneProbingParallelepipedEstimator_8cpp.html#acf36ecb2b183354828ddd0b48821b752">Estimator</a>        = PlaneProbingDigitalSurfaceLocalEstimator&lt;Surface, ProbingAlgorithm&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Parameters of the estimator:</span></div>
<div class="line">    <span class="comment">// - the probing factory</span></div>
<div class="line">    Estimator::ProbingFactory probingFactory = [&amp;bound](<span class="keyword">const</span> Estimator::ProbingFrame&amp; frame, <span class="keyword">const</span> SurfacePredicate&amp; surfacePredicate) {</div>
<div class="line">        <span class="comment">// If the base estimator is a PlaneProbingTetrahedronEstimator</span></div>
<div class="line">        <span class="comment">// return new ProbingAlgorithm(frame.p, { frame.b1, frame.b2, frame.normal }, surfacePredicate);</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// For a PlaneProbingParallelepipedEstimator</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">new</span> ProbingAlgorithm(frame.p, { frame.b1, frame.b2, frame.normal }, surfacePredicate, bound);</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// - an optional hashmap of pre-estimations</span></div>
<div class="line">    std::unordered_map&lt;Surfel, RealPoint&gt; preEstimations;</div>
<div class="line">    <span class="comment">// The user can provide the pre-estimation</span></div>
<div class="line">    <span class="comment">// auto preEstimationsVector = SHG3::getCTrivialNormalVectors(surface, surfels, params);</span></div>
<div class="line">    <span class="comment">// for (std::size_t i = 0; i &lt; surfels.size(); ++i)</span></div>
<div class="line">    <span class="comment">// {</span></div>
<div class="line">    <span class="comment">//     preEstimations[surfels[i]] = preEstimationsVector[i];</span></div>
<div class="line">    <span class="comment">// }</span></div>
<div class="line">    <span class="comment">// Or if it is not given, it is implicitly done inside the Estimator::eval function (using the MaximalSegmentSliceEstimation estimator)</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// - a verbosity flag</span></div>
<div class="line">    <span class="keywordtype">bool</span> verbose = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="examplePlaneProbingParallelepipedEstimator_8cpp.html#acf36ecb2b183354828ddd0b48821b752">Estimator</a> estimator(surface, probingFactory, preEstimations, verbose);</div>
<div class="line">    estimator.init(gridstep, surfels.begin(), surfels.end());</div>
</div><!-- fragment --><p> And to use it: </p><div class="fragment"><div class="line">    <span class="comment">// Evaluation on a range of surfels</span></div>
<div class="line">    std::vector&lt;Estimator::Quantity&gt; quantities;</div>
<div class="line">    estimator.eval(surfels.begin(), surfels.end(), std::back_inserter(quantities));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Or on one surfel &#39;s&#39;</span></div>
<div class="line">    <span class="comment">// Estimator::Quantity q = estiamtor.eval(s);</span></div>
</div><!-- fragment --> <dl class="section warning"><dt>Warning</dt><dd>Due to its nature, <a class="el" href="classDGtal_1_1PlaneProbingTetrahedronEstimator.html" title="Aim: A class that locally estimates a normal on a digital set using only a predicate &quot;does a point x ...">PlaneProbingTetrahedronEstimator</a> only returns an <em>approximation</em> of the normal vector on every surfel that is not a reentrant corner. If you want to have a correct estimation on every surfel, use a <a class="el" href="classDGtal_1_1PlaneProbingParallelepipedEstimator.html" title="Aim:">PlaneProbingParallelepipedEstimator</a> instead as the base.</dd></dl>
<p>The parameters that are specific to this estimator are the following:</p><ul>
<li>the <em>probing</em> <em>factory</em> is a function that takes as input a <em>frame</em> (a base point and three vectors) and a reference to the predicate. It should return a dynamically allocated plane-probing estimator from these inputs.</li>
<li><em>pre-estimations</em>. Due to its nature, a plane-probing algorithm only works correctly in the octant determined by the initial frame. If this octant is not correct, then the estimated normal will also be incorrect. That is why we use so-called pre-estimations that must be normal vectors that are cheap to evaluate and that are used to construct a good initial frame. The user can provide such estimations via the third parameter, otherwise it is automatically computed internally using a <a class="el" href="classDGtal_1_1MaximalSegmentSliceEstimation.html" title="Aim:">MaximalSegmentSliceEstimation</a> estimator.</li>
</ul>
<p>Model of <a class="el" href="structDGtal_1_1concepts_1_1CSurfelLocalEstimator.html">concepts::CSurfelLocalEstimator</a> :</p><ul>
<li><a class="el" href="classDGtal_1_1PlaneProbingDigitalSurfaceLocalEstimator.html#a164ce007792d8d9aad197f813b7b7744">PlaneProbingDigitalSurfaceLocalEstimator::init()</a> initializes the estimator.</li>
<li><a class="el" href="classDGtal_1_1PlaneProbingDigitalSurfaceLocalEstimator.html#aba8dff45f98184ce869118714b2fce70">PlaneProbingDigitalSurfaceLocalEstimator::eval()</a> runs the estimator either on a surfel or on a range of surfels.</li>
<li><a class="el" href="classDGtal_1_1PlaneProbingDigitalSurfaceLocalEstimator.html#ade8551ef834b9df5c6bd1af95f849220">PlaneProbingDigitalSurfaceLocalEstimator::h()</a> returns the gridstep.</li>
</ul>
<p>Model of <a class="el" href="structDGtal_1_1concepts_1_1CDigitalSurfaceLocalEstimator.html">concepts::CDigitalSurfaceLocalEstimator</a> :</p><ul>
<li><a class="el" href="classDGtal_1_1PlaneProbingDigitalSurfaceLocalEstimator.html#a9b500f4fbea2b650ff3e95ebe7cdd91f">PlaneProbingDigitalSurfaceLocalEstimator::attach()</a> attaches a digital surface to the estimator.</li>
<li><a class="el" href="classDGtal_1_1PlaneProbingDigitalSurfaceLocalEstimator.html#a69f0ec0702d434b9bcbf995c69ef8287">PlaneProbingDigitalSurfaceLocalEstimator::setParams()</a> sets the parameters of the estimator.</li>
</ul>
<h1><a class="anchor" id="sectPlaneProbing3"></a>
Further notes</h1>
<h2><a class="anchor" id="subsectPlaneProbing31"></a>
Implementing your own candidate set</h2>
<p>To implement your own candidate set, you need to do the following steps:</p><ol type="1">
<li>Make a new class that is a subclass of <a class="el" href="classDGtal_1_1PlaneProbingNeighborhood.html">PlaneProbingNeighborhood</a>,</li>
<li>Overload the <a class="el" href="classDGtal_1_1PlaneProbingNeighborhood.html#a08f18457bbee5140c7f73b0e5480ae79">PlaneProbingNeighborhood::hexagonState</a> (current configuration of the H-neighborhood) and if necessary <a class="el" href="classDGtal_1_1PlaneProbingNeighborhood.html#a5f662b4213a8e5bfb3f21ca8507ccb20">PlaneProbingNeighborhood::getOperation</a> (construct an <a class="el" href="structDGtal_1_1PlaneProbingNeighborhood_1_1UpdateOperation.html">PlaneProbingNeighborhood::UpdateOperation</a> from a point on a ray),</li>
<li>Add a corresponding <a class="el" href="namespaceDGtal.html#abb201440d2d4b97d7078c6716a8d6f49">ProbingMode</a> in <a class="el" href="PlaneProbingTetrahedronEstimator_8h_source.html">PlaneProbingTetrahedronEstimator.h</a>,</li>
<li>Add a selector function at the top of <a class="el" href="PlaneProbingTetrahedronEstimator_8ih_source.html">PlaneProbingTetrahedronEstimator.ih</a>. </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 1 2021 17:06:28 for DGtal by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
