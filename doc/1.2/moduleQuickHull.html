<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: QuickHull algorithm in arbitrary dimension for convex hull and Delaunay cell complex computation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="structDGtal_1_1QuickHull.html" title="Aim: Implements the quickhull algorithm by Barber et al. , a famous arbitrary dimensional convex hull...">QuickHull</a> algorithm in arbitrary dimension for convex hull and Delaunay cell complex computation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#dgtal_quickhull_sec1">The QuickHull convex hull algorithm</a></li>
<li class="level1"><a href="#dgtal_quickhull_sec2">Computing convex hulls and Delaunay cell complex using QuickHull</a><ul><li class="level2"><a href="#dgtal_quickhull_sec21">Convex hull of lattice points</a></li>
<li class="level2"><a href="#dgtal_quickhull_sec22">Convex hull of rational points</a></li>
<li class="level2"><a href="#dgtal_quickhull_sec23">Delaunay cell complex of lattice points (2D example)</a></li>
<li class="level2"><a href="#dgtal_quickhull_sec24">Delaunay cell complex of rational points (2D example)</a></li>
<li class="level2"><a href="#dgtal_quickhull_sec25">Further information stored in QuickHull object</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtal_quickhull_sec3">Using ConvexityHelper for convex hull and Delaunay services</a><ul><li class="level2"><a href="#dgtal_quickhull_sec31">Building a lattice polytope (nD)</a></li>
<li class="level2"><a href="#dgtal_quickhull_sec32">Building the boundary of a lattice convex hull as a surface (3D)</a></li>
<li class="level2"><a href="#dgtal_quickhull_sec33">Building the convex hull cell complex of lattice points (nD)</a></li>
<li class="level2"><a href="#dgtal_quickhull_sec34">Building the Delaunay cell complex of lattice points (nD)</a></li>
<li class="level2"><a href="#dgtal_quickhull_sec35">Building a rational polytope (nD)</a></li>
<li class="level2"><a href="#dgtal_quickhull_sec36">Building the boundary of a rational convex hull as a surface (3D)</a></li>
<li class="level2"><a href="#dgtal_quickhull_sec37">Building the convex hull cell complex of real points (nD)</a></li>
<li class="level2"><a href="#dgtal_quickhull_sec38">Building the Delaunay cell complex of real points (nD)</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>Jacques-Olivier Lachaud</dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.2</dd></dl>
<p>Part of the <a class="el" href="packageGeometry.html">Geometry package</a>.</p>
<p>This part of the manual describes the <a class="el" href="namespaceDGtal.html" title="DGtal is the top-level namespace which contains all DGtal functions and types.">DGtal</a> implementation of the famous "QuickHull" algorithm by Barber et al. <a class="el" href="citelist.html#CITEREF_barber1996">[9]</a> , and how to use it to compute convex hulls and Delaunay convex cell decompositions.</p>
<p>The following programs are related to this documentation: <a class="el" href="exampleLatticeBallQuickHull3D_8cpp.html">exampleLatticeBallQuickHull3D.cpp</a> , <a class="el" href="exampleLatticeBallDelaunay2D_8cpp.html">exampleLatticeBallDelaunay2D.cpp</a> , <a class="el" href="exampleRationalBallQuickHull3D_8cpp.html">exampleRationalBallQuickHull3D.cpp</a> , <a class="el" href="exampleRationalBallDelaunay3D_8cpp_source.html">exampleRationalBallDelaunay3D.cpp</a> , <a class="el" href="exampleQuickHull3D_8cpp.html">exampleQuickHull3D.cpp</a> , <a class="el" href="testQuickHull_8cpp.html">testQuickHull.cpp</a> , <a class="el" href="testConvexityHelper_8cpp.html">testConvexityHelper.cpp</a></p>
<h1><a class="anchor" id="dgtal_quickhull_sec1"></a>
The QuickHull convex hull algorithm</h1>
<p>The objective of the <a class="el" href="structDGtal_1_1QuickHull.html" title="Aim: Implements the quickhull algorithm by Barber et al. , a famous arbitrary dimensional convex hull...">QuickHull</a> algorithm is to compute the convex hull of a set of points <em>V</em> lying in a space of arbitrary dimension <em>d</em> (here <em>d</em> is greater than one). This algorithm has the limitation to only process full dimensional convex hulls, because of the way it is initialized. It maintains and updates a list of facets (which defines the faces of the current polytope) by following these steps:</p>
<ol type="1">
<li>Initialization: an initial <em>d-dimensional</em> simplex is built with \( d+1 \) facets. Furthermore, each remaining point of <em>V</em> is associated to one of these facets if it is <b>above</b> it. Hence, each point of <em>V</em> is either associated to no facet and is thus already inside the current hull, or it is associated to only one facet. Points <b>on</b> each facet and <b>neighbors</b> of facets are computed (easy for a simplex) and all the facets are then queued.</li>
<li>While the queue of facets is not empty, the front facet <em>f</em> is popped.<ul>
<li>ignore it if contains no "above" point(s)</li>
<li>otherwise pick the furthest above point <em>p</em> </li>
<li>find by neighbor adjacencies from <em>f</em> all the facets visible from <em>p</em> (i.e. <em>p</em> is above them)</li>
<li>define the horizon H as the set of ridges R, where a ridge is a pair of two neighbor facets, where the first is visible from <em>^</em>, whilst the second is not.</li>
<li>define the new facets as the ones formed by the umbrella from <em>p</em> to its ridges.</li>
<li>merge possible parallel facets and update "on" points</li>
<li>reassign "above" points of <em>f</em> to these new facets and put them into the queue</li>
</ul>
</li>
<li>The algorithm stops when all current facets have no "above" points.</li>
<li>Optionnaly extract vertices of the convex hull polytopes by determining the "on" points that belong to at least <em>d</em> facets.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>In opposition to the usual <code>qhull</code> implementation, this class uses a kernel that can be chosen in order to provide exact computations. This is the case for lattice points, but also rational points. Computation times are very similar.</dd>
<dd>
In opposition to <code>CGAL 3D convex hull</code> package, or with the arbitrary dimensional <code>CGAL dD Triangulation</code> package, this algorithm does not build a simplicial convex hull. Facets may not be triangles or simplices in higher dimensions. This happens frequently for lattice points, where coplanar and cospherical situations are common.</dd>
<dd>
This version is generally more than twice faster than <code>CGAL</code> function <code>convex_hull_3</code> for the usual CGAL kernels Cartesian and Exact_predicates_inexact_constructions_kernel.</dd>
<dd>
However this implementation is not tailored for incremental dynamic convex hull computations.</dd>
<dd>
Last, the method for computing the Delaunay triangulation by using the convex hull in a higher dimensional space is generally much slower than CGAL method for computing the Delaunay triangulation by point location (5-10 times slower in our experience).</dd></dl>
<h1><a class="anchor" id="dgtal_quickhull_sec2"></a>
Computing convex hulls and Delaunay cell complex using QuickHull</h1>
<p>In order to get a fine control over convex hull computations, you can use class <a class="el" href="structDGtal_1_1QuickHull.html" title="Aim: Implements the quickhull algorithm by Barber et al. , a famous arbitrary dimensional convex hull...">QuickHull</a> directly. It is required to choose a <b>kernel</b> specific to your objective. For now, the available kernels are:</p>
<ul>
<li><a class="el" href="structDGtal_1_1ConvexHullIntegralKernel.html">ConvexHullIntegralKernel</a> : it allows the computation of the convex hull of a range of lattice points in arbitrary dimension.</li>
<li><a class="el" href="structDGtal_1_1ConvexHullRationalKernel.html">ConvexHullRationalKernel</a> : it allows the computation of the convex hull of a range of rational points in arbitrary dimension. The user fixes the precision at kernel instantiation.</li>
<li><a class="el" href="structDGtal_1_1DelaunayIntegralKernel.html">DelaunayIntegralKernel</a> : it allows the computation of the Delaunay cell complex of a range of lattice points in arbitrary dimension.</li>
<li><a class="el" href="structDGtal_1_1DelaunayRationalKernel.html">DelaunayRationalKernel</a> : it allows the computation of the Delaunay cell complex of a range of rational points in arbitrary dimension. The user fixes the precision at kernel instantiation.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>All kernels are parametrized by the dimension of input points, the integer type <code>CoordinateInteger</code> used for representing lattice points, and the integer type <code>InternalInteger</code> used internally in facet and normal computations, as well as above predicates. Depending on your input (amplitude of coordinates and number of dimensions), you must choose consistently in order to get correct results. Default parameters are <a class="el" href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63" title="signed 94-bit integer.">DGtal::int64_t</a> for both.</dd></dl>
<p>As a rule of the thumb, determinant computations raise integers to the power of the dimension, hence the choice of <a class="el" href="namespaceDGtal.html#ad14cde66089fcbdefb20c819562d2a0d" title="Multi-precision integer with GMP implementation.">DGtal::BigInteger</a> (requires WITH_GMP) for <code>InternalInteger</code> is compulsory when \( N^d \ge 4.10^{18} \), for \( N \) the maximum norm of input points and \( d \) the dimension. When <code>CoordinateInteger</code> is <a class="el" href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63" title="signed 94-bit integer.">DGtal::int64_t</a>, then the following table sums up these rules.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">\( d \) dimension   </th><th class="markdownTableHeadNone">max \( N \) for <a class="el" href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63" title="signed 94-bit integer.">DGtal::int64_t</a>   </th><th class="markdownTableHeadNone">max \( N \) for <a class="el" href="namespaceDGtal.html#ad14cde66089fcbdefb20c819562d2a0d" title="Multi-precision integer with GMP implementation.">DGtal::BigInteger</a>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">\( \approx 2e9 \)   </td><td class="markdownTableBodyNone">\( \approx 4e18 \)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">\( \approx 1.5e6 \)   </td><td class="markdownTableBodyNone">\( \approx 4e18 \)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">\( \approx 4e4 \)   </td><td class="markdownTableBodyNone">\( \approx 4e18 \)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">5   </td><td class="markdownTableBodyNone">\( \approx 5e3 \)   </td><td class="markdownTableBodyNone">\( \approx 4e18 \)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">6   </td><td class="markdownTableBodyNone">\( \approx 1.2e3 \)   </td><td class="markdownTableBodyNone">\( \approx 4e18 \)   </td></tr>
</table>
<p>If you use rational kernels with a given precision \( p \), you should divide the above values by \( p \).</p>
<dl class="section note"><dt>Note</dt><dd>With respect to the choice <a class="el" href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63" title="signed 94-bit integer.">DGtal::int64_t</a> for both <code>CoordinateInteger</code> and <code>InternalInteger</code>, expect a 25 times slow-down factor if you use <a class="el" href="namespaceDGtal.html#ad14cde66089fcbdefb20c819562d2a0d" title="Multi-precision integer with GMP implementation.">DGtal::BigInteger</a> for <code>InternalInteger</code>, and a 35 times slow-down factor if you use <a class="el" href="namespaceDGtal.html#ad14cde66089fcbdefb20c819562d2a0d" title="Multi-precision integer with GMP implementation.">DGtal::BigInteger</a> for both <code>CoordinateInteger</code> and <code>InternalInteger</code>.</dd></dl>
<h2><a class="anchor" id="dgtal_quickhull_sec21"></a>
Convex hull of lattice points</h2>
<p>To compute the convex hull of lattice points, you need to include <code><a class="el" href="QuickHull_8h_source.html">QuickHull.h</a></code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/tools/QuickHull.h&quot;</span></div>
</div><!-- fragment --><p> You should then define some typedefs:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> <a class="code" href="structDGtal_1_1ConvexHullIntegralKernel.html">DGtal::ConvexHullIntegralKernel&lt; 3 &gt;</a> Kernel3D;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code" href="structDGtal_1_1QuickHull.html">DGtal::QuickHull&lt; Kernel3D &gt;</a>         QuickHull3D;</div>
<div class="ttc" id="astructDGtal_1_1ConvexHullIntegralKernel_html"><div class="ttname"><a href="structDGtal_1_1ConvexHullIntegralKernel.html">DGtal::ConvexHullIntegralKernel</a></div><div class="ttdoc">Aim: a geometric kernel to compute the convex hull of digital points with integer-only arithmetic.</div><div class="ttdef"><b>Definition:</b> <a href="QuickHullKernels_8h_source.html#l00376">QuickHullKernels.h:378</a></div></div>
<div class="ttc" id="astructDGtal_1_1QuickHull_html"><div class="ttname"><a href="structDGtal_1_1QuickHull.html">DGtal::QuickHull</a></div><div class="ttdoc">Aim: Implements the quickhull algorithm by Barber et al. , a famous arbitrary dimensional convex hull...</div><div class="ttdef"><b>Definition:</b> <a href="QuickHull_8h_source.html#l00139">QuickHull.h:140</a></div></div>
</div><!-- fragment --><p> Then we assume that <em>V</em> contains a range of lattice 3D points (with either 32 bits or 64 bits precision). You may compute their convex hull (facets and vertices) with (<a class="el" href="structDGtal_1_1QuickHull.html#a0600b38897cc9beb1df378454b9cd75b">QuickHull::setInput</a> and <a class="el" href="structDGtal_1_1QuickHull.html#ae2f105ab38ab215d790773737f45cf0d">QuickHull::computeConvexHull</a>):</p>
<div class="fragment"><div class="line">  QuickHull3D hull;</div>
<div class="line">  hull.setInput( V );</div>
<div class="line">  hull.computeConvexHull();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;#points=&quot;</span>    &lt;&lt; hull.nbPoints()</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; #vertices=&quot;</span> &lt;&lt; hull.nbVertices()</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; #facets=&quot;</span>   &lt;&lt; hull.nbFacets() &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> You may check computation times with (<a class="el" href="structDGtal_1_1QuickHull.html#af1bcfc30b33c996a82ade28a90b60389" title="Timings of the different phases: 0: init, 1: facets, 2: vertices.">QuickHull::timings</a>)</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> total_time = 0;</div>
<div class="line">  std::for_each( hull.timings.cbegin(), hull.timings.cend(),</div>
<div class="line">                 [&amp;total_time] ( <span class="keywordtype">double</span> t ) { total_time += t; } );</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;purge duplicates= &quot;</span> &lt;&lt; round(hull.timings[ 0 ]) &lt;&lt; <span class="stringliteral">&quot; ms.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;init simplex    = &quot;</span> &lt;&lt; round(hull.timings[ 1 ]) &lt;&lt; <span class="stringliteral">&quot; ms.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;quickhull core  = &quot;</span> &lt;&lt; round(hull.timings[ 2 ]) &lt;&lt; <span class="stringliteral">&quot; ms.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;compute vertices= &quot;</span> &lt;&lt; round(hull.timings[ 3 ]) &lt;&lt; <span class="stringliteral">&quot; ms.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;total time      = &quot;</span> &lt;&lt; round(total_time) &lt;&lt; <span class="stringliteral">&quot; ms.&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> You can easily retrieve the vertex positions with <a class="el" href="structDGtal_1_1QuickHull.html#ab504ada81b6b8d3cbec4a79ab8f4f255">QuickHull::getVertexPositions</a> (you can put them in a vector of real or lattice points), and get the consistently oriented vertices for each face with <a class="el" href="structDGtal_1_1QuickHull.html#a6d3026c921bb8f8e542435411dbb1077">QuickHull::getFacetVertices</a>. Below we show how to build a <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a> that represents the convex hull boundary and save it as OBJ file.</p>
<div class="fragment"><div class="line">  std::vector&lt; RealPoint &gt; positions;</div>
<div class="line">  hull.getVertexPositions( positions );</div>
<div class="line">  std::vector&lt; std::vector&lt; std::size_t &gt; &gt; facets;</div>
<div class="line">  hull.getFacetVertices( facets );</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code" href="structDGtal_1_1SurfaceMesh.html">DGtal::SurfaceMesh&lt; RealPoint, RealVector&gt;</a> SMesh;</div>
<div class="line">  SMesh mesh( positions.cbegin(), positions.cend(), facets.cbegin(), facets.cend() );</div>
<div class="ttc" id="astructDGtal_1_1SurfaceMesh_html"><div class="ttname"><a href="structDGtal_1_1SurfaceMesh.html">DGtal::SurfaceMesh</a></div><div class="ttdoc">Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...</div><div class="ttdef"><b>Definition:</b> <a href="SurfaceMesh_8h_source.html#l00091">SurfaceMesh.h:92</a></div></div>
</div><!-- fragment --> <div class="fragment"><div class="line">  std::ofstream out( <span class="stringliteral">&quot;qhull.obj&quot;</span> );</div>
<div class="line">  <a class="code" href="structDGtal_1_1SurfaceMeshWriter.html#a2d786cc76abdacdbabaa75f9518cbf72">DGtal::SurfaceMeshWriter&lt; RealPoint, RealVector &gt;::writeOBJ</a>( out, mesh );</div>
<div class="line">  out.close();</div>
<div class="ttc" id="astructDGtal_1_1SurfaceMeshWriter_html_a2d786cc76abdacdbabaa75f9518cbf72"><div class="ttname"><a href="structDGtal_1_1SurfaceMeshWriter.html#a2d786cc76abdacdbabaa75f9518cbf72">DGtal::SurfaceMeshWriter::writeOBJ</a></div><div class="ttdeci">static bool writeOBJ(std::ostream &amp;output, const SurfaceMesh &amp;smesh)</div></div>
</div><!-- fragment --> <table class="doxtable">
<tr>
<td><div class="image">
<img src="qhull-lattice-ball-12_5-s.png" alt=""/>
<div class="caption">
Convex hull of lattice ball with radius 12.5</div></div>
 </td><td><div class="image">
<img src="qhull-lattice-ball-25-s.png" alt=""/>
<div class="caption">
Convex hull of lattice ball with radius 25</div></div>
 </td><td><div class="image">
<img src="qhull-lattice-ball-50-s.png" alt=""/>
<div class="caption">
Convex hull of lattice ball with radius 50</div></div>
   </td></tr>
</table>
<p>To give an idea of computation times, for 1e7 lattice points randomly chosen in a ball of radius 1000, computations times are as follows on a Macbook pro (processor 2,7 GHz Quad-Core Intel Core i7, memory 16 GB 2133 MHz LPDDR3):</p>
<pre class="fragment">examples/geometry/tools/exampleLatticeBallQuickHull3D 10000000 1000

#points=9990515 #vertices=14183 #facets=28036
purge duplicates= 4221 ms.
init simplex    = 223 ms.
quickhull core  = 3214 ms.
compute vertices= 255 ms.
total time      = 7913 ms.
</pre><dl class="section note"><dt>Note</dt><dd>Half of the time is spent on removing duplicated input points. If you know that your range of points does not contain duplicates, you can specify it to <a class="el" href="structDGtal_1_1QuickHull.html#a0600b38897cc9beb1df378454b9cd75b">QuickHull::setInput</a>.</dd></dl>
<h2><a class="anchor" id="dgtal_quickhull_sec22"></a>
Convex hull of rational points</h2>
<p><a class="el" href="structDGtal_1_1QuickHull.html" title="Aim: Implements the quickhull algorithm by Barber et al. , a famous arbitrary dimensional convex hull...">QuickHull</a> cannot handle exactly "real" points, but can handle rational approximations of such points. The user must specify a precision, the rational denominator, at kernel creation. To compute the convex hull of rational points, you need to include <code><a class="el" href="QuickHull_8h_source.html">QuickHull.h</a></code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/tools/QuickHull.h&quot;</span></div>
</div><!-- fragment --><p> You should then define some typedefs:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> <a class="code" href="structDGtal_1_1ConvexHullRationalKernel.html">DGtal::ConvexHullRationalKernel&lt; 3 &gt;</a> Kernel3D;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code" href="structDGtal_1_1QuickHull.html">DGtal::QuickHull&lt; Kernel3D &gt;</a>         QuickHull3D;</div>
<div class="ttc" id="astructDGtal_1_1ConvexHullRationalKernel_html"><div class="ttname"><a href="structDGtal_1_1ConvexHullRationalKernel.html">DGtal::ConvexHullRationalKernel</a></div><div class="ttdoc">Aim: a geometric kernel to compute the convex hull of floating points with integer-only arithmetic....</div><div class="ttdef"><b>Definition:</b> <a href="QuickHullKernels_8h_source.html#l00658">QuickHullKernels.h:660</a></div></div>
</div><!-- fragment --><p> Then we assume that <em>V</em> contains a range of real 3D points (with double precision). You may compute their approximate convex hull (facets and vertices) with the following lines (<a class="el" href="structDGtal_1_1QuickHull.html#a0600b38897cc9beb1df378454b9cd75b">QuickHull::setInput</a> and <a class="el" href="structDGtal_1_1QuickHull.html#ae2f105ab38ab215d790773737f45cf0d">QuickHull::computeConvexHull</a>):</p>
<div class="fragment"><div class="line">  Kernel3D kernel( precision );</div>
<div class="line">  QuickHull3D hull( kernel );</div>
<div class="line">  hull.setInput( V );</div>
<div class="line">  hull.computeConvexHull();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;#points=&quot;</span>    &lt;&lt; hull.nbPoints()</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; #vertices=&quot;</span> &lt;&lt; hull.nbVertices()</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; #facets=&quot;</span>   &lt;&lt; hull.nbFacets() &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> The <b>precision</b> is the denominator used for representing rational coordinates. Real points with <code>double</code> precision are rounded to these nearest rational coordinates.</p>
<dl class="section note"><dt>Note</dt><dd>Different real points may be rounded to the same rational point.</dd></dl>
<p>You may check computation times with (<a class="el" href="structDGtal_1_1QuickHull.html#af1bcfc30b33c996a82ade28a90b60389" title="Timings of the different phases: 0: init, 1: facets, 2: vertices.">QuickHull::timings</a>)</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> total_time = 0;</div>
<div class="line">  std::for_each( hull.timings.cbegin(), hull.timings.cend(),</div>
<div class="line">                 [&amp;total_time] ( <span class="keywordtype">double</span> t ) { total_time += t; } );</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;purge duplicates= &quot;</span> &lt;&lt; round(hull.timings[ 0 ]) &lt;&lt; <span class="stringliteral">&quot; ms.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;init simplex    = &quot;</span> &lt;&lt; round(hull.timings[ 1 ]) &lt;&lt; <span class="stringliteral">&quot; ms.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;quickhull core  = &quot;</span> &lt;&lt; round(hull.timings[ 2 ]) &lt;&lt; <span class="stringliteral">&quot; ms.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;compute vertices= &quot;</span> &lt;&lt; round(hull.timings[ 3 ]) &lt;&lt; <span class="stringliteral">&quot; ms.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;total time      = &quot;</span> &lt;&lt; round(total_time) &lt;&lt; <span class="stringliteral">&quot; ms.&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> You can easily retrieve the rational vertex positions with <a class="el" href="structDGtal_1_1QuickHull.html#ab504ada81b6b8d3cbec4a79ab8f4f255">QuickHull::getVertexPositions</a> (you can put them in a vector of real points), and get the consistently oriented vertices for each face with <a class="el" href="structDGtal_1_1QuickHull.html#a6d3026c921bb8f8e542435411dbb1077">QuickHull::getFacetVertices</a>. Below we show how to build a <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a> that represents the convex hull boundary and save it as OBJ file.</p>
<div class="fragment"><div class="line">  std::vector&lt; RealPoint &gt; positions;</div>
<div class="line">  hull.getVertexPositions( positions );</div>
<div class="line">  std::vector&lt; std::vector&lt; std::size_t &gt; &gt; facets;</div>
<div class="line">  hull.getFacetVertices( facets );</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code" href="structDGtal_1_1SurfaceMesh.html">DGtal::SurfaceMesh&lt; RealPoint, RealVector&gt;</a> SMesh;</div>
<div class="line">  SMesh mesh( positions.cbegin(), positions.cend(), facets.cbegin(), facets.cend() );</div>
</div><!-- fragment --> <div class="fragment"><div class="line">  std::ofstream out( <span class="stringliteral">&quot;qhull.obj&quot;</span> );</div>
<div class="line">  <a class="code" href="structDGtal_1_1SurfaceMeshWriter.html#a2d786cc76abdacdbabaa75f9518cbf72">DGtal::SurfaceMeshWriter&lt; RealPoint, RealVector &gt;::writeOBJ</a>( out, mesh );</div>
<div class="line">  out.close();</div>
</div><!-- fragment --> <table class="doxtable">
<tr>
<td><div class="image">
<img src="qhull-rational-ball-10_5-p1-s.png" alt=""/>
<div class="caption">
Convex hull of rational ball with radius 10.5 with precision 1</div></div>
 </td><td><div class="image">
<img src="qhull-rational-ball-10_5-p2-s.png" alt=""/>
<div class="caption">
Convex hull of rational ball with radius 10.5 with precision 2</div></div>
 </td><td><div class="image">
<img src="qhull-rational-ball-10_5-p4-s.png" alt=""/>
<div class="caption">
Convex hull of rational ball with radius 10.5 with precision 4</div></div>
   </td></tr>
<tr>
<td><div class="image">
<img src="qhull-rational-ball-10_5-p16-s.png" alt=""/>
<div class="caption">
Convex hull of rational ball with radius 10.5 with precision 16</div></div>
 </td><td><div class="image">
<img src="qhull-rational-ball-10_5-p128-s.png" alt=""/>
<div class="caption">
Convex hull of rational ball with radius 10.5 with precision 128</div></div>
 </td><td><div class="image">
<img src="qhull-rational-ball-10_5-p1024-s.png" alt=""/>
<div class="caption">
Convex hull of rational ball with radius 10.5 with precision 1024</div></div>
  <p class="endtd"></p>
</td></tr>
</table>
<p>To give an idea of computation times, for 1e7 real points randomly chosen in a ball of radius 1000, computations times are as follows on a Macbook pro (processor 2,7 GHz Quad-Core Intel Core i7, memory 16 GB 2133 MHz LPDDR3), for a precision of 1024:</p>
<pre class="fragment">examples/geometry/tools/exampleRationalBallQuickHull3D 10000000 1000 1024

#points=10000000 #vertices=14267 #facets=28503
purge duplicates= 4049 ms.
init simplex    = 322 ms.
quickhull core  = 3271 ms.
compute vertices= 239 ms.
total time      = 7882 ms.
</pre><dl class="section note"><dt>Note</dt><dd>Half of the time is spent on removing duplicated input points. If you know that your range of points does not contain duplicates, you can specify it to <a class="el" href="structDGtal_1_1QuickHull.html#a0600b38897cc9beb1df378454b9cd75b">QuickHull::setInput</a>.</dd>
<dd>
If you choose a too big precision, integer computations required by convex hull computations might overflow. You may consider using <a class="el" href="namespaceDGtal.html#ad14cde66089fcbdefb20c819562d2a0d" title="Multi-precision integer with GMP implementation.">DGtal::BigInteger</a> at least for the internal integer representation.</dd></dl>
<h2><a class="anchor" id="dgtal_quickhull_sec23"></a>
Delaunay cell complex of lattice points (2D example)</h2>
<p>Computing the Delaunay complex of lattice points is very similar to computing its convex hull. You should just use the appropriate kernel as follows:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> <a class="code" href="structDGtal_1_1DelaunayIntegralKernel.html">DGtal::DelaunayIntegralKernel&lt; 2 &gt;</a> Kernel2D;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code" href="structDGtal_1_1QuickHull.html">DGtal::QuickHull&lt; Kernel2D &gt;</a>       Delaunay2D;</div>
<div class="ttc" id="astructDGtal_1_1DelaunayIntegralKernel_html"><div class="ttname"><a href="structDGtal_1_1DelaunayIntegralKernel.html">DGtal::DelaunayIntegralKernel</a></div><div class="ttdoc">Aim: a geometric kernel to compute the Delaunay triangulation of digital points with integer-only ari...</div><div class="ttdef"><b>Definition:</b> <a href="QuickHullKernels_8h_source.html#l00508">QuickHullKernels.h:510</a></div></div>
</div><!-- fragment --><p> Then we assume that <em>V</em> contains a range of lattice 3D points (with either 32 bits or 64 bits precision). You may compute their Delaunay complex hull (facets and vertices) with (<a class="el" href="structDGtal_1_1QuickHull.html#a0600b38897cc9beb1df378454b9cd75b">QuickHull::setInput</a> and <a class="el" href="structDGtal_1_1QuickHull.html#ae2f105ab38ab215d790773737f45cf0d">QuickHull::computeConvexHull</a>):</p>
<div class="fragment"><div class="line">  Delaunay2D hull;</div>
<div class="line">  hull.setInput( V );</div>
<div class="line">  hull.computeConvexHull();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;#points=&quot;</span>    &lt;&lt; hull.nbPoints()</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; #vertices=&quot;</span> &lt;&lt; hull.nbVertices()</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; #facets=&quot;</span>   &lt;&lt; hull.nbFacets() &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> You can easily retrieve the vertex positions with <a class="el" href="structDGtal_1_1QuickHull.html#ab504ada81b6b8d3cbec4a79ab8f4f255">QuickHull::getVertexPositions</a> (you can put them in a vector of real or lattice points), and get the consistently oriented vertices for each <b>cell</b> with <a class="el" href="structDGtal_1_1QuickHull.html#a6d3026c921bb8f8e542435411dbb1077">QuickHull::getFacetVertices</a>.</p>
<p>In opposition with convex hull computation, facets here designate the d-dimensional Delaunay cells (here d=2). You also have finite facets (the ones within the convex hull) and infinite facets (the ones of the furthest site Delaunay decomposition). Below we show how to build a <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a> that represents the finite Delaunay cells and save it as OBJ file.</p>
<div class="fragment"><div class="line">  std::vector&lt; RealPoint &gt; positions;</div>
<div class="line">  hull.getVertexPositions( positions );</div>
<div class="line">  std::vector&lt; std::vector&lt; std::size_t &gt; &gt; facets;</div>
<div class="line">  hull.getFacetVertices( facets );</div>
<div class="line">  <span class="comment">// Finite facets precede infinite facets =&gt; keep only finite facets</span></div>
<div class="line">  facets.resize( hull.nbFiniteFacets() ); </div>
<div class="line">  <span class="comment">// To viusalize the result, we build a surface mesh in R3 lying in</span></div>
<div class="line">  <span class="comment">// the plane z=0 and composed of the Delaunay cells.</span></div>
<div class="line">  <span class="keyword">typedef</span> <a class="code" href="classDGtal_1_1SpaceND.html">DGtal::SpaceND&lt; 3, int &gt;</a> <a class="code" href="namespaceDGtal_1_1Z3i.html#a53d22fc69530a513baf89080684d8158">Z3</a>;</div>
<div class="line">  std::vector&lt; Z3::RealPoint &gt; positions3d;</div>
<div class="line">  <span class="keywordflow">for</span> ( <span class="keyword">auto</span> p : positions )</div>
<div class="line">    positions3d.push_back( <a class="code" href="testAstroid2D_8cpp.html#ac914bb734ccb5a7c569747c1e699c1aa">Z3::RealPoint</a>( p[ 0 ], p[ 1 ], 0.0  ) );</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code" href="structDGtal_1_1SurfaceMesh.html">DGtal::SurfaceMesh&lt; Z3::RealPoint, Z3::RealVector&gt;</a> SMesh;</div>
<div class="line">  SMesh mesh( positions3d.cbegin(), positions3d.cend(),</div>
<div class="line">              facets.cbegin(), facets.cend() );</div>
<div class="ttc" id="aclassDGtal_1_1SpaceND_html"><div class="ttname"><a href="classDGtal_1_1SpaceND.html">DGtal::SpaceND</a></div><div class="ttdef"><b>Definition:</b> <a href="SpaceND_8h_source.html#l00095">SpaceND.h:96</a></div></div>
<div class="ttc" id="anamespaceDGtal_1_1Z3i_html_a53d22fc69530a513baf89080684d8158"><div class="ttname"><a href="namespaceDGtal_1_1Z3i.html#a53d22fc69530a513baf89080684d8158">DGtal::Z3i::Z3</a></div><div class="ttdeci">Space Z3</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00145">StdDefs.h:145</a></div></div>
<div class="ttc" id="atestAstroid2D_8cpp_html_ac914bb734ccb5a7c569747c1e699c1aa"><div class="ttname"><a href="testAstroid2D_8cpp.html#ac914bb734ccb5a7c569747c1e699c1aa">RealPoint</a></div><div class="ttdeci">Z2i::RealPoint RealPoint</div><div class="ttdef"><b>Definition:</b> <a href="testAstroid2D_8cpp_source.html#l00046">testAstroid2D.cpp:46</a></div></div>
</div><!-- fragment --> <div class="fragment"><div class="line">  std::ofstream out( <span class="stringliteral">&quot;delaunay.obj&quot;</span> );</div>
<div class="line">  <a class="code" href="structDGtal_1_1SurfaceMeshWriter.html#a2d786cc76abdacdbabaa75f9518cbf72">DGtal::SurfaceMeshWriter&lt; Z3::RealPoint, Z3::RealVector &gt;::writeOBJ</a>( out, mesh );</div>
<div class="line">  out.close();</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>If you wish to visit the infinite facets, you may start from facet numbered <code>hull.nbFiniteFacets()</code>.</dd></dl>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="qhull-delaunay2d-ball-20-100.png" alt=""/>
<div class="caption">
Delaunay cell decomposition of 100 randomly chosen points in a lattice ball with radius 20</div></div>
 </td><td><div class="image">
<img src="qhull-delaunay2d-ball-20-1000.png" alt=""/>
<div class="caption">
Delaunay cell decomposition of 1000 randomly chosen points in a lattice ball with radius 20</div></div>
   </td></tr>
</table>
<p>To give an idea of computation times, for 1e6 lattice points randomly chosen in a ball of radius 1000, computations times are as follows on a Macbook pro (processor 2,7 GHz Quad-Core Intel Core i7, memory 16 GB 2133 MHz LPDDR3):</p>
<pre class="fragment">examples/geometry/tools/exampleLatticeBallDelaunay2D 1000000 1000

#points=856202 #vertices=856202 #facets=1459906
purge duplicates= 284 ms.
init simplex    = 15 ms.
quickhull core  = 19316 ms.
compute vertices= 1109 ms.
total time      = 20723 ms.
</pre><h2><a class="anchor" id="dgtal_quickhull_sec24"></a>
Delaunay cell complex of rational points (2D example)</h2>
<p>It is completely similar with the previous example, just replace the kernel by <a class="el" href="structDGtal_1_1DelaunayRationalKernel.html" title="Aim: a geometric kernel to compute the Delaunay triangulation of a range of floating points with inte...">DelaunayRationalKernel</a> and specify a precision at kernel instantiation.</p>
<h2><a class="anchor" id="dgtal_quickhull_sec25"></a>
Further information stored in QuickHull object</h2>
<p>A number of public data is stored in object <a class="el" href="structDGtal_1_1QuickHull.html" title="Aim: Implements the quickhull algorithm by Barber et al. , a famous arbitrary dimensional convex hull...">QuickHull</a> and is meaningfull after a convex hull computation:</p>
<ul>
<li><a class="el" href="structDGtal_1_1QuickHull.html#a7f8778c9148e02e260b689812f99954b">QuickHull::input2comp</a> the surjective mapping giving for each input point index its index in the point range processed by quick hull</li>
<li><a class="el" href="structDGtal_1_1QuickHull.html#aeff6679f4662c340463c8dfce191af6e">QuickHull::comp2input</a> the injective mapping giving for each processed point index its index in the input point range.</li>
<li><a class="el" href="structDGtal_1_1QuickHull.html#ad3380efed13370da111d6a7ee501dc00" title="point index -&gt; vertex index (or UNASSIGNED)">QuickHull::p2v</a> the map giving for each processed point index its index in the range of vertices (or UNASSIGNED if it is not an index)</li>
<li><a class="el" href="structDGtal_1_1QuickHull.html#a550cdf8a850e07cec4aa8fa8bc390a4a" title="vertex index -&gt; point index">QuickHull::v2p</a> the map giving for each vertex index its index in the range of processed points.</li>
</ul>
<p>To sum up, the maps are as follows and give indices in respective arrays:</p>
<pre class="fragment">              input2comp                        p2v
input points ------------&gt; processed points ----------&gt; convex hull vertices
(user given)               (no duplicates)                 (output)

              comp2input                        v2p
input points &lt;------------ processed points &lt;---------- convex hull vertices
(user given)               (no duplicates)                 (output)</pre><p><a class="el" href="structDGtal_1_1QuickHull.html" title="Aim: Implements the quickhull algorithm by Barber et al. , a famous arbitrary dimensional convex hull...">QuickHull</a>:timings stores also the respective times taken by each step of the computation (see examples).</p>
<h1><a class="anchor" id="dgtal_quickhull_sec3"></a>
Using ConvexityHelper for convex hull and Delaunay services</h1>
<p>Class <a class="el" href="structDGtal_1_1ConvexityHelper.html" title="Aim: Provides a set of functions to facilitate the computation of convex hulls and polytopes,...">ConvexityHelper</a> offers several functions that makes easier the computation of convex hull or Delaunay complex (of course with a little bit less flexibility than using <a class="el" href="structDGtal_1_1QuickHull.html" title="Aim: Implements the quickhull algorithm by Barber et al. , a famous arbitrary dimensional convex hull...">QuickHull</a> directly).</p>
<h2><a class="anchor" id="dgtal_quickhull_sec31"></a>
Building a lattice polytope (nD)</h2>
<p>Building a lattice polytope in nD just requires a call to <a class="el" href="structDGtal_1_1ConvexityHelper.html#a96700dca021436562039540b8281d722">ConvexityHelper::computeLatticePolytope</a>.</p>
<div class="fragment"><div class="line">std::vector&lt;Z2i::Point&gt; V = { <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,0), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(-4,-1), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(-3,5), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(7,3), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(5, -2) };</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> P = <a class="code" href="structDGtal_1_1ConvexityHelper.html#a96700dca021436562039540b8281d722">ConvexityHelper&lt; 2 &gt;::computeLatticePolytope</a>( V );</div>
<div class="ttc" id="astructDGtal_1_1ConvexityHelper_html_a96700dca021436562039540b8281d722"><div class="ttname"><a href="structDGtal_1_1ConvexityHelper.html#a96700dca021436562039540b8281d722">DGtal::ConvexityHelper::computeLatticePolytope</a></div><div class="ttdeci">static LatticePolytope computeLatticePolytope(const std::vector&lt; Point &gt; &amp;input_points, bool remove_duplicates=true, bool make_minkowski_summable=false)</div></div>
<div class="ttc" id="atestClone2_8cpp_html_a15e9592ccc512dc691b46185e6814758"><div class="ttname"><a href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a></div><div class="ttdeci">MyPointD Point</div><div class="ttdef"><b>Definition:</b> <a href="testClone2_8cpp_source.html#l00383">testClone2.cpp:383</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>For dimension up to 3D, you may indicate if you wish your lattice polytope to be Minkowski summable by a cubical grid cell (see <a class="el" href="structDGtal_1_1ConvexityHelper.html#a96700dca021436562039540b8281d722">ConvexityHelper::computeLatticePolytope</a> reference doc).</dd></dl>
<h2><a class="anchor" id="dgtal_quickhull_sec32"></a>
Building the boundary of a lattice convex hull as a surface (3D)</h2>
<p>You may simply use one of the two static methods <a class="el" href="structDGtal_1_1ConvexityHelper.html#a283c4a4c50e59e69e74f6b0ba31fef51">ConvexityHelper::computeConvexHullBoundary</a> to build either a <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a> or a <a class="el" href="classDGtal_1_1PolygonalSurface.html" title="Aim: Represents a polygon mesh, i.e. a 2-dimensional combinatorial surface whose faces are (topologic...">PolygonalSurface</a> that represents the boundary convex hull of a set of 3D lattice points.</p>
<h2><a class="anchor" id="dgtal_quickhull_sec33"></a>
Building the convex hull cell complex of lattice points (nD)</h2>
<p>You can use <a class="el" href="structDGtal_1_1ConvexityHelper.html#a30d289d6bd7b6095a343ee743a9d8ca2">ConvexityHelper::computeConvexHullCellComplex</a> to build a cell complex that represents the convex hull of the given lattice points. This complex has exactly 1 full dimension cell, as many codimension 1 facets as the number of polytope faces, and as many vertices than the points lying on the convex hull boundary. w </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> ConvexityHelper&lt; 3 &gt; Helper;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Helper::Point</a>        <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>;</div>
<div class="line">std::vector&lt;Point&gt; V</div>
<div class="line">= { <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,0,0), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(-2,0,0), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(2,0,0), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,-2,0), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,2,0),</div>
<div class="line">      <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,0,-2), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,0,2) };</div>
<div class="line">ConvexCellComplex&lt; Point &gt; complex;</div>
<div class="line"><span class="keywordtype">bool</span> ok = Helper::computeConvexHullCellComplex( complex, V );</div>
</div><!-- fragment --><h2><a class="anchor" id="dgtal_quickhull_sec34"></a>
Building the Delaunay cell complex of lattice points (nD)</h2>
<p>You may use <a class="el" href="structDGtal_1_1ConvexityHelper.html#a6946256bdb0e0fde723cf5447b0b0e09">ConvexityHelper::computeDelaunayCellComplex</a> to compute the Delaunay cell complex of a range of lattice points.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> ConvexityHelper&lt; 3 &gt; Helper;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Helper::Point</a>        <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>;</div>
<div class="line">std::vector&lt;Point&gt; V</div>
<div class="line">= { <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,0,0), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(-2,0,0), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(2,0,0), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,-2,0), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,2,0),</div>
<div class="line">      <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,0,-2), <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a>(0,0,2) };</div>
<div class="line">ConvexCellComplex&lt; Point &gt; complex;</div>
<div class="line"><span class="keywordtype">bool</span> ok = Helper::computeDelaunayCellComplex( complex, V );</div>
</div><!-- fragment --><p>You can have a look at <a class="el" href="exampleLatticeBallDelaunay3D_8cpp.html">exampleLatticeBallDelaunay3D.cpp</a> for a complete example, with a post-processing that blowns up the 3D cells for visualization.</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="qhull-delaunay3d-ball-5.jpg" alt=""/>
<div class="caption">
Delaunay cell decomposition of randomly chosen points in a 3D lattice ball with radius 5</div></div>
 </td><td><div class="image">
<img src="qhull-delaunay3d-ball-10.jpg" alt=""/>
<div class="caption">
Delaunay cell decomposition of randomly chosen points in a 3D lattice ball with radius 10</div></div>
   </td></tr>
</table>
<h2><a class="anchor" id="dgtal_quickhull_sec35"></a>
Building a rational polytope (nD)</h2>
<p>Building a rational polytope in nD that approximately encloses the given range of real points just requires a call to <a class="el" href="structDGtal_1_1ConvexityHelper.html#a7379862326baa896c4ea93a05f8147bd">ConvexityHelper::computeRationalPolytope</a>. You specify the precision as the denominator used in all rational numbers approximating the real point coordinates.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="exampleQuickHull3D_8cpp.html">exampleQuickHull3D.cpp</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>In opposition with <a class="el" href="structDGtal_1_1ConvexityHelper.html#a283c4a4c50e59e69e74f6b0ba31fef51">ConvexityHelper::computeConvexHullBoundary</a> the precision must be an integer (no smaller than one), but it acts similarly. This is because the built polytope must be a rational polytope (i.e. constraints are rational).</dd></dl>
<h2><a class="anchor" id="dgtal_quickhull_sec36"></a>
Building the boundary of a rational convex hull as a surface (3D)</h2>
<p>You may simply use one of the two static methods <a class="el" href="structDGtal_1_1ConvexityHelper.html#a283c4a4c50e59e69e74f6b0ba31fef51">ConvexityHelper::computeConvexHullBoundary</a> to build either a <a class="el" href="structDGtal_1_1SurfaceMesh.html" title="Aim: Represents an embedded mesh as faces and a list of vertices. Vertices may be shared among faces ...">SurfaceMesh</a> or a <a class="el" href="classDGtal_1_1PolygonalSurface.html" title="Aim: Represents a polygon mesh, i.e. a 2-dimensional combinatorial surface whose faces are (topologic...">PolygonalSurface</a> that represents the boundary convex hull of a set of 3D real points. The precision is given as a scale factor that transforms real coordinates before rounding them at the nearest integer.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="exampleQuickHull3D_8cpp.html">exampleQuickHull3D.cpp</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>In opposition with <a class="el" href="structDGtal_1_1ConvexityHelper.html#a7379862326baa896c4ea93a05f8147bd">ConvexityHelper::computeRationalPolytope</a> the precision might be any double value, but it acts similarly. This is because the build object is a V-representation of a polytope, with floating-point point coordinates.</dd></dl>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="exampleQuickHull3D-bunny-input.jpg" alt=""/>
<div class="caption">
Coarse model of Stanford bunny</div></div>
 </td><td><div class="image">
<img src="exampleQuickHull3D-bunny-both.jpg" alt=""/>
<div class="caption">
Its convex hull with a precision 100</div></div>
   </td></tr>
</table>
<h2><a class="anchor" id="dgtal_quickhull_sec37"></a>
Building the convex hull cell complex of real points (nD)</h2>
<p>You can use <a class="el" href="structDGtal_1_1ConvexityHelper.html#a30d289d6bd7b6095a343ee743a9d8ca2">ConvexityHelper::computeConvexHullCellComplex</a> to build a cell complex that represents the convex hull of the given real points. This complex has exactly 1 full dimension cell, as many codimension 1 facets as the number of polytope faces, and as many vertices than the points lying on the convex hull boundary.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="exampleQuickHull3D_8cpp.html">exampleQuickHull3D.cpp</a></dd></dl>
<h2><a class="anchor" id="dgtal_quickhull_sec38"></a>
Building the Delaunay cell complex of real points (nD)</h2>
<p>You may use <a class="el" href="structDGtal_1_1ConvexityHelper.html#a6946256bdb0e0fde723cf5447b0b0e09">ConvexityHelper::computeDelaunayCellComplex</a> to approximate the Delaunay cell complex of a range of real points, by specifying a precision.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> ConvexityHelper&lt; 3 &gt; Helper;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="testAstroid2D_8cpp.html#ac914bb734ccb5a7c569747c1e699c1aa">Helper::RealPoint</a>    <a class="code" href="testAstroid2D_8cpp.html#ac914bb734ccb5a7c569747c1e699c1aa">RealPoint</a>;</div>
<div class="line">std::vector&lt;RealPoint&gt; V</div>
<div class="line">= { <a class="code" href="testAstroid2D_8cpp.html#ac914bb734ccb5a7c569747c1e699c1aa">RealPoint</a>(0,0,0), <a class="code" href="testAstroid2D_8cpp.html#ac914bb734ccb5a7c569747c1e699c1aa">RealPoint</a>(-2.77,0,0), <a class="code" href="testAstroid2D_8cpp.html#ac914bb734ccb5a7c569747c1e699c1aa">RealPoint</a>(2.77,0,0), </div>
<div class="line">    <a class="code" href="testAstroid2D_8cpp.html#ac914bb734ccb5a7c569747c1e699c1aa">RealPoint</a>(0,-2.77,0), <a class="code" href="testAstroid2D_8cpp.html#ac914bb734ccb5a7c569747c1e699c1aa">RealPoint</a>(0,2.77,0),</div>
<div class="line">    <a class="code" href="testAstroid2D_8cpp.html#ac914bb734ccb5a7c569747c1e699c1aa">RealPoint</a>(0,0,-2.77), <a class="code" href="testAstroid2D_8cpp.html#ac914bb734ccb5a7c569747c1e699c1aa">RealPoint</a>(0,0,2.77) };</div>
<div class="line">ConvexCellComplex&lt; RealPoint &gt; complex;</div>
<div class="line"><span class="keywordtype">bool</span> ok = Helper::computeDelaunayCellComplex( complex, V, 100.0 );</div>
</div><!-- fragment --><p>You can have a look at <a class="el" href="exampleRationalBallDelaunay3D_8cpp_source.html">exampleRationalBallDelaunay3D.cpp</a> for a complete example, with a post-processing that blowns up the 3D cells for visualization.</p>
<div class="image">
<img src="exampleRationalBallDelaunay3D-100.jpg" alt=""/>
<div class="caption">
Delaunay cell decomposition of 100 randomly chosen points in a 3D ball with radius 10, with precision 100 and retraction 0.25</div></div>
 </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 1 2021 17:06:28 for DGtal by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
