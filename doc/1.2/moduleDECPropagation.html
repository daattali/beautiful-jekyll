<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Propagation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Propagation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#sectDECPropagationIntro">Propagation equation</a></li>
<li class="level1"><a href="#sectDECPropagationTime">Temporal resolution with initial condition</a></li>
<li class="level1"><a href="#sectDECPropagationForced">Established permanent regime solution</a></li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>Pierre Gueth</dd></dl>
<h1><a class="anchor" id="sectDECPropagationIntro"></a>
Propagation equation</h1>
<p>Propagation plays a important role in physics as it models a lot a problem ranging from classical oscillators to electromagnetism, relativistic gravitation and quantum mechanics. Here we will study the linear propagation equation of a time dependent scalar wave function \(\psi(x,t)\), modelled as dual 0-form in the DEC framework,</p>
<p class="formulaDsp">
\[ \Delta \psi + \frac{1}{c^2} \frac{\partial^2\psi}{\partial t^2} = \left( \Delta + \frac{1}{c^2} \frac{\partial^2}{\partial t^2} \right) \psi = \rho \]
</p>
<p>where \(c\) is propagation speed inside the medium and \(\rho(x,t)\) is the scalar concentration field that generates waves. The \(+\) differs from the classical physics equation since here we consider \(\Delta\) to have positive eigenvalues, which is the opposite of the definition of the Laplace operator in physics. As DEC handles only spatial dimensions, we will present two classical tricks that can be used to handle the time dependent in many physics problems. For simplicity of notation, we define the propagation operator \(\square\).</p>
<p class="formulaDsp">
\[ \square = \Delta + \frac{1}{c^2} \frac{\partial^2}{\partial t^2} \]
</p>
<h1><a class="anchor" id="sectDECPropagationTime"></a>
Temporal resolution with initial condition</h1>
<p>In this example, we compute the time evolution of a wave given the initial (potentially complex) wave function \(\psi(x,0)=\psi_0(x)\). Snippets are taken from <a class="el" href="examplePropagation_8cpp_source.html">examplePropagation.cpp</a>.</p>
<p>Consider the homogeneous propagation equation, where \(\rho(x,t) = 0\),</p>
<p class="formulaDsp">
\[ \square \psi = 0 \]
</p>
<p>The Laplace operator \(\Delta\) is computed using <a class="el" href="classDGtal_1_1DiscreteExteriorCalculus.html#a424b75e14a8fb0aa7010736e60c360e0">DiscreteExteriorCalculus.laplace</a>. Note that the problem is expressed on the dual structure. A small fraction of <a class="el" href="classDGtal_1_1DiscreteExteriorCalculus.html#a58af09018c1ac24cc7bfb62faeafde30">DiscreteExteriorCalculus.identity</a> is added to ensure a proper definition of \(\Delta\).</p>
<div class="fragment"><div class="line">        <span class="keyword">const</span> Calculus::DualIdentity0 laplace = calculus.laplace&lt;<a class="code" href="namespaceDGtal.html#ab8007ddbb5627666913e18c3b951745dac649578cee4b5463ded5048fdaa47a41">DUAL</a>&gt;() + 1e-8 * calculus.identity&lt;0, <a class="code" href="namespaceDGtal.html#ab8007ddbb5627666913e18c3b951745dac649578cee4b5463ded5048fdaa47a41">DUAL</a>&gt;();</div>
<div class="ttc" id="anamespaceDGtal_html_ab8007ddbb5627666913e18c3b951745dac649578cee4b5463ded5048fdaa47a41"><div class="ttname"><a href="namespaceDGtal.html#ab8007ddbb5627666913e18c3b951745dac649578cee4b5463ded5048fdaa47a41">DGtal::DUAL</a></div><div class="ttdeci">@ DUAL</div><div class="ttdef"><b>Definition:</b> <a href="Duality_8h_source.html#l00063">Duality.h:62</a></div></div>
</div><!-- fragment --><p> Since \(\Delta\) is a positive semi definite real valued Hermitian operator, its eigenvalues are real and positive and its eigenvectors are real.</p>
<p class="formulaDsp">
\[ \Delta \phi_i = k_i^2 \, \phi_i \]
</p>
<p>where \(\phi_i\) are eigenvectors and \(k_i^2\) are corresponding eigenvalues. Eigen pairs can be computed using Eigen::SelfAdjointEigenSolver for small system; \(\phi_i\) is then the ith column of the eigen_vectors matrix. For larger systems, one can use more advance techniques such as band shift invert resolution.</p>
<div class="fragment"><div class="line">        <span class="keyword">typedef</span> Eigen::SelfAdjointEigenSolver&lt;Eigen::MatrixXd&gt; EigenSolverMatrix;</div>
<div class="line">        <span class="keyword">const</span> EigenSolverMatrix eigen_solver(laplace.myContainer);</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> Eigen::VectorXd eigen_values = eigen_solver.eigenvalues();</div>
<div class="line">        <span class="keyword">const</span> Eigen::MatrixXd eigen_vectors = eigen_solver.eigenvectors();</div>
</div><!-- fragment --><p> \(\phi_i\) form an orthonormal basis of the Laplace operator solutions. One can use this property to define \(\psi_i\) an orthonormal basis of solutions of the homogeneous propagation equation (it is easy to check that \(\square \psi_i = 0\)).</p>
<p class="formulaDsp">
\[ \psi_i(x,t) = \phi_k(x) \, e^{j c k_i t} \]
</p>
<p>where \(j\) is the imaginary unit. One can project any solution \(\psi\) of the propagation equation onto this basis. The (potentially complex) coordinates \(p_i\) of \(\psi\) in the \(\psi_i\) basis are</p>
<p class="formulaDsp">
\[ p_i = \left&lt; \psi | \psi_i \right&gt; \]
</p>
<p>where, for all \(t\), \(\left&lt; \bullet | \bullet \right&gt; \) is the inner product between dual 0-forms. In the DEC framework, such a product can be computed as the scalar product between the discrete value vector <a class="el" href="classDGtal_1_1KForm.html#a19e859f462f1d851550465b7fcc2c68d">KForm.myContainer</a>. We can then write \(\psi\) as a linear combination of \(\psi_i\)</p>
<p class="formulaDsp">
\[ \psi = p_i \, \psi_i \]
</p>
<p>where the summation over \(i\) is implicit. Note that for \(t=0\), \(\psi_i(x,0) = \phi_i(x)\). To solve the temporal evolution from \(\psi_0(x)\), all we need to do is to find its initial projections \(p_{0i}\) and let complex exponentials do the their duty to predict future (and past) wave functions.</p>
<p class="formulaDsp">
\[ p_{0i} = \left&lt; \psi_0 | \phi_i \right&gt; \]
</p>
<p>Those inner product are computed by multiplying the initial wave 0-form container with the transposed eigen_vectors matrix.</p>
<div class="fragment"><div class="line">        Eigen::VectorXcd initial_projections = eigen_vectors.transpose() * initial_wave;</div>
</div><!-- fragment --><p> For aesthetic reason, initial projections are filtered to keep only low frequency (high wavelength) components.</p>
<div class="fragment"><div class="line">        <span class="keyword">const</span> Calculus::Scalar lambda_cutoff = 4.5;</div>
<div class="line">        <span class="keyword">const</span> Calculus::Scalar angular_frequency_cutoff = 2*M_PI * cc / lambda_cutoff;</div>
<div class="line">        <span class="keywordtype">int</span> cutted = 0;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> kk=0; kk&lt;initial_projections.rows(); kk++)</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">const</span> Calculus::Scalar angular_frequency = angular_frequencies(kk);</div>
<div class="line">            <span class="keywordflow">if</span> (angular_frequency &lt; angular_frequency_cutoff) <span class="keywordflow">continue</span>;</div>
<div class="line">            initial_projections(kk) = 0;</div>
<div class="line">            cutted ++;</div>
<div class="line">        }</div>
</div><!-- fragment --><p> To get the wave function for any other time \(t\), \(\psi\) is computed as</p>
<p class="formulaDsp">
\[ \psi(x,t) = p_{0i} \, \psi_i(x,t) = p_{0i} \, \phi_i(x) \, e^{j c k_i t} \]
</p>
<p>This translate to the following code where the term \(c k_i\) is precomputed for all times.</p>
<div class="fragment"><div class="line">        <span class="keyword">const</span> Eigen::VectorXd angular_frequencies = cc * eigen_values.array().sqrt();</div>
</div><!-- fragment --><div class="fragment"><div class="line">            <span class="keyword">const</span> Calculus::Scalar time = kk/20.;</div>
<div class="line">            <span class="keyword">const</span> Eigen::VectorXcd current_projections = (angular_frequencies * std::complex&lt;double&gt;(0,time)).array().exp() * initial_projections.array();</div>
<div class="line">            <span class="keyword">const</span> Eigen::VectorXcd current_wave = eigen_vectors * current_projections;</div>
</div><!-- fragment --><p> For real wave functions, knowing the initial wave is not enough the get a unique answer. One would have to know temporal initial wave derivative as well to fully determine the propagation behavior. When one use complex wave functions, the derivative initial conditions are replaced by the phase of the initial wave. By changing the phase field, one would get different behavior. For example if one choose initial wave as described above, one would get a nice uniform propagation of the wave.</p>
<div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> xx=9; xx&lt;13; xx++)</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> yy=13; yy&lt;17; yy++)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> point(xx,yy);</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">Cell</a> cell = calculus.myKSpace.uSpel(point);</div>
<div class="line">        <span class="keyword">const</span> Index index = calculus.getCellIndex(cell);</div>
<div class="line">        initial_wave(index) = 1;</div>
<div class="line">    }</div>
<div class="ttc" id="atestClone2_8cpp_html_a15e9592ccc512dc691b46185e6814758"><div class="ttname"><a href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a></div><div class="ttdeci">MyPointD Point</div><div class="ttdef"><b>Definition:</b> <a href="testClone2_8cpp_source.html#l00383">testClone2.cpp:383</a></div></div>
<div class="ttc" id="atestCubicalComplex_8cpp_html_a9b10591d95c90247f1c7b3bd52853782"><div class="ttname"><a href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">Cell</a></div><div class="ttdeci">KSpace::Cell Cell</div><div class="ttdef"><b>Definition:</b> <a href="testCubicalComplex_8cpp_source.html#l00056">testCubicalComplex.cpp:56</a></div></div>
</div><!-- fragment --><div class="image">
<img src="propagation_time_wave_i.gif" alt=""/>
<div class="caption">
Real part of wave propagating from initial conditions with null phase.</div></div>
<p>If, on the other hand, one starts to mess with the phase on the initial wave and introduce phase variation along y, one would get a directional propagation of the wave along -y.</p>
<div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> xx=9; xx&lt;13; xx++)</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> yy=13; yy&lt;17; yy++)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="testClone2_8cpp.html#a15e9592ccc512dc691b46185e6814758">Point</a> point(xx,yy);</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="testCubicalComplex_8cpp.html#a9b10591d95c90247f1c7b3bd52853782">Cell</a> cell = calculus.myKSpace.uSpel(point);</div>
<div class="line">        <span class="keyword">const</span> Index index = calculus.getCellIndex(cell);</div>
<div class="line">        initial_wave(index) = std::exp(std::complex&lt;double&gt;(0,2*M_PI*(yy-14.5)/8));</div>
<div class="line">    }</div>
</div><!-- fragment --><div class="image">
<img src="propagation_time_wave_ii.gif" alt=""/>
<div class="caption">
Real part of wave propagating from initial conditions with phase variation along y.</div></div>
<h1><a class="anchor" id="sectDECPropagationForced"></a>
Established permanent regime solution</h1>
<p>In this section, we compute the established standing wave generated by a standing concentration field oscillating at a single angular frequency \(\omega_p\). One can define the wavenumber \(k_p = \frac{\omega_p}{c}\) and the wavelength \(\lambda_p = \frac{2 \pi c}{\omega_p}\) equivalently to \(\omega_p\). The established standing wave hypothesis induce a separability of spatial and temporal components: \(\rho(x,t)\) can be expressed as the product between \(\rho_p(x)\), the spatial part, and \(e^{j \omega_p t}\), the temporal part.</p>
<p class="formulaDsp">
\[ \rho(x,t) = \rho_p(x) \, e^{j \omega_p t} = \rho_p(x) \, e^{j c k_p t} = \rho_p(x) \, e^{\frac{2 \pi c t}{\lambda_p}} \]
</p>
<p>The separability applies to \(\psi(x,t)\) too. This linearity of \(\square\) implies that the solution is vibrating at the same frequency as the excitation.</p>
<p class="formulaDsp">
\[ \psi(x,t) = \psi_p(x) \, e^{j c k_p t} \]
</p>
<p>The propagation operator gives a relation between \(\psi_p\) and \(\rho_p\) through the \((\Delta - k_p^2 I)\) operator.</p>
<p class="formulaDsp">
\[ \square \psi = \rho \;\Leftrightarrow\; ( \Delta - k_p^2 \, I ) \, \psi_p = \rho_p \;\Leftrightarrow\; \psi_p = ( \Delta - k_p^2 \, I )^{-1} \, \rho_p \]
</p>
<p>where \(I\) is the identity operator on dual 0-forms and \(( \Delta - k_p^2 I )^{-1}\) is the inverse of \(( \Delta - k_p^2 I )\), always uniquely defined. If \((\phi_i, k_{\Delta i}^2)\) are eigen pairs of \(\Delta\),</p>
<p class="formulaDsp">
\[ \Delta \phi_i = k_{\Delta i}^2 \, \phi_i \]
</p>
<p>it is easy to show that \((\phi_i, \frac{1}{k_{\Delta i}^2 - k_p^2})\) are eigen pairs of \((\Delta - k_p^2 I)^{-1}\). Eigenvectors stay the same, only eigenvalues are changed.</p>
<p class="formulaDsp">
\[ ( \Delta - k_p^2 \, I )^{-1} \phi_i = \frac{1}{k_{\Delta i}^2-k_p^2} \, \phi_i \]
</p>
<p>Using \(p_{pi}\) and \(r_{pi}\), the coordinates of \(\psi_p\) and \(\rho_p\) in the \(\phi_i\) basis, defined as</p>
<p class="formulaDsp">
\[ p_{pi} = \left&lt; \psi_p | \phi_i \right&gt; \; r_{pi} = \left&lt;\rho_p | \phi_i \right&gt; \]
</p>
<p>the solution of the problem is the computed as</p>
<p class="formulaDsp">
\[ p_{pi} = \frac{r_{pi}}{k_{\Delta i}^2 - k_p^2} \]
</p>
<p>This leads to the following definition for \(( \Delta - k_p^2 I )^{-1}\), as concentration_to_wave, in the DEC framework.</p>
<div class="fragment"><div class="line">            <span class="keyword">const</span> Eigen::VectorXd dalembert_eigen_values = (laplace_eigen_values.array() - (2*M_PI/lambda)*(2*M_PI/lambda)).array().inverse();</div>
<div class="line">            <span class="keyword">const</span> Eigen::MatrixXd concentration_to_wave = laplace_eigen_vectors * dalembert_eigen_values.asDiagonal() * laplace_eigen_vectors.transpose();</div>
</div><!-- fragment --><p> The spatial part of the established wave is computed by applying concentration_to_wave to the concentration 0-form container.</p>
<div class="fragment"><div class="line">            Calculus::DualForm0 wave(calculus, concentration_to_wave * concentration.myContainer);</div>
</div><!-- fragment --><p> To illustrate this section, we compute the established standing waves on a disk with a punctual excitation at its center for multiple wavelength \(\lambda_{pk}\) such that a standing wave with \(k\) extremums between center and border is created.</p>
<p class="formulaDsp">
\[ r = k \frac{\lambda_{pk}}{2} + \frac{\lambda_{pk}}{4} \]
</p>
<p>where \(r\) is the radius of the disk. Here we took \(r = 20.75 \mathrm{px}\).</p>
<div class="fragment"><div class="line">            <span class="keyword">const</span> Calculus::Scalar lambda = 4*20.75/(1+2*ll);</div>
</div><!-- fragment --> <div class="image">
<img src="propagation_forced_wave_0.png" alt=""/>
<div class="caption">
Established standing wave for lambda_p0.</div></div>
 <div class="image">
<img src="propagation_forced_wave_1.png" alt=""/>
<div class="caption">
Established standing wave for lambda_p1.</div></div>
 <div class="image">
<img src="propagation_forced_wave_2.png" alt=""/>
<div class="caption">
Established standing wave for lambda_p2.</div></div>
 <div class="image">
<img src="propagation_forced_wave_3.png" alt=""/>
<div class="caption">
Established standing wave for lambda_p3.</div></div>
 <div class="image">
<img src="propagation_forced_wave_4.png" alt=""/>
<div class="caption">
Established standing wave for lambda_p4.</div></div>
 <div class="image">
<img src="propagation_forced_wave_5.png" alt=""/>
<div class="caption">
Established standing wave for lambda_p5.</div></div>
 <div class="image">
<img src="propa_samples.png" alt=""/>
<div class="caption">
Established standing wave profiles along vertical, horizontal and diagonal lines for lambda_pk.</div></div>
 </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 1 2021 17:06:23 for DGtal by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
