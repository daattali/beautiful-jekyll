<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Convex hull and alpha-shape in the plane</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Convex hull and alpha-shape in the plane </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#sectmoduleHull2D1">Convex hull</a><ul><li class="level2"><a href="#subsectmoduleHull2D11">Andrew&#39;s algorithm</a></li>
<li class="level2"><a href="#subsectmoduleHull2D12">Graham&#39;s algorithm</a></li>
<li class="level2"><a href="#subsectmoduleHull2D13">Melkman&#39;s algorithm</a><ul><li class="level3"><a href="#subsectmoduleHull2D131">Constructing a Melkman convex hull from both sides.</a></li>
</ul>
</li>
<li class="level2"><a href="#subsectmoduleHull2D14">Convex hull thickness</a></li>
</ul>
</li>
<li class="level1"><a href="#sectmoduleHull2D2">Alpha-shape</a></li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>Tristan Roussillon, Bertrand Kerautret</dd></dl>
<p>In this part of the manual, we describe how to compute well-known geometric structures such as the convex hull or the alpha-shape of a 2D point set. The proposed implementations provide exact results as long as the underlying geometric predicates are robust (see <a class="el" href="moduleGeometricPredicates.html">Implementation of geometric predicates</a> for more details about geometric predicates).</p>
<p>Related examples are <a class="el" href="exampleConvexHull2D_8cpp.html">exampleConvexHull2D.cpp</a> and <a class="el" href="exampleAlphaShape_8cpp.html">exampleAlphaShape.cpp</a>.</p>
<h1><a class="anchor" id="sectmoduleHull2D1"></a>
Convex hull</h1>
<p>Let us recall that a polygon is a weakly externally visible polygon (WEVP) if for every point on it, there exists an infinite half-line beginning at this point, which does not intersect the polygon at anywhere else.</p>
<p>The two basic procedures <a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#a22b3737b4aeb5443d541b9336116f6d8" title="Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP...">functions::Hull2D::buildHullWithStack</a> (the object having a stack interface is passed by reference) and <a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#a6c864509908d68566f323096fbe7bbcc" title="Procedure that calls Hull2D::buildHullWithStack on a copy of the stack object used to retrieved the h...">functions::Hull2D::buildHullWithAdaptedStack</a> (the object having a stack interface is passed by copy) retrieve the extremal vertices of a WEVP in linear-time. This is an implementation of a well-known method, called Sklansky's scan, Graham's scan or 3-coins algorithm, which has been proven to correctly retrieve the convex hull of any WEVP [Toussaint and Avis, 1982: <a class="el" href="citelist.html#CITEREF_ToussaintAvis1982">[100]</a>]. <br  />
</p>
<p>Three convex hull algorithms use this basic procedure: <br  />
</p><ul>
<li><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#a248898c40cc98e35b6dbcfe944c8adff" title="Procedure that retrieves the vertices of the hull of a set of 2D points given by the range [ itb ,...">functions::Hull2D::andrewConvexHullAlgorithm</a> [Andrew, 1979: <a class="el" href="citelist.html#CITEREF_Andrew1979">[6]</a>]</li>
<li><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#ae9140238e424c6e4121991d410a19011" title="Procedure that retrieves the vertices of the convex hull of a set of 2D points given by the range [ i...">functions::Hull2D::grahamConvexHullAlgorithm</a> [Graham, 1972: <a class="el" href="citelist.html#CITEREF_Graham1972">[51]</a>]</li>
<li><a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html#acab511ebdfea4fa4b0d02901fa5f1464" title="Procedure that retrieves the vertices of the hull of a set of 2D points given by the range [ itb ,...">functions::Hull2D::melkmanConvexHullAlgorithm</a> [Melkman, 1987: <a class="el" href="citelist.html#CITEREF_Melkman1987">[73]</a>]</li>
</ul>
<p>Before calling these algoritms, you must use the <a class="el" href="namespaceDGtal_1_1functions_1_1Hull2D.html" title="Hull2D namespace gathers useful functions to compute and return the convex hull or the alpha-shape of...">functions::Hull2D</a> namespace defined in the file <a class="el" href="Hull2DHelpers_8h_source.html">Hull2DHelpers.h</a>. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/geometry/tools/Hull2DHelpers.h&quot;</span></div>
</div><!-- fragment --><div class="fragment"><div class="line">  <span class="keyword">using namespace </span>functions::Hull2D; </div>
</div><!-- fragment --><p> Moreover, you need to create an orientation functor... <br  />
 </p><div class="fragment"><div class="line">  <span class="keyword">typedef</span> InHalfPlaneBySimple3x3Matrix&lt;Z2i::Point, DGtal::int64_t&gt; <a class="code" href="testConvexHull2DReverse_8cpp.html#a4b95d895f3d8af697b8c550bc833cc9f">Functor</a>;  </div>
<div class="line">  <a class="code" href="testConvexHull2DReverse_8cpp.html#a4b95d895f3d8af697b8c550bc833cc9f">Functor</a> functor; </div>
<div class="ttc" id="atestConvexHull2DReverse_8cpp_html_a4b95d895f3d8af697b8c550bc833cc9f"><div class="ttname"><a href="testConvexHull2DReverse_8cpp.html#a4b95d895f3d8af697b8c550bc833cc9f">Functor</a></div><div class="ttdeci">InHalfPlaneBySimple3x3Matrix&lt; Point, double &gt; Functor</div><div class="ttdef"><b>Definition:</b> <a href="testConvexHull2DReverse_8cpp_source.html#l00053">testConvexHull2DReverse.cpp:51</a></div></div>
</div><!-- fragment --><p>... and, if required, a predicate </p><div class="fragment"><div class="line">    <span class="keyword">typedef</span> PredicateFromOrientationFunctor2&lt;Functor, false, false&gt; StrictPredicate; </div>
<div class="line">    StrictPredicate predicate( functor ); </div>
</div><!-- fragment --><p> See <a class="el" href="moduleGeometricPredicates.html">Implementation of geometric predicates</a> for more details about geometric predicates.</p>
<dl class="section note"><dt>Note</dt><dd>The above functor returns:<ul>
<li>0 for aligned points</li>
<li>a strictly positive value for counter-clockwise oriented points</li>
<li>a strictly negative value for clockwise oriented points</li>
</ul>
</dd>
<dd>
In this example, the predicate is an object that adapts the functor in order to return 'true' for striclty positive values. The last two template arguments means that neither the strictly negative values, nor the null values are accepted.</dd></dl>
<h2><a class="anchor" id="subsectmoduleHull2D11"></a>
Andrew's algorithm</h2>
<p>The more versatile algorithm is Andrew's one [Andrew, 1979: <a class="el" href="citelist.html#CITEREF_Andrew1979">[6]</a>], also known to be the monotone-chain algorithm. First, points are sorted along the horizontal axis. Then, the lower and upper convex hulls are computed by a simple Graham scan from left to right and from right to left. The resulting algorithm is correct because sorting points by increasing x-coordinates (and increasing y-coordinates for a same x-coordinate) produces a WEVP. The overall time complexity is \( O(n\log{(n)}) \) for a 2D point set of size \( n \).</p>
<div class="image">
<img src="AndrewWEVP.png" alt=""/>
<div class="caption">
Sorting step of Andrew's algorithm produces a WEVP</div></div>
<p>  Note that the starting point is depicted in red and that the arrows show the point order.</p>
<p>In order to retrieve the extremal points of a range of points, you may call the procedure andrewConvexHullAlgorithm as follows: <br  />
 </p><div class="fragment"><div class="line">    <a class="code" href="namespaceDGtal_1_1functions_1_1Hull2D.html#a248898c40cc98e35b6dbcfe944c8adff">andrewConvexHullAlgorithm</a>( pointSet.begin(), pointSet.end(), back_inserter( res ), predicate );   </div>
<div class="ttc" id="anamespaceDGtal_1_1functions_1_1Hull2D_html_a248898c40cc98e35b6dbcfe944c8adff"><div class="ttname"><a href="namespaceDGtal_1_1functions_1_1Hull2D.html#a248898c40cc98e35b6dbcfe944c8adff">DGtal::functions::Hull2D::andrewConvexHullAlgorithm</a></div><div class="ttdeci">void andrewConvexHullAlgorithm(const ForwardIterator &amp;itb, const ForwardIterator &amp;ite, OutputIterator res, const Predicate &amp;aPredicate)</div><div class="ttdoc">Procedure that retrieves the vertices of the hull of a set of 2D points given by the range [ itb ,...</div></div>
</div><!-- fragment --><p>Note that in this example the extremal points are pushed to a back insertion sequence called 'res'.</p>
<div class="image">
<img src="ConvexHullCCW.png" alt=""/>
<div class="caption">
Convex hull of the digitization of a disk</div></div>
 <p>You can however change the predicate to accept aligned points and therefore all points lying on the boundary of the convex hull. <br  />
 </p><div class="fragment"><div class="line">    <span class="keyword">typedef</span> PredicateFromOrientationFunctor2&lt;Functor, false, true&gt; LargePredicate; </div>
<div class="line">    LargePredicate predicate( functor ); </div>
</div><!-- fragment --> <div class="image">
<img src="ConvexHullCCWWithPointsOnEdges.png" alt=""/>
<div class="caption">
All points lying on the boundary of the convex hull of the digitization of a disk</div></div>
 <p>You can also change the predicate so that the resulting list of vertices is clockwise-oriented. </p><div class="fragment"><div class="line">    <span class="keyword">typedef</span> PredicateFromOrientationFunctor2&lt;Functor, true, false&gt; StrictPredicate; </div>
<div class="line">    StrictPredicate predicate( functor );</div>
</div><!-- fragment --> <div class="image">
<img src="ConvexHullCW.png" alt=""/>
<div class="caption">
Clockwise-oriented list of extremal points of the digitization of a disk</div></div>
 <h2><a class="anchor" id="subsectmoduleHull2D12"></a>
Graham's algorithm</h2>
<p>Graham's algorithm is another well-known algorithm to compute the convex hull of a 2D point set of size \( n \) in \( O(n\log{(n)}) \) [Graham, 1972: <a class="el" href="citelist.html#CITEREF_Graham1972">[51]</a>]. The method can be coarsely described as follows:</p><ul>
<li>choose a pole and sort the points by increasing angle about the pole</li>
<li>apply a simple Graham's scan on the sorted list of points.</li>
</ul>
<p>We have chosen the point of maximal x-coordinate (and maximal y-coordinate) to be the pole. Hence, the algorithm is correct since sorting the points by increasing angle about such a pole produces again a WEVP.</p>
<div class="image">
<img src="GrahamWEVP.png" alt=""/>
<div class="caption">
Sorting step of Graham's algorithm produces a WEVP</div></div>
 <p>The main advantage of Graham's algorithm over Andrew's one is that only one scan is required instead of two to retrieve the whole convex hull.</p>
<p>You may call the procedure grahamConvexHullAlgorithm as follows: <br  />
 </p><div class="fragment"><div class="line">    <a class="code" href="namespaceDGtal_1_1functions_1_1Hull2D.html#ae9140238e424c6e4121991d410a19011">grahamConvexHullAlgorithm</a>( pointSet.begin(), pointSet.end(), back_inserter( res ), predicate ); </div>
<div class="ttc" id="anamespaceDGtal_1_1functions_1_1Hull2D_html_ae9140238e424c6e4121991d410a19011"><div class="ttname"><a href="namespaceDGtal_1_1functions_1_1Hull2D.html#ae9140238e424c6e4121991d410a19011">DGtal::functions::Hull2D::grahamConvexHullAlgorithm</a></div><div class="ttdeci">void grahamConvexHullAlgorithm(const ForwardIterator &amp;itb, const ForwardIterator &amp;ite, OutputIterator res, const Predicate &amp;aPredicate, PolarComparator &amp;aPolarComparator)</div><div class="ttdoc">Procedure that retrieves the vertices of the convex hull of a set of 2D points given by the range [ i...</div></div>
</div><!-- fragment --> <dl class="section warning"><dt>Warning</dt><dd>You must choose a predicate returning 'true' for counter-clockwise oriented 3-point sets, because the sorting step is done with a counter-clockwise orientation. <br  />
</dd></dl>
<h2><a class="anchor" id="subsectmoduleHull2D13"></a>
Melkman's algorithm</h2>
<p>The two previous algorithms are off-line and compute the convex hull of any set of \( n \) 2D points in \( O(n\log{(n)}) \). <br  />
 Melkman's algorithm is on-line and computes the convex hull of a simple polygonal line, ie. without self-intersection, in linear-time (amortized constant time per update).</p>
<p>Note that Graham's scan, used by the two previous algorithms, runs in linear-time on weakly externally visible polygons, which is a subset of simple polygonal lines. As a consequence, Graham's scan may fail for simple polygonal lines that are not weakly externally visible. <br  />
</p>
<p>In <a class="el" href="exampleConvexHull2D_8cpp.html">exampleConvexHull2D.cpp</a>, you may find a minimal example:</p>
<div class="image">
<img src="SimplePolygonalLine.png" alt=""/>
<div class="caption">
A simple polygonal line that is not weakly externally visible</div></div>
 <p>On such example, Graham's scan fails because the polygonal line is not weakly externally visible. However, Melkman's algorithm produces the right output:</p>
<div class="image">
<img src="SimplePolygonalLineMelkman.png" alt=""/>
<div class="caption">
Output for Melkman's algorithm </div></div>
 <p>Melkman's algorithm works fine because it is based on a double ended queue and it <br  />
 assumes that the input points form a simple polygonal line. Due to this assumption, any new point cannot be located in the cone formed by the first and last edge of the current convex hull (in red in the figure below). As a consequence, it is enough to update the convex hull by a Graham's scan from the front and/or from the back of the deque and it is never required to remove/insert points in the middle of the deque. <br  />
</p>
<div class="image">
<img src="MelkmanHowTo.png" alt=""/>
<div class="caption">
Consequence of the no self-intersection hypothesis</div></div>
 <p>You may use <a class="el" href="classDGtal_1_1MelkmanConvexHull.html" title="Aim: This class implements the on-line algorithm of Melkman for the computation of the convex hull of...">MelkmanConvexHull</a> class as follows: </p><div class="fragment"><div class="line">    <a class="code" href="classDGtal_1_1MelkmanConvexHull.html">DGtal::MelkmanConvexHull&lt;Z2i::Point, Functor&gt;</a> <a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>( functor ); </div>
<div class="line">    <span class="keywordflow">for</span> (std::vector&lt;Z2i::Point&gt;::const_iterator </div>
<div class="line">           it = polygonalLine.begin(), </div>
<div class="line">           itEnd = polygonalLine.end(); </div>
<div class="line">         it != itEnd; ++it)</div>
<div class="line">      <a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add( *it ); </div>
<div class="ttc" id="aclassDGtal_1_1MelkmanConvexHull_html"><div class="ttname"><a href="classDGtal_1_1MelkmanConvexHull.html">DGtal::MelkmanConvexHull</a></div><div class="ttdoc">Aim: This class implements the on-line algorithm of Melkman for the computation of the convex hull of...</div><div class="ttdef"><b>Definition:</b> <a href="MelkmanConvexHull_8h_source.html#l00089">MelkmanConvexHull.h:90</a></div></div>
<div class="ttc" id="atestConvexHull2DReverse_8cpp_html_a3e9b82c8e3bf7352dbd881a33c21aa52"><div class="ttname"><a href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a></div><div class="ttdeci">DGtal::MelkmanConvexHull&lt; Point, Functor &gt; ch</div><div class="ttdef"><b>Definition:</b> <a href="testConvexHull2DReverse_8cpp_source.html#l00054">testConvexHull2DReverse.cpp:54</a></div></div>
</div><!-- fragment --><p> The class <a class="el" href="classDGtal_1_1MelkmanConvexHull.html" title="Aim: This class implements the on-line algorithm of Melkman for the computation of the convex hull of...">MelkmanConvexHull</a> provides an on-line way of computing the convex hull of a sequence of points, which form a simple polygonal line: each time a point is added, the current convex hull is updated accordingly. However, if you are not interested in the on-line feature, you may call the off-line procedure melkmanConvexHullAlgorithm as follows: <br  />
 </p><div class="fragment"><div class="line">    <a class="code" href="namespaceDGtal_1_1functions_1_1Hull2D.html#acab511ebdfea4fa4b0d02901fa5f1464">melkmanConvexHullAlgorithm</a>( polygonalLine.begin(), polygonalLine.end(), back_inserter( res ), functor );   </div>
<div class="ttc" id="anamespaceDGtal_1_1functions_1_1Hull2D_html_acab511ebdfea4fa4b0d02901fa5f1464"><div class="ttname"><a href="namespaceDGtal_1_1functions_1_1Hull2D.html#acab511ebdfea4fa4b0d02901fa5f1464">DGtal::functions::Hull2D::melkmanConvexHullAlgorithm</a></div><div class="ttdeci">void melkmanConvexHullAlgorithm(const ForwardIterator &amp;itb, const ForwardIterator &amp;ite, OutputIterator res, Functor &amp;aFunctor)</div><div class="ttdoc">Procedure that retrieves the vertices of the hull of a set of 2D points given by the range [ itb ,...</div></div>
</div><!-- fragment --> <dl class="section warning"><dt>Warning</dt><dd>The behavior is undefined if the input points do not form a simple polygonal line.</dd></dl>
<h3><a class="anchor" id="subsectmoduleHull2D131"></a>
Constructing a Melkman convex hull from both sides.</h3>
<p>If you want to construction a convex hull by considering the front and back of a contour you will need to use the <a class="el" href="classDGtal_1_1MelkmanConvexHull.html#ae82c6313dfcb17d3f1abd9e18caf26d5">MelkmanConvexHull::reverse()</a> method. For instance, to recover the convex hull of the point P0 of the following figure, you will need to do as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> InHalfPlaneBySimple3x3Matrix&lt;Z2i::RealPoint, double&gt; <a class="code" href="testConvexHull2DReverse_8cpp.html#a4b95d895f3d8af697b8c550bc833cc9f">Functor</a>;</div>
<div class="line"><span class="keyword">typedef</span> MelkmanConvexHull&lt;Z2i::RealPoint, Functor&gt; MelkmanCV;</div>
<div class="line">MelkmanCV <a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>;</div>
<div class="line"><a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(P0);</div>
<div class="line"><a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(P1);</div>
<div class="line"><a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(P2);</div>
<div class="line"><a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.reverse();</div>
<div class="line"><a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(P3);</div>
<div class="line"><a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.reverse();</div>
<div class="line"><a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(P4);</div>
<div class="line"><a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.reverse();</div>
<div class="line"><a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(P5);</div>
<div class="line"><a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.reverse();</div>
<div class="line"><a class="code" href="testConvexHull2DReverse_8cpp.html#a3e9b82c8e3bf7352dbd881a33c21aa52">ch</a>.add(P6);</div>
</div><!-- fragment --><p>Such sequence will produce the correct result given on the image (2) of the following figure.</p>
<div class="image">
<img src="convexHullReverse.png" alt=""/>
<div class="caption">
Illustration of the convex hull result starting from the point P0 and adding alternately the points Pi. (1) shows wrong convex hull obtained without the convex hull reverse, (2) is the correct convex hull obtained by using the reverse() method after each addition of points.</div></div>
 <h2><a class="anchor" id="subsectmoduleHull2D14"></a>
Convex hull thickness</h2>
<p>From a convex hull it can be useful to compute its associated thickness. We propose the implementation of the well known rotating caliper algorithm allowing to compute all the antipodal pairs in linear time [Shamos , 1978: <a class="el" href="citelist.html#CITEREF_Shamos1978">[96]</a>].</p>
<p>Two definitions of thickness can be computed from an iterator on the convex hull. The first one is the vertical/horizontal thickness obtained by projection on the main x-y axis from antipodal pairs. The second one is given from the normal projection on the edge of the same antipodal pairs. The two definitions are illustrated on the following figures:</p>
<div class="image">
<img src="exampleConvexHullHV.png" alt=""/>
<div class="caption">
Example of the definitiion of horizontal/vertical thickness defined from the convex hull antipodal pair ((P,Q), S).</div></div>
 <div class="image">
<img src="exampleConvexHullEucl.png" alt=""/>
<div class="caption">
Example of the definitiion of Euclidean thickness defined from the convex hull antipodal pair ((P,Q), S).</div></div>
 <p>To compute the thickness of a convex hull you have simply to call the computeHullThickness procedure:</p>
<div class="fragment"><div class="line">    <span class="keywordtype">double</span> th = <a class="code" href="namespaceDGtal_1_1functions_1_1Hull2D.html#aa85c48fa77f6284d8d43808576ba474b">DGtal::functions::Hull2D::computeHullThickness</a>(res.begin(), res.end(), <a class="code" href="namespaceDGtal_1_1functions_1_1Hull2D.html#ade3b11c94c4d3736bb8efc7abcc58735a602f83cef2331731bf233abeaf2c0ff6">DGtal::functions::Hull2D::HorizontalVerticalThickness</a>);</div>
<div class="ttc" id="anamespaceDGtal_1_1functions_1_1Hull2D_html_aa85c48fa77f6284d8d43808576ba474b"><div class="ttname"><a href="namespaceDGtal_1_1functions_1_1Hull2D.html#aa85c48fa77f6284d8d43808576ba474b">DGtal::functions::Hull2D::computeHullThickness</a></div><div class="ttdeci">double computeHullThickness(const ForwardIterator &amp;itb, const ForwardIterator &amp;ite, const ThicknessDefinition &amp;def)</div><div class="ttdoc">Procedure to compute the convex hull thickness given from different definitions (Horizontal/vertical ...</div></div>
<div class="ttc" id="anamespaceDGtal_1_1functions_1_1Hull2D_html_ade3b11c94c4d3736bb8efc7abcc58735a602f83cef2331731bf233abeaf2c0ff6"><div class="ttname"><a href="namespaceDGtal_1_1functions_1_1Hull2D.html#ade3b11c94c4d3736bb8efc7abcc58735a602f83cef2331731bf233abeaf2c0ff6">DGtal::functions::Hull2D::HorizontalVerticalThickness</a></div><div class="ttdeci">@ HorizontalVerticalThickness</div><div class="ttdef"><b>Definition:</b> <a href="Hull2DHelpers_8h_source.html#l00078">Hull2DHelpers.h:78</a></div></div>
</div><!-- fragment --><p>To recover the antipodal pairs for which the thickness is minimal you can also use the same method with an antipodal pair:</p>
<div class="fragment"><div class="line">    <a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Z2i::Point</a> antipodalP, antipodalQ, antipodalS;</div>
<div class="line">    th = <a class="code" href="namespaceDGtal_1_1functions_1_1Hull2D.html#aa85c48fa77f6284d8d43808576ba474b">DGtal::functions::Hull2D::computeHullThickness</a>(res.begin(), res.end(), <a class="code" href="namespaceDGtal_1_1functions_1_1Hull2D.html#ade3b11c94c4d3736bb8efc7abcc58735a602f83cef2331731bf233abeaf2c0ff6">DGtal::functions::Hull2D::HorizontalVerticalThickness</a>, antipodalP, antipodalQ, antipodalS);</div>
<div class="ttc" id="anamespaceDGtal_1_1Z2i_html_ac0a04516c81db6f4a583eddda0f64875"><div class="ttname"><a href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">DGtal::Z2i::Point</a></div><div class="ttdeci">Space::Point Point</div><div class="ttdef"><b>Definition:</b> <a href="StdDefs_8h_source.html#l00095">StdDefs.h:95</a></div></div>
</div><!-- fragment --><p> And display the result: </p><div class="fragment"><div class="line">    board.setPenColor(<a class="code" href="classDGtal_1_1Color.html#aa5e8679bd0da49f95d13cd95a17b619b">DGtal::Color::Red</a>);</div>
<div class="line">    board.drawCircle( antipodalS[0], antipodalS[1], 0.2) ;</div>
<div class="line">    board.setPenColor(<a class="code" href="classDGtal_1_1Color.html#abf76f3f60747766c469ceb8e9bbfe68b">DGtal::Color::Blue</a>);</div>
<div class="line">    board.drawCircle(antipodalP[0], antipodalP[1], 0.2);</div>
<div class="line">    board.drawCircle(antipodalQ[0], antipodalQ[1], 0.2);</div>
<div class="line">    board.drawLine(antipodalP[0], antipodalP[1], antipodalQ[0], antipodalQ[1]);</div>
<div class="ttc" id="aclassDGtal_1_1Color_html_aa5e8679bd0da49f95d13cd95a17b619b"><div class="ttname"><a href="classDGtal_1_1Color.html#aa5e8679bd0da49f95d13cd95a17b619b">DGtal::Color::Red</a></div><div class="ttdeci">static const Color Red</div><div class="ttdef"><b>Definition:</b> <a href="Color_8h_source.html#l00392">Color.h:392</a></div></div>
<div class="ttc" id="aclassDGtal_1_1Color_html_abf76f3f60747766c469ceb8e9bbfe68b"><div class="ttname"><a href="classDGtal_1_1Color.html#abf76f3f60747766c469ceb8e9bbfe68b">DGtal::Color::Blue</a></div><div class="ttdeci">static const Color Blue</div><div class="ttdef"><b>Definition:</b> <a href="Color_8h_source.html#l00395">Color.h:395</a></div></div>
</div><!-- fragment --><p>By using the sequence of points of the first example, you will obtain a thickness of 12 with the following antipodal pair:</p>
<div class="image">
<img src="ConvexHullCCWAntiPodal.png" alt=""/>
<div class="caption">
Example of antipodal pair obtained from the computation of the horizontal/vertical thickness. The edge (P, Q) of the antipodal pair is represented in blue and its vertex R is given in red.</div></div>
 <dl class="section warning"><dt>Warning</dt><dd>The convex hull should be oriented in counter clockwise else it will return wrong result.</dd></dl>
<h1><a class="anchor" id="sectmoduleHull2D2"></a>
Alpha-shape</h1>
<p>The alpha-shape of a finite set of points has been introduced in [Edelsbrunner et. al., 1983: <a class="el" href="citelist.html#CITEREF_Edelsbrunner1983">[43]</a>]. This geometric structure is based on the following concept of generalized disk. <br  />
 For an arbitrary real \( \alpha \), a <em>generalized</em> <em>disk</em> of radius \( 1/\alpha \) is defined as</p><ul>
<li>a disk of radius \( 1/\alpha \) if \( \alpha &gt; 0 \)</li>
<li>a complement of the disk of radius \( -1/\alpha \) if \( \alpha &lt; 0 \)</li>
<li>a half-plane if \( \alpha = 0 \)</li>
</ul>
<p>We also define the <em>direct</em> (resp. <em>indirect</em>) generalized disk of radius \( 1/\alpha \) passing by two points \( P \) and \( Q \) as the unique generalized disk of radius \( 1/\alpha \) with \( P, Q \) on its boundary and such that \( P, Q \) and its center are counter-clockwise oriented (resp. clockwise oriented).</p>
<p>The <em>\(\alpha\)-hull</em> of a point set is the intersection of all closed generalized disks of radius \( 1/\alpha \) that contains the point set. A point \( P \) of this point set is <em>\(\alpha\)-extreme</em> if there exists a closed generalized disk of radius \( 1/\alpha \) such that \( P \) lies on its boundary and which contains all the other points. <br  />
 The <em>\(\alpha\)-shape</em> is the straight-line graph whose vertices are the \(\alpha\)-extreme points and whose edges connect any two \(\alpha\)-extreme points such that there exists a closed generalized disk of radius \( 1/\alpha \) with both points on its boundary and which contains all the other points. <br  />
</p>
<p>Any \(\alpha\)-shape of a set of points is a subgraph of either the closest point or the farthest point Delaunay triangulation. Moreover, the set of \(\alpha_1\)-extreme points is a subset of the set of \(\alpha_2\)-extreme points if \(\alpha_1 \geq \alpha_2 \). <br  />
</p>
<p>Various \(\alpha\)-shapes of the digitization of a disk are depicted below for \( \alpha \in \{ -1, -1/\sqrt{5}, -1/5, 0, 1/9, 1/8 \} \).</p>
<div class="image">
<img src="AlphaShapeM1.png" alt=""/>
<div class="caption">
alpha = -1 (8-connected boundary)</div></div>
 <div class="image">
<img src="AlphaShapeMSqrt5.png" alt=""/>
<div class="caption">
alpha = -0.4472 </div></div>
 <div class="image">
<img src="AlphaShapeM5.png" alt=""/>
<div class="caption">
alpha = -0.2 (points lying on the boundary of the convex hull)</div></div>
 <div class="image">
<img src="AlphaShape0.png" alt=""/>
<div class="caption">
alpha = 0 (convex hull)</div></div>
 <div class="image">
<img src="AlphaShapeP9.png" alt=""/>
<div class="caption">
alpha = 0.1111 </div></div>
 <div class="image">
<img src="AlphaShapeP8.png" alt=""/>
<div class="caption">
alpha = 0.125 (points lying on the smallest enclosing circle)</div></div>
 <p>You may observe that:</p><ul>
<li>if \( \alpha = -1 \), we retrieve the 8-connected boundary</li>
<li>if \( \alpha = -\epsilon \) for an arbitrary small \( \epsilon \), we retrieve all the points lying on the boundary of the convex hull</li>
<li>if \( \alpha = 0 \), we retrieve the convex hull vertices.</li>
<li>if the radius of the smallest enclosing circle is denoted by \( R_{min} \), we retrieve all the points lying on the smallest enclosing circle if \( \alpha = 1/R_{min}-\epsilon \) for an arbitrary small \( \epsilon \).</li>
</ul>
<p>Even if the convex hull of a set of points is its \(0\)-shape, the following properties are not true for general \(\alpha\)-shapes, \( \alpha \neq 0 \):</p><ul>
<li>The \(\alpha\)-shape of 3 points always exists and is always connected,</li>
<li>For any 3-point set \( P, Q, R \) in the plane, <br  />
 if \( R \) belongs to the direct generalized disk of radius \( 1/\alpha \) passing by \( P \) and \( Q \) then \( P \) belongs to the direct generalized disk of radius \( 1/\alpha \) passing by \( Q \) and \( R \) and \( Q \) belongs to the direct generalized disk of radius \( 1/\alpha \) passing by \( R \) and \( P \).</li>
</ul>
<p>As a consequence, the current implementation cannot compute the alpha-shape of an arbitrary set of points. Such an algorithm would have required to compute the closest point and farthest point Delaunay triangulation. Though, we provide procedures, based on the 3-coins algorithm, which compute in linear-time the alpha-shape of specific polygons, for which the two above properties remain true: closedGrahamScanFromVertex (the starting point is expected to be extremal) and closedGrahamScanFromAnyPoint (no assumption about the starting point is required).</p>
<p>This class of polygons is the set of simple polygons such that:</p><ul>
<li>The distance between any two consecutive vertices is smaller than \( 2/\alpha \) if \( \alpha &gt; 0 \) or greater than \( -2/\alpha \) if \( \alpha &lt; 0 \). This guarantees that the \(\alpha\)-shape of three consecutive vertices always exists (if \( \alpha &gt; 0 \)) and is always connected (if \( \alpha &lt; 0 \)).</li>
<li>For every set of three consecutive vertices \( P, Q, R \) of the polygon, \( PR \) is the longest side of the triangle \( P, Q, R \).</li>
</ul>
<p>Let us consider a connected and convex digital object such that its 4-connected (resp. 8-connected) boundary is simply 4-connected (resp. 8-connected). It is clear that its 4-connected (resp. 8-connected) boundary belongs to the above class of polygons provided that \( -1 \leq \alpha &lt; 1/R_{min} \) (resp. \( -\sqrt{2}/2 \leq \alpha &lt; 1/R_{min} \)). We can therefore compute any alpha-shape of the digitization of a compact and convex set by a linear-time scan of the points of its boundary.</p>
<p>In such cases, you can perform the computation in two steps. First, you must define a predicate from an instance of <a class="el" href="classDGtal_1_1InGeneralizedDiskOfGivenRadius.html" title="Aim: This class implements an orientation functor that   provides a way to determine the position of ...">InGeneralizedDiskOfGivenRadius</a> as follows: </p><div class="fragment"><div class="line">    <span class="keyword">typedef</span> AvnaimEtAl2x2DetSignComputer&lt;DGtal::int64_t&gt; DetComputer; </div>
<div class="line">    <span class="keyword">typedef</span> InGeneralizedDiskOfGivenRadius&lt;Z2i::Point, DetComputer&gt; <a class="code" href="testConvexHull2DReverse_8cpp.html#a4b95d895f3d8af697b8c550bc833cc9f">Functor</a>; </div>
<div class="line">    <a class="code" href="testConvexHull2DReverse_8cpp.html#a4b95d895f3d8af697b8c550bc833cc9f">Functor</a> functor(<span class="keyword">true</span>, 1, 0); <span class="comment">//alpha = 0; 1/alpha -&gt; +inf </span></div>
<div class="line">    <span class="keyword">typedef</span> PredicateFromOrientationFunctor2&lt;Functor&gt; Predicate; </div>
<div class="line">    Predicate predicate( functor ); </div>
</div><!-- fragment --><p> Then, you can call the procedure closedGrahamScanFromAnyPoint as follows: </p><div class="fragment"><div class="line">    <a class="code" href="namespaceDGtal_1_1functions_1_1Hull2D.html#a36a5b9f6ff0943c40f07fb9128313af7">closedGrahamScanFromAnyPoint</a>( border.begin(), border.end(), back_inserter( res ), predicate );   </div>
<div class="ttc" id="anamespaceDGtal_1_1functions_1_1Hull2D_html_a36a5b9f6ff0943c40f07fb9128313af7"><div class="ttname"><a href="namespaceDGtal_1_1functions_1_1Hull2D.html#a36a5b9f6ff0943c40f07fb9128313af7">DGtal::functions::Hull2D::closedGrahamScanFromAnyPoint</a></div><div class="ttdeci">void closedGrahamScanFromAnyPoint(const ForwardIterator &amp;itb, const ForwardIterator &amp;ite, OutputIterator res, const Predicate &amp;aPredicate)</div><div class="ttdoc">Procedure that retrieves the vertices of the convex hull of a weakly externally visible polygon (WEVP...</div></div>
</div><!-- fragment --><p> In order to create an instance of <a class="el" href="classDGtal_1_1InGeneralizedDiskOfGivenRadius.html" title="Aim: This class implements an orientation functor that   provides a way to determine the position of ...">InGeneralizedDiskOfGivenRadius</a>, you must provide the value of \( 1/\alpha \) by three arguments:</p><ul>
<li>a boolean to set the sign of \( \alpha \) ('true' if \( \alpha \geq 0 \), 'false' if \( \alpha &lt; 0 \)),</li>
<li>the squared numerator of \( 1/\alpha \)</li>
<li>the squared denominator of \( 1/\alpha \). As shown above, \( \alpha = 0 \) if this third argument is zero. <br  />
</li>
</ul>
<p>For example, the following line set \( \alpha \) to \( 1/9 \). </p><div class="fragment"><div class="line">    <a class="code" href="testConvexHull2DReverse_8cpp.html#a4b95d895f3d8af697b8c550bc833cc9f">Functor</a> functor(<span class="keyword">true</span>, 81, 1); <span class="comment">//1/alpha = sqrt(81/1) = 9 </span></div>
</div><!-- fragment --><p> The above illustrations are generated by the program written in <a class="el" href="exampleAlphaShape_8cpp.html">exampleAlphaShape.cpp</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 1 2021 17:06:27 for DGtal by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
