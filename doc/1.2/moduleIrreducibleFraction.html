<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DGtal: Irreducible fraction, continued fractions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="modern-doxygen-blue.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Irreducible fraction, continued fractions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#dgtal_irrfrac_sec1">Introduction to positive irreducible fraction.</a><ul><li class="level2"><a href="#dgtal_irrfrac_sec1_1">Euclid algorithm</a></li>
<li class="level2"><a href="#dgtal_irrfrac_sec1_2">Continued fraction</a></li>
<li class="level2"><a href="#dgtal_irrfrac_sec1_3">Stern-Brocot tree</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtal_irrfrac_sec2">Implementation of irreducible fractions.</a><ul><li class="level2"><a href="#dgtal_irrfrac_sec2_1">Irreducible fraction concept</a></li>
<li class="level2"><a href="#dgtal_irrfrac_sec2_2">Naive approach</a></li>
<li class="level2"><a href="#dgtal_irrfrac_sec2_3">First approach with Stern-Brocot tree</a></li>
<li class="level2"><a href="#dgtal_irrfrac_sec2_4">Second approach with Stern-Brocot tree</a></li>
</ul>
</li>
<li class="level1"><a href="#dgtal_irrfrac_sec3">Using irreducible fractions.</a><ul><li class="level2"><a href="#dgtal_irrfrac_sec3_1">Choosing your integers for fractions</a></li>
<li class="level2"><a href="#dgtal_irrfrac_sec3_2">Instantiating fractions</a></li>
<li class="level2"><a href="#dgtal_irrfrac_sec3_3">Obtaining quotients</a></li>
<li class="level2"><a href="#dgtal_irrfrac_sec3_3_bis">Obtaining all the convergents of a fraction</a></li>
<li class="level2"><a href="#dgtal_irrfrac_sec3_4">Fractions are back insertable</a></li>
<li class="level2"><a href="#dgtal_irrfrac_sec3_5">Computing reduced fractions</a></li>
<li class="level2"><a href="#dgtal_irrfrac_sec3_6">Getting ancestors in the Stern-Brocot tree</a></li>
<li class="level2"><a href="#dgtal_irrfrac_sec3_7">Inverse of a fraction</a></li>
<li class="level2"><a href="#dgtal_irrfrac_sec3_8">Rational approximation of floating-point number</a></li>
<li class="level2"><a href="#dgtal_irrfrac_sec3_9">Standard arithmetic operations &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section user"><dt>Author(s) of this documentation: </dt><dd>Jacques-Olivier Lachaud</dd></dl>
<p>Part of the <a class="el" href="packageArithmetic.html">Arithmetic package</a>.</p>
<p>This part of the manual describes how to create and use irreducible fractions. More precisely, several representations of irreducible fractions are provided. They are based on the Stern-Brocot tree structure. With these fractions, amortized constant time operations are provided for computing reduced fractions.</p>
<p>Part of the code is a backport from <em>ImaGene</em>. <a class="el" href="citelist.html#CITEREF_ImaGene">[53]</a></p>
<h1><a class="anchor" id="dgtal_irrfrac_sec1"></a>
Introduction to positive irreducible fraction.</h1>
<p>A positive <b>irreducible</b> <b>fraction</b> is a fraction <em>p</em> / <em>q</em>, such that <em>p</em> and <em>q</em> are positive integers and gcd(<em>p</em>, <em>q</em>)=1. The fractions \(\frac{0}{1}\) (zero) and \(\frac{1}{0}\) (infinite) are added for convenience. Standard operations like '+', '-', '*', or '/' can be defined over these fractions: it is a matter of playing with numerators and denominators.</p>
<p>However, these fractions have other properties that are useful in the context of digital geometry, especially in digital straightness. These other properties are related to Euclid algorithm, the Stern-Brocot tree, and simple continued fractions.</p>
<h2><a class="anchor" id="dgtal_irrfrac_sec1_1"></a>
Euclid algorithm</h2>
<p>The well-known Euclid algorithm is useful to compute the greatest common divisor of two integers <em>p</em> and <em>q</em>. However, its intermediate computations are also useful. Let us play with 8/3 (see <a class="el" href="classDGtal_1_1IntegerComputer.html#ae5af156009b4e1154c4b789952b71160">IntegerComputer::gcd</a>).</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">p   </th><th class="markdownTableHeadNone">=   </th><th class="markdownTableHeadNone">u   </th><th class="markdownTableHeadNone">*   </th><th class="markdownTableHeadNone">q   </th><th class="markdownTableHeadNone">+   </th><th class="markdownTableHeadNone">r    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">=   </td><td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">*   </td><td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">+   </td><td class="markdownTableBodyNone">2    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">=   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">*   </td><td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">+   </td><td class="markdownTableBodyNone">1    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">=   </td><td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">*   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">+   </td><td class="markdownTableBodyNone">0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">*   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
</table>
<p>At each iteration, <em>p</em> takes the former value of <em>q</em>, <em>q</em> takes the former value of <em>r</em>. The algorithm stops when <em>q</em> is null. Then <em>p</em> is the gcd (1 here).</p>
<p>The values of <em>u</em> are called the <b>quotients</b> of \(\frac{p}{q}\), and are numbered from 0. A unique way to describe \(\frac{p}{q}\) is the sequence \(u_0,u_1,\ldots,u_k\), which is in fact denoted as \([u_0;u_1,\ldots,u_k]\). This sequence <b>characterizes</b> the fraction.</p>
<h2><a class="anchor" id="dgtal_irrfrac_sec1_2"></a>
Continued fraction</h2>
<p>In fact, one can prove that \(\frac{p}{q}=u_0+\frac{1}{u_1+\frac{1}{\ldots+\frac{1}{u_k}}}\), which is the simple continued fraction of <em>p</em> / <em>q</em>.</p>
<p>The successive fractions \(\frac{p_i}{q_i}=[u_0;u_1,\ldots,u_i]\), for \(k &lt; i\) are called the <em>principal</em> <em>convergents</em> of \(\frac{p}{q}\), and are the best approximations of this fraction for the size of their denominator.</p>
<p>A <em>i-<em>reduced</em> of</em> a continued fraction is its <em>k</em> - <em>i-th</em> convergent. The <em>depth</em> of the fraction is <em>k</em>.</p>
<p>A nice property of convergents with respect to their fraction is that even convergents are smaller than the fraction while odd convergents are greater.</p>
<h2><a class="anchor" id="dgtal_irrfrac_sec1_3"></a>
Stern-Brocot tree</h2>
<p>Another (but one-to-one) way of seeing irreducible fractions is the Stern-Brocot tree. Place the fractions 0/1 and 1/0 at the top, then for each pair of consecutive fractions \(\frac{p}{q}\) and \(\frac{p&#39;}{q&#39;}\) compute its mediant \(\frac{p+p&#39;}{q+q&#39;}\). The fraction 1/1 appears first, then 1/2 and 2/1, then 1/3, 2/3, 3/2, 3/1, etc.</p>
<div class="image">
<img src="Sternbrocot.png" alt=""/>
<div class="caption">
Stern-Brocot tree of irreducible fractions.</div></div>
 <p>Now the sequence of quotients \(u_0, u_1,\ldots, u_k \) is exactly the sequence of right-then-left moves in the Stern-Brocot tree from node 1/1 when \( u_0 \ge 1 \), except for the last \( u_k \) where there is one less movement. Otherwise, when \( u_0 = 0 \), the sequence \( u_1,\ldots, u_k \) is exactly the sequence of left-then-right moves in the Stern-Brocot tree from node 1/1, except for the last \( u_k \) where there is one less movement.</p>
<p>Looking back at \( 8/3=[2;1,2] \) gives 2 right moves, 1 left move, then 2-1 right move.</p>
<h1><a class="anchor" id="dgtal_irrfrac_sec2"></a>
Implementation of irreducible fractions.</h1>
<p>When playing with irreducible fractions, computing reduced fractions or partial quotients is one of the main task. For instance, splitting formula and Berstel splitting formula is intensively used by algorithms related to digital straightness. Therefore, we must have representations of irreducible fractions which are efficient for that kind of requests.</p>
<p>Several representations have been implemented in the Arithmetic package. Their interface are common (see <a class="el" href="moduleIrreducibleFraction.html#dgtal_irrfrac_sec2_1">Irreducible fraction concept</a>) so that a user can choose which representation suits him best.</p>
<h2><a class="anchor" id="dgtal_irrfrac_sec2_1"></a>
Irreducible fraction concept</h2>
<p>Irreducible fractions are first described abstractly with the concept CPositiveIrreducibleFraction. Note that the following operations are defined for each irreducible fraction.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name   </th><th class="markdownTableHeadNone">Expression   </th><th class="markdownTableHeadNone">Type requirements   </th><th class="markdownTableHeadNone">Return type   </th><th class="markdownTableHeadNone">Precondition   </th><th class="markdownTableHeadNone">Semantics   </th><th class="markdownTableHeadNone">Post condition   </th><th class="markdownTableHeadNone">Complexity    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Constructor   </td><td class="markdownTableBodyNone"><code>Fraction</code>( <em>p</em>, <em>q</em> )   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><em>X</em>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">creates the fraction p'/q', where p'=p/g, q'=q/g, g=gcd(p,q)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">o(<em>p+<em>q</em>)</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">numerator   </td><td class="markdownTableBodyNone"><em>x</em>.<code>p()</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><em>Integer</em>   </td><td class="markdownTableBodyNone">! <em>x</em>.<code>null()</code>   </td><td class="markdownTableBodyNone">returns the numerator   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">denominator   </td><td class="markdownTableBodyNone"><em>x</em>.<code>q()</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><em>Integer</em>   </td><td class="markdownTableBodyNone">! <em>x</em>.<code>null()</code>   </td><td class="markdownTableBodyNone">returns the denominator   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">quotient   </td><td class="markdownTableBodyNone"><em>x</em>.<code>u()</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><em>Size</em>   </td><td class="markdownTableBodyNone">! <em>x</em>.<code>null()</code>   </td><td class="markdownTableBodyNone">returns the quotient \(u_k\)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">depth   </td><td class="markdownTableBodyNone"><em>x</em>.<code>k()</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><em>Size</em>   </td><td class="markdownTableBodyNone">! <em>x</em>.<code>null()</code>   </td><td class="markdownTableBodyNone">returns the depth <em>k</em>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">null test   </td><td class="markdownTableBodyNone"><em>x</em>.<code>null()</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><code>bool</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">returns 'true' if the fraction is null 0/0 (default fraction)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">even parity   </td><td class="markdownTableBodyNone"><em>x</em>.<code>even()</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><code>bool</code>   </td><td class="markdownTableBodyNone">! <em>x</em>.<code>null()</code>   </td><td class="markdownTableBodyNone">returns 'true' iff the fraction is even, i.e. <em>k</em> is even   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">odd parity   </td><td class="markdownTableBodyNone"><em>x</em>.<code>odd()</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><code>bool</code>   </td><td class="markdownTableBodyNone">! <em>x</em>.<code>null()</code>   </td><td class="markdownTableBodyNone">returns 'true' iff the fraction is odd, i.e. <em>k</em> is odd   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">left descendant   </td><td class="markdownTableBodyNone"><em>x</em>.<code>left()</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><em>X</em>   </td><td class="markdownTableBodyNone">! <em>x</em>.<code>null()</code>   </td><td class="markdownTableBodyNone">returns the left descendant of p/q in the Stern-Brocot tree   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">right descendant   </td><td class="markdownTableBodyNone"><em>x</em>.<code>right()</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><em>X</em>   </td><td class="markdownTableBodyNone">! <em>x</em>.<code>null()</code>   </td><td class="markdownTableBodyNone">returns the right descendant of p/q in the Stern-Brocot tree   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">father   </td><td class="markdownTableBodyNone"><em>x</em>.<code>father()</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><em>X</em>   </td><td class="markdownTableBodyNone">! <em>x</em>.<code>null()</code>   </td><td class="markdownTableBodyNone">returns the father of this fraction, ie \([u_0,...,u_k - 1]\)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">m-father   </td><td class="markdownTableBodyNone"><em>x</em>.<code>father</code>(<em>m</em>)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><em>X</em>   </td><td class="markdownTableBodyNone">! <em>x</em>.<code>null()</code>, <em>m&gt;=0</em>   </td><td class="markdownTableBodyNone">returns the <em>m-father</em> of this fraction, ie \([u_0,...,u_{k-1}, m]\)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">O( <em>m</em>)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">previousPartial   </td><td class="markdownTableBodyNone"><em>x</em>.<code>previousPartial()</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><em>X</em>   </td><td class="markdownTableBodyNone">! <em>x</em>.<code>null()</code>   </td><td class="markdownTableBodyNone">returns the previous partial of this fraction, ie \([u_0,...,u_{k-1}]\)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">inverse   </td><td class="markdownTableBodyNone"><em>x</em>.<code>inverse()</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><em>X</em>   </td><td class="markdownTableBodyNone">! <em>x</em>.<code>null()</code>   </td><td class="markdownTableBodyNone">returns the inverse of this fraction, ie \([0,u_0,...,u_k]\) if \(u_0 \neq 0 \) or \([u_1,...,u_k]\) otherwise   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><em>m-th</em> partial   </td><td class="markdownTableBodyNone"><em>x</em>.<code>partial(m)</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><em>X</em>   </td><td class="markdownTableBodyNone">! <em>x</em>.<code>null()</code>   </td><td class="markdownTableBodyNone">returns the <em>m-th</em> partial of this fraction, ie \([u_0,...,u_m]\)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em>m-th</em> reduced   </td><td class="markdownTableBodyNone"><em>x</em>.<code>reduced(m)</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><em>X</em>   </td><td class="markdownTableBodyNone">! <em>x</em>.<code>null()</code>   </td><td class="markdownTableBodyNone">returns the <em>m-th</em> reduced of this fraction, equivalently the \(k-m\) partial, ie \([u_0,...,u_{k-m}]\)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">splitting formula   </td><td class="markdownTableBodyNone"><em>x</em>.<code>getSplit</code>(<em>x1</em>, <em>x2</em>)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><code>void</code>   </td><td class="markdownTableBodyNone">! <em>x</em>.<code>null()</code>   </td><td class="markdownTableBodyNone">modifies fractions <em>x1</em> and <em>x2</em> such that \( x1 \oplus x2 = x \)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Berstel splitting formula   </td><td class="markdownTableBodyNone"><em>x</em>.<code>getSplitBerstel</code>(<em>x1</em>, <em>n1</em>, <em>x2</em>, <em>n2</em>)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><code>void</code>   </td><td class="markdownTableBodyNone">! <em>x</em>.<code>null()</code>   </td><td class="markdownTableBodyNone">modifies fractions <em>x1</em> and <em>x2</em> and integers <em>n1</em> and <em>n2</em> such that \( (x1)^{n1} \oplus (x2)^{n2} = x \)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Continued fraction coefficients   </td><td class="markdownTableBodyNone"><em>x</em>.<code>getCFrac</code>(<em>quots</em>)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><code>void</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">modifies the vector <em>quots</em> such that it contains the quotients \(u_0,u_1,...,u_k \)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">O(k)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">equality   </td><td class="markdownTableBodyNone"><em>x</em>.<code>equals</code>(<em>p</em>, <em>q</em>)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><code>bool</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">returns 'true' iff the fraction is equal to \( p / q \).   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">less than   </td><td class="markdownTableBodyNone"><em>x</em>.<code>lessThan</code>(<em>p</em>, <em>q</em>)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><code>bool</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">returns 'true' iff the fraction is inferior to \( p / q \).   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">more than   </td><td class="markdownTableBodyNone"><em>x</em>.<code>moreThan</code>(<em>p</em>, <em>q</em>)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><code>bool</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">returns 'true' iff the fraction is superior to \( p / q \).   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">equality ==   </td><td class="markdownTableBodyNone"><em>x</em> == <em>y</em>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><code>bool</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">returns 'true' iff the fraction is equal to <em>y</em>.   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">inequality !=   </td><td class="markdownTableBodyNone"><em>x</em> != <em>y</em>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><code>bool</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">returns 'true' iff the fraction is different from <em>y</em>.   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">less than &lt;   </td><td class="markdownTableBodyNone"><em>x</em> &lt; <em>y</em>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><code>bool</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">returns 'true' iff the fraction is inferior to <em>y</em>.   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">more than &gt;   </td><td class="markdownTableBodyNone"><em>x</em> &gt; <em>y</em>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><code>bool</code>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">returns 'true' iff the fraction is superior to <em>y</em>.   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">O(1)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Next continued fraction   </td><td class="markdownTableBodyNone"><em>x.pushBack( pair )</em>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">transforms this fraction \([0,u_0,...,u_k]\) into \([0,u_0,...,u_k,m]\), where <em>pair</em> is \((m,k+1)\)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">O(m)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Next continued fraction   </td><td class="markdownTableBodyNone"><em>x.push_back( pair )</em>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">transforms this fraction \([0,u_0,...,u_k]\) into \([0,u_0,...,u_k,m]\), where <em>pair</em> is \((m,k+1)\)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">O(m)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Begin visiting quotients   </td><td class="markdownTableBodyNone"><em>x.begin()</em>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><em>ConstIterator</em>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">returns a forward iterator on the beginning of the sequence of quotients \([u_0,...,u_k]\)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">End visiting quotients   </td><td class="markdownTableBodyNone"><em>x.end()</em>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"><em>ConstIterator</em>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">returns a forward iterator after the end of the sequence of quotients \([u_0,...,u_k]\)   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone"></td></tr>
</table>
<p>Inner types are:</p>
<ul>
<li><em>Integer:</em> the type for representing a numerator or a denominator.</li>
<li><em>Size:</em> the type for representing partial quotients, i.e. the integers that appear in the continued fractions of p/q. Might be the same as Integer but may be also smaller, since quotients are generally much smaller than the convergent numerators and denominators.</li>
<li><em>Value</em> and <em>value_type:</em> the type <code>std::pair&lt;Size,Size&gt;</code>, useful to create back insertion sequence.</li>
<li><em>ConstIterator</em> and <em>const_iterator:</em> the type for visiting the quotients of the fraction in sequence. The value of the iterator has type <em>Value</em>.</li>
</ul>
<p>Notations are:</p>
<ul>
<li><em>X</em> : A type that is a model of CPositiveIrreducibleFraction</li>
<li><em>x</em> : object of type <em>X</em>, which is below some fraction written \([u_0, \ldots, u_k]\) as a continued fraction</li>
<li><em>x1</em>, <em>x2</em>, <em>y</em> : other objects of type <em>X</em> </li>
<li><em>p</em>, <em>q</em> : object of type <em>Integer</em> </li>
<li><em>m</em>, <em>n1</em>, <em>n2</em> : objects of type <em>Size</em> </li>
<li><em>quots</em> : an object of type <code>std::vector&lt;Size&gt;</code> </li>
<li><em>pair</em> : a object of <code>std::pair&lt;Size,Size&gt;</code>, here (m,k+1) <br  />
</li>
</ul>
<h2><a class="anchor" id="dgtal_irrfrac_sec2_2"></a>
Naive approach</h2>
<p>A naive approach is to represent an irreducible fraction with three arrays of integers: the numerators (p_i), the denominators (q_i), the quotients (u_i).</p>
<p>However, each time we duplicate the fraction, or each time we compute a reduced fraction, the complexity of the operation is proportional to the depth of the fraction, i.e. in O(k).</p>
<p>We wish to have amortized O(1) complexity for these operations. Therefore, we take another path.</p>
<h2><a class="anchor" id="dgtal_irrfrac_sec2_3"></a>
First approach with Stern-Brocot tree</h2>
<p>This approach is implemented in the class <a class="el" href="classDGtal_1_1SternBrocot_1_1Fraction.html" title="This fraction is a model of CPositiveIrreducibleFraction.">SternBrocot::Fraction</a> (see also class <a class="el" href="classDGtal_1_1SternBrocot.html" title="Aim: The Stern-Brocot tree is the tree of irreducible fractions. This class allows to construct it pr...">SternBrocot</a>). We construct on demand parts of the Stern-Brocot tree structure. For instance, if one wish to manipule fraction 8/3, the following nodes of the tree are computed once and for all: 0/1, 1/0, 1/1, 2/1, 1/2, 3/1, 1/3, 5/2, 2/5, 8/3, 3/8.</p>
<p>Each node in the Stern-Brocot is created once. The node stores information on the irreducible fraction itself (p/q, the partial quotient u, the depth k), but also pointers to ascendants, descendants and inverse in the Stern-Brocot tree. Nodes are constructed on demand, when the user ask for descendant or for a specific fraction.</p>
<p>A fraction <a class="el" href="classDGtal_1_1SternBrocot_1_1Fraction.html" title="This fraction is a model of CPositiveIrreducibleFraction.">SternBrocot::Fraction</a> is just a pointer to the corresponding node in the Stern-Brocot tree. Looking for a reduced partial is just moving from node to node.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/arithmetic/SternBrocot.h&quot;</span></div>
<div class="line">...</div>
<div class="line">typedef SternBrocot&lt;DGtal::int64_t,DGtal::int32_t&gt; SB;</div>
<div class="line"><span class="keyword">typedef</span> SB::Fraction Fraction;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">Fraction::ConstIterator</a> <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a>;</div>
<div class="line"> </div>
<div class="line">Fraction f1( 117, 45 ); <span class="comment">// 117/45</span></div>
<div class="line">Fraction f2; <span class="comment">// null 0/0</span></div>
<div class="line">f2.push_back( std::make_pair( 2, 0 ) ); <span class="comment">// u_0 = 2</span></div>
<div class="line">f2.push_back( std::make_pair( 1, 1 ) ); <span class="comment">// u_1 = 1</span></div>
<div class="line">f2.push_back( std::make_pair( 2, 2 ) ); <span class="comment">// u_2 = 2</span></div>
<div class="line"><span class="comment">// f2 = 8/3</span></div>
<div class="line"><span class="comment">// Displays quotients of f1.</span></div>
<div class="line"><span class="keywordflow">for</span> ( <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a> it = f1.begin(), itend = f1.end();</div>
<div class="line">      it != itend; ++it )</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;u_&quot;</span> &lt;&lt; (*it).second </div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; (*it).first &lt;&lt; std::endl;</div>
<div class="ttc" id="agreedy-plane-segmentation-ex2_8cpp_html_a6d06fad433cff067dfcbbbf16d6e2dbf"><div class="ttname"><a href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a></div><div class="ttdeci">MyDigitalSurface::ConstIterator ConstIterator</div><div class="ttdef"><b>Definition:</b> <a href="greedy-plane-segmentation-ex2_8cpp_source.html#l00093">greedy-plane-segmentation-ex2.cpp:93</a></div></div>
</div><!-- fragment --><p>You may have a look at <a class="el" href="testSternBrocot_8cpp.html">testSternBrocot.cpp</a> to see how to use these fractions.</p>
<p>Also inverses and reduced fractions are quickly computed, this representation has two disadvantages:</p><ul>
<li>it is memory costly: many nodes are created for a fraction. In fact \(2\sum_{i=1..k} u_i\) nodes may be created.</li>
<li>it is not optimal in terms of complexity. Reduced takes O(1) but computing \([u_0,...,u_{k-1},m]\) takes O(u_k-m).</li>
</ul>
<h2><a class="anchor" id="dgtal_irrfrac_sec2_4"></a>
Second approach with Stern-Brocot tree</h2>
<p>This approach is implemented in the class <a class="el" href="classDGtal_1_1LighterSternBrocot_1_1Fraction.html" title="This fraction is a model of CPositiveIrreducibleFraction.">LighterSternBrocot::Fraction</a> (see also class <a class="el" href="classDGtal_1_1LighterSternBrocot.html" title="Aim: The Stern-Brocot tree is the tree of irreducible fractions. This class allows to construct it pr...">LighterSternBrocot</a>).</p>
<p>There are two main differences with the class <a class="el" href="classDGtal_1_1SternBrocot.html" title="Aim: The Stern-Brocot tree is the tree of irreducible fractions. This class allows to construct it pr...">SternBrocot</a>. The first one is that inverses are not stored. With this optimization, there are twice less nodes and each node is lighter. The second one lies in the access to the children of a node. Here, a map type M is provided so that a node \( [u_0; u_1, ..., u_n] \) can access its child node \( [u_0; u_1, ..., u_n, k] \) in the time of the operation M::operator[]. This representation is also different from <a class="el" href="classDGtal_1_1LightSternBrocot.html" title="Aim: The Stern-Brocot tree is the tree of irreducible fractions. This class allows to construct it pr...">LightSternBrocot</a> in the sense that nodes have only one set of child nodes and that only fractions greater than 1/1 are stored.</p>
<p>In this representation, the fraction 1/1 has depth 0, like 2/1, 3/1, etc. Furthermore, each fraction \( [u_0,...,u_n] \) has an origin which is the fraction \( [u_0,...,u_{n-1},1] \). It is the top extremity of this branch. The origin has depth n-1 since \( [u_0,...,u_{n-1},1] \) = \( [u_0,...,u_{n-1}+1] \). Inversely a k-child of \( [u_0,...,u_n] \), for k &gt;= 2, is the fraction \( [u_0,...,u_n - 1, k] \). A 1-child of a fraction f is itself, except for the fraction 1/0 where its 1-child is 1/1 by convention.</p>
<p>In practice, also this class has supposedly a better complexity than <a class="el" href="classDGtal_1_1SternBrocot.html" title="Aim: The Stern-Brocot tree is the tree of irreducible fractions. This class allows to construct it pr...">SternBrocot</a>, it is 1% slower for integers smaller than 10^9 and 5% slower for integers smaller than 10^4. Note however that it takes like 7 times less memory (and asymptotically less when the number of computations tends toward infinity).</p>
<p>This class is not to be instantiated, since it is useless to duplicate it. Use static method <a class="el" href="classDGtal_1_1LighterSternBrocot.html#a18773744ffe8b2e557631420d0a9f78a">LighterSternBrocot::fraction</a> or constructor of <a class="el" href="classDGtal_1_1LighterSternBrocot_1_1Fraction.html" title="This fraction is a model of CPositiveIrreducibleFraction.">LighterSternBrocot::Fraction</a> to obtain your fractions.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;DGtal/arithmetic/LighterSternBrocot.h&quot;</span></div>
<div class="line">...</div>
<div class="line">typedef SternBrocot&lt;DGtal::int64_t, DGtal::int32_t, DGtal::StdMapRebinder&gt; SB;</div>
<div class="line"><span class="keyword">typedef</span> SB::Fraction Fraction;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">Fraction::ConstIterator</a> <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a>;</div>
<div class="line"> </div>
<div class="line">Fraction f1( 117, 45 ); <span class="comment">// 117/45</span></div>
<div class="line">Fraction f2; <span class="comment">// null 0/0</span></div>
<div class="line">f2.push_back( std::make_pair( 2, 0 ) ); <span class="comment">// u_0 = 2</span></div>
<div class="line">f2.push_back( std::make_pair( 1, 1 ) ); <span class="comment">// u_1 = 1</span></div>
<div class="line">f2.push_back( std::make_pair( 2, 2 ) ); <span class="comment">// u_2 = 2</span></div>
<div class="line"><span class="comment">// f2 = 8/3</span></div>
<div class="line"><span class="comment">// Displays quotients of f1.</span></div>
<div class="line"><span class="keywordflow">for</span> ( <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a> it = f1.begin(), itend = f1.end();</div>
<div class="line">      it != itend; ++it )</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;u_&quot;</span> &lt;&lt; (*it).second </div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; (*it).first &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>You may have a look at <a class="el" href="testLighterSternBrocot_8cpp.html">testLighterSternBrocot.cpp</a> to see how to use these fractions.</p>
<h1><a class="anchor" id="dgtal_irrfrac_sec3"></a>
Using irreducible fractions.</h1>
<h2><a class="anchor" id="dgtal_irrfrac_sec3_1"></a>
Choosing your integers for fractions</h2>
<p>Available fractions allows you to choose the ultimate precision you wish to have for your fractions.</p>
<p>You have two different integral types for irreducible fractions: TInteger and TSize. The type TInteger defines the integral type for the numerators and the denominators. The type TSize defines the integral type for the quotients and for the depth of the fraction.</p>
<dl class="section note"><dt>Note</dt><dd>It is worthy to note that quotients are in general much much smaller than numerators and denominators (except for fractions p/1 or 1/q). You may choose thus a smaller type for TSize (like <a class="el" href="namespaceDGtal.html#ac1e9ac6a329319ae13c51c0c9e92486a" title="signed 32-bit integer.">DGtal::int32_t</a>) than for TInteger (for instance <a class="el" href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63" title="signed 94-bit integer.">DGtal::int64_t</a>).</dd></dl>
<p>You may for instance choose your fractions like: </p><div class="fragment"><div class="line"><span class="comment">// With SternBrocot</span></div>
<div class="line"><span class="keyword">typedef</span> SternBrocot&lt;DGtal::int64_t,DGtal::int32_t&gt;::Fraction Fraction; <span class="comment">// not so big fractions</span></div>
<div class="line"><span class="keyword">typedef</span> SternBrocot&lt;DGtal::BigInteger,DGtal::BigInteger&gt;::Fraction Fraction; <span class="comment">// arbitrary large fractions</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// With LighterSternBrocot</span></div>
<div class="line"><span class="keyword">typedef</span> LighterSternBrocot&lt;DGtal::int64_t,DGtal::int32_t,DGtal::StdMapRebinder&gt;::Fraction Fraction; <span class="comment">// not so big fractions</span></div>
<div class="line"><span class="keyword">typedef</span> LighterSternBrocot&lt;DGtal::BigInteger,DGtal::BigInteger,DGtal::StdMapRebinder&gt;::Fraction Fraction; <span class="comment">// arbitrary large fractions</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>If you wish to instantiate fractions with integral types other than <a class="el" href="namespaceDGtal.html#ac1e9ac6a329319ae13c51c0c9e92486a" title="signed 32-bit integer.">DGtal::int32_t</a>, <a class="el" href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63" title="signed 94-bit integer.">DGtal::int64_t</a>, <a class="el" href="namespaceDGtal.html#ad14cde66089fcbdefb20c819562d2a0d" title="Multi-precision integer with GMP implementation.">DGtal::BigInteger</a>, then you must instantiate the singleton of the class. For instance, add somewhere in your code:</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// With SternBrocot</span></div>
<div class="line"><span class="keyword">typedef</span> SternBrocot&lt;IntegralType1,IntegralType2&gt;::Fraction Fraction; <span class="comment">// not so big fractions</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line">SternBrocot&lt;IntegralType1,IntegralType2&gt;*</div>
<div class="line"><a class="code" href="classDGtal_1_1SternBrocot.html#a0aa0ad3b7f1e1b888fa543857fc63ad6">SternBrocot&lt;IntegralType1,IntegralType2&gt;::singleton</a> = 0;</div>
<div class="ttc" id="aclassDGtal_1_1SternBrocot_html_a0aa0ad3b7f1e1b888fa543857fc63ad6"><div class="ttname"><a href="classDGtal_1_1SternBrocot.html#a0aa0ad3b7f1e1b888fa543857fc63ad6">DGtal::SternBrocot::singleton</a></div><div class="ttdeci">static SternBrocot * singleton</div><div class="ttdoc">Singleton class.</div><div class="ttdef"><b>Definition:</b> <a href="SternBrocot_8h_source.html#l00467">SternBrocot.h:467</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>In some sense, <em>IntegralType2</em> should be promotable to <em>IntegralType1</em>. I.e., if <em>t1</em> is of type <em>IntegralType1</em> and <em>t2</em> is of type <em>IntegralType2</em> then</dd></dl>
<div class="fragment"><div class="line">t1 = (IntegralType1) t2; </div>
</div><!-- fragment --><p> should be valid.</p>
<h2><a class="anchor" id="dgtal_irrfrac_sec3_2"></a>
Instantiating fractions</h2>
<p>You may instantiate a fraction directly by giving the numerator <em>p</em> and denominator <em>q</em>. Note that if \( g = gcd(p,q) \neq 1 \), the instantiated fraction is \( \frac{p&#39;}{q&#39;} \) where \( p&#39;=p/g, q&#39;=q/g \). We follow the example <a class="el" href="convergents_8cpp.html">convergents.cpp</a>.</p>
<p>First we give the correct includes:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DGtal/arithmetic/LighterSternBrocot.h&quot;</span></div>
</div><!-- fragment --><p> Then the useful types:</p>
<div class="fragment"><div class="line">  <span class="keyword">typedef</span> LighterSternBrocot&lt;DGtal::int64_t, DGtal::int64_t, StdMapRebinder&gt; SB; <span class="comment">// the type of the Stern-Brocot tree</span></div>
<div class="line">  <span class="keyword">typedef</span> SB::Fraction Fraction; <span class="comment">// the type for fractions</span></div>
<div class="line">  <span class="keyword">typedef</span> <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">Fraction::ConstIterator</a> <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a>; <span class="comment">// the iterator type for visiting quotients</span></div>
<div class="line">  <span class="keyword">typedef</span> <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">Fraction::Value</a> <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">Value</a>; <span class="comment">// the value of the iterator, a pair (quotient,depth).</span></div>
<div class="ttc" id="atestSimpleRandomAccessRangeFromPoint_8cpp_html_a566a00621638570a4186414035153a2e"><div class="ttname"><a href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">Value</a></div><div class="ttdeci">double Value</div><div class="ttdef"><b>Definition:</b> <a href="testSimpleRandomAccessRangeFromPoint_8cpp_source.html#l00041">testSimpleRandomAccessRangeFromPoint.cpp:38</a></div></div>
</div><!-- fragment --><p> The program is given <em>p</em> and <em>q</em> in arguments <em>argv</em>. The fraction is instantiated as follows:</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63">DGtal::int64_t</a> p = atoll( argv[ 1 ] );</div>
<div class="line">  <a class="code" href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63">DGtal::int64_t</a> q = atoll( argv[ 2 ] );</div>
<div class="line">  Fraction f( p, q ); <span class="comment">// fraction p/q</span></div>
<div class="ttc" id="anamespaceDGtal_html_a1c09e3f63904ff371f1b99f45069fc63"><div class="ttname"><a href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63">DGtal::int64_t</a></div><div class="ttdeci">boost::int64_t int64_t</div><div class="ttdoc">signed 94-bit integer.</div><div class="ttdef"><b>Definition:</b> <a href="BasicTypes_8h_source.html#l00074">BasicTypes.h:74</a></div></div>
</div><!-- fragment --> <h2><a class="anchor" id="dgtal_irrfrac_sec3_3"></a>
Obtaining quotients</h2>
<p>You may visit the quotients of a fraction by using the single-pass iterators provided by the class. A fraction is indeed a model of CSinglePassConstRange. The quotients are computed and stored with the call to <code>begin()</code>. We therefore advise you to store the begin() iterator in a variable. Then, all other operations with iterators (copy, displacement, comparison, dereferenciation) are O(1). We display the quotients of the fraction <em>f</em> as follows.</p>
<div class="fragment"><div class="line">  <span class="comment">// Visit quotients u_k as pair (u_k,k)</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;z = &quot;</span>;</div>
<div class="line">  <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a> itbegin = f.begin(), itend = f.end();</div>
<div class="line">  <span class="keywordflow">for</span> ( <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a> it = itbegin; it != itend; ++it )</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">Value</a> u = *it;</div>
<div class="line">      std::cout &lt;&lt; ( ( it == itbegin ) ? <span class="stringliteral">&quot;[&quot;</span> : <span class="stringliteral">&quot;,&quot;</span> )</div>
<div class="line">                &lt;&lt; u.first;</div>
<div class="line">    }</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The iterator value is the pair \( (u_i,i) \) where \( 0 \le i \le k \) and <em>k</em> is the depth of the fraction. The type is therefore a <code>std::pair&lt;Size,Size&gt;</code>. This is done for consistency with <code>push_back</code> method.</dd></dl>
<h2><a class="anchor" id="dgtal_irrfrac_sec3_3_bis"></a>
Obtaining all the convergents of a fraction</h2>
<p>One way of obtaining all the convergents of a fraction is simply to create the fraction progressively by adding quotients one at a time. You may use the methods <code>pushBack</code> or <code>push_back</code> to do so. This can be done as follows:</p>
<div class="fragment"><div class="line">  Fraction g;         <span class="comment">// fraction null, 0/0, invalid</span></div>
<div class="line">  <span class="keywordflow">for</span> ( <a class="code" href="greedy-plane-segmentation-ex2_8cpp.html#a6d06fad433cff067dfcbbbf16d6e2dbf">ConstIterator</a> it = itbegin; it != itend; ++it )</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="testSimpleRandomAccessRangeFromPoint_8cpp.html#a566a00621638570a4186414035153a2e">Value</a> u = *it;</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;z_&quot;</span> &lt;&lt; u.second &lt;&lt; <span class="stringliteral">&quot; = &quot;</span>;</div>
<div class="line">      g.push_back( u ); <span class="comment">// add (u_i,i) to existing fractions</span></div>
<div class="line">      std::cout &lt;&lt; g.p() &lt;&lt; <span class="stringliteral">&quot; / &quot;</span> &lt;&lt; g.q() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
</div><!-- fragment --><p> You may now execute this program to get the quotients and the convergents of a given fraction. We give below several examples:</p>
<pre class="fragment"># A Fibonacci fraction
$ ./examples/arithmetic/convergents 21 34
z = [0,1,1,1,1,1,1,2]
z_0 = 0 / 1
z_1 = 1 / 1
z_2 = 1 / 2
z_3 = 2 / 3
z_4 = 3 / 5
z_5 = 5 / 8
z_6 = 8 / 13
z_7 = 21 / 34

# Approximations of pi
$ ./examples/arithmetic/convergents 103993 33102
z = [3,7,15,1,292]
z_0 = 3 / 1
z_1 = 22 / 7
z_2 = 333 / 106
z_3 = 355 / 113
z_4 = 103993 / 33102

# A huge fraction
$ ./examples/arithmetic/convergents-biginteger 243224233245235253407096734543059 4324213412343432913758138673203834
z = [0,17,1,3,1,1,12,1,2,33,2,1,1,1,1,49,1,1,1,1,17,34,1,1,304,1,2,1,1,1,2,1,48,1,20,2,3,5,1,1,16,9,1,1,5,1,2,2,7,4,3,1,7,1,1,17,1,1,29,1,12,2,5]
z_0 = 0 / 1
z_1 = 1 / 17
z_2 = 1 / 18
z_3 = 4 / 71
z_4 = 5 / 89
...
z_18 = 23610961 / 419772458
...
z_40 = 832739221613445323225 / 14805030169237188131024
...
z_62 = 243224233245235253407096734543059 / 4324213412343432913758138673203834
</pre><h2><a class="anchor" id="dgtal_irrfrac_sec3_4"></a>
Fractions are back insertable</h2>
<p>Since fractions have a <code>push_back</code> method, you can use <code>std::back_inserter</code> to create a <code>std::back_insert_iterator</code> on your fraction. The code for computing a fraction from its quotients looks like:</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="fraction_8cpp.html">fraction.cpp</a></dd></dl>
<div class="fragment"><div class="line">  Fraction f;</div>
<div class="line">  OutputIterator itback = std::back_inserter( f );</div>
<div class="line">  <span class="keywordflow">for</span> ( Quotient i = 1; i &lt; argc; ++i)</div>
<div class="line">    {</div>
<div class="line">      Quotient u = atoll( argv[ i ] );</div>
<div class="line">      *itback++ = std::make_pair( u, i-1 );</div>
<div class="line">    }</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;z = &quot;</span> &lt;&lt; f.p() &lt;&lt; <span class="stringliteral">&quot; / &quot;</span> &lt;&lt; f.q() &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> which gives</p>
<pre class="fragment"># More precise approximation of pi
$ ./examples/arithmetic/fraction 3 7 15 1 292 1 1 1 2 1 3 1 14
z = 80143857 / 25510582
</pre><h2><a class="anchor" id="dgtal_irrfrac_sec3_5"></a>
Computing reduced fractions</h2>
<p>If \( z_k \) is a fraction, its 1-reduced is \( z_{k-1} \), its 2-reduced is \( z_{k-2} \) and so on. Reduced are in particular used for computing Bzout vectors, or in splitting formulas. You may use the methods <code>reduced</code> (<a class="el" href="classDGtal_1_1SternBrocot_1_1Fraction.html#a42fb469669bbc5dba8f83d07711af180">SternBrocot::Fraction::reduced</a>, <a class="el" href="classDGtal_1_1LighterSternBrocot_1_1Fraction.html#accc9201444a8b246f81808937e07494d">LighterSternBrocot::Fraction::reduced</a>) or <code>partial</code> (<a class="el" href="classDGtal_1_1SternBrocot_1_1Fraction.html#a388a851461b158ae4d02ea2a6a136bc9">SternBrocot::Fraction::partial</a>, <a class="el" href="classDGtal_1_1LighterSternBrocot_1_1Fraction.html#a2c609a7fba7e2d5ed4ac5641c2066b6d">LighterSternBrocot::Fraction::partial</a>) to obtain them.</p>
<p>Assume <em>f</em> is the fraction \( 103993 / 33102 = [3;7,15,1,292] \). Then </p><div class="fragment"><div class="line">Fraction z_3 = f.reduced( 1 ); <span class="comment">// [3;7,15,1] but in fact [3;7,16]</span></div>
<div class="line">Fraction z_2 = f.reduced( 2 ); <span class="comment">// [3;7,15] </span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The depth of a <em>i-reduced</em> fraction is necessarily \( k - i \). It may be \( k - i - 1 \).</dd></dl>
<p>You dispose also of the methods <code>getSplit</code> and <code>getSplitBerstel</code> to obtain directly the decomposition of a fraction into two fractions. Their "mediant sum" gives the fraction itself. Fractions are seen as vectors in this case.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDGtal_1_1SternBrocot_1_1Fraction.html#a3aa348c7bc82549a9a0db5936aa35253">SternBrocot::Fraction::getSplit</a>, <a class="el" href="classDGtal_1_1LighterSternBrocot_1_1Fraction.html#a185b3796ac3903aa937a17ad7d33a03b">LighterSternBrocot::Fraction::getSplit</a>, <a class="el" href="classDGtal_1_1SternBrocot_1_1Fraction.html#a83ee8ffec0899fee9c738c594c3e3328">SternBrocot::Fraction::getSplitBerstel</a>, <a class="el" href="classDGtal_1_1LighterSternBrocot_1_1Fraction.html#ab37e74d8a75e22cf640ee28e1dc0ca68">LighterSternBrocot::Fraction::getSplitBerstel</a>.</dd></dl>
<h2><a class="anchor" id="dgtal_irrfrac_sec3_6"></a>
Getting ancestors in the Stern-Brocot tree</h2>
<p>Convergents or partials, and reduced fractions are ancestors of a given fractions. There exist in-between ancestors which are not given by these methods. We list them below with their exact definition, assuming <em>f</em> is \( [u_0,...,u_{k-1},u_k] \):</p>
<ul>
<li><em>i-<b>convergent</b> or</em> <em>i-<b>partial:</b> the</em> fraction \( z_i=[u_0,...,u_i] \). Method <code>partial</code>, <a class="el" href="classDGtal_1_1SternBrocot_1_1Fraction.html#a388a851461b158ae4d02ea2a6a136bc9">SternBrocot::Fraction::partial</a>, <a class="el" href="classDGtal_1_1LighterSternBrocot_1_1Fraction.html#a2c609a7fba7e2d5ed4ac5641c2066b6d">LighterSternBrocot::Fraction::partial</a>.</li>
<li><em>i-<b>reduced</b> fraction:</em> the fraction \( z_{k-i}=[u_0,...,u_{k-i}] \). Method <code>reduced</code>, <a class="el" href="classDGtal_1_1SternBrocot_1_1Fraction.html#a42fb469669bbc5dba8f83d07711af180">SternBrocot::Fraction::reduced</a>, <a class="el" href="classDGtal_1_1LighterSternBrocot_1_1Fraction.html#accc9201444a8b246f81808937e07494d">LighterSternBrocot::Fraction::reduced</a>.</li>
<li><b>father</b> fraction: the fraction \( z&#39;=[u_0,...,u_{k-1},u_{k} - 1] \). Method <code>father</code>, <a class="el" href="classDGtal_1_1SternBrocot_1_1Fraction.html#a5eac4a0367b6411951427a2b2fc1dbb5">SternBrocot::Fraction::father</a>, <a class="el" href="classDGtal_1_1LighterSternBrocot_1_1Fraction.html#ac8321f46a68290b2fee3d0b46bed8e31">LighterSternBrocot::Fraction::father</a>.</li>
<li><em>m-<b>father</b> fraction:</em> the fraction \( z&#39;=[u_0,...,u_{k-1},m] \). Method <code>father(Size m)</code>, SternBrocot::Fraction::father(Size m) const, LighterSternBrocot::Fraction::father(Size m) const.</li>
<li><b>origin</b> fraction: the fraction \( z&#39;=[u_0,...,u_{k-1},1] \). Method <code>origin</code>, SternBrocot::Fraction::origin, <a class="el" href="classDGtal_1_1LighterSternBrocot_1_1Fraction.html#afb814e1fd200b64278415c1594d33503">LighterSternBrocot::Fraction::origin</a>.</li>
</ul>
<h2><a class="anchor" id="dgtal_irrfrac_sec3_7"></a>
Inverse of a fraction</h2>
<p>You can get the inverse of a fraction in O(1) with the method <code>inverse</code> (<a class="el" href="classDGtal_1_1SternBrocot_1_1Fraction.html#ad2f41797ad59137f8a56d04773bd01f6">SternBrocot::Fraction::inverse</a>, <a class="el" href="classDGtal_1_1LighterSternBrocot_1_1Fraction.html#a3b3f4f93d8c972b31cf48f668e3a38ad">LighterSternBrocot::Fraction::inverse</a>).</p>
<h2><a class="anchor" id="dgtal_irrfrac_sec3_8"></a>
Rational approximation of floating-point number</h2>
<p>A simple way to get rational approximation of a "real" number is to use the mapping: \( G(x)=\frac{1}{x- \lfloor x \rfloor} \). The successive \( \lfloor x \rfloor \) gives the successive quotients of the rational approximation. You may have a look at example <a class="el" href="approximation_8cpp.html">approximation.cpp</a>.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">long</span> <span class="keywordtype">double</span> epsilon = 1e-14;</div>
<div class="line">  <span class="keywordtype">long</span> <span class="keywordtype">double</span> number0 = strtold( argv[ 1 ], 0 );</div>
<div class="line">  <span class="keywordtype">long</span> <span class="keywordtype">double</span> number = number0;</div>
<div class="line">  ASSERT( number &gt;= 0.0 );</div>
<div class="line">  Fraction f;</div>
<div class="line">  OutputIterator itback = std::back_inserter( f );</div>
<div class="line">  Quotient i = 0;</div>
<div class="line">  <span class="keywordflow">while</span> ( <span class="keyword">true</span> )</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordtype">long</span> <span class="keywordtype">double</span> int_part = floorl( number );</div>
<div class="line">      Quotient u = <a class="code" href="structDGtal_1_1NumberTraitsImpl.html#a0104cb5103fc4596e3fe975a592cc87e">NumberTraits&lt;long double&gt;::castToInt64_t</a>( int_part );</div>
<div class="line">      *itback++ = std::make_pair( u, i++ );</div>
<div class="line">      <span class="keywordtype">long</span> <span class="keywordtype">double</span> approx =</div>
<div class="line">        ( (<span class="keywordtype">long</span> double) <a class="code" href="structDGtal_1_1NumberTraitsImpl.html#af97eb78317d1fc1c6babd4dcc95ed336">NumberTraits&lt;Integer&gt;::castToDouble</a>( f.p() ) )</div>
<div class="line">        / ( (<span class="keywordtype">long</span> double) <a class="code" href="structDGtal_1_1NumberTraitsImpl.html#af97eb78317d1fc1c6babd4dcc95ed336">NumberTraits&lt;Integer&gt;::castToDouble</a>( f.q() ) );</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;z = &quot;</span> &lt;&lt; f.p() &lt;&lt; <span class="stringliteral">&quot; / &quot;</span> &lt;&lt; f.q()</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot; =~ &quot;</span> &lt;&lt; std::setprecision( 16 ) &lt;&lt; approx &lt;&lt; std::endl;</div>
<div class="line">      number -= int_part;</div>
<div class="line">      <span class="keywordflow">if</span> ( ( (number0 - epsilon ) &lt; approx )</div>
<div class="line">           &amp;&amp; ( approx &lt; (number0 + epsilon ) ) ) <span class="keywordflow">break</span>;</div>
<div class="line">      number = 1.0 / number;</div>
<div class="line">    }</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;z = &quot;</span> &lt;&lt; f.p() &lt;&lt; <span class="stringliteral">&quot; / &quot;</span> &lt;&lt; f.q() &lt;&lt; std::endl;</div>
<div class="ttc" id="astructDGtal_1_1NumberTraitsImpl_html_a0104cb5103fc4596e3fe975a592cc87e"><div class="ttname"><a href="structDGtal_1_1NumberTraitsImpl.html#a0104cb5103fc4596e3fe975a592cc87e">DGtal::NumberTraitsImpl&lt; std::decay&lt; T &gt;::type &gt;::castToInt64_t</a></div><div class="ttdeci">static DGtal::int64_t castToInt64_t(const std::decay&lt; T &gt;::type &amp;aT)</div><div class="ttdoc">Cast method to DGtal::int64_t (for I/O or board export uses only).</div><div class="ttdef"><b>Definition:</b> <a href="NumberTraits_8h_source.html#l00145">NumberTraits.h:145</a></div></div>
<div class="ttc" id="astructDGtal_1_1NumberTraitsImpl_html_af97eb78317d1fc1c6babd4dcc95ed336"><div class="ttname"><a href="structDGtal_1_1NumberTraitsImpl.html#af97eb78317d1fc1c6babd4dcc95ed336">DGtal::NumberTraitsImpl&lt; std::decay&lt; T &gt;::type &gt;::castToDouble</a></div><div class="ttdeci">static double castToDouble(const std::decay&lt; T &gt;::type &amp;aT)</div><div class="ttdoc">Cast method to double (for I/O or board export uses only).</div><div class="ttdef"><b>Definition:</b> <a href="NumberTraits_8h_source.html#l00154">NumberTraits.h:154</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="dgtal_irrfrac_sec3_9"></a>
Standard arithmetic operations '+', '-', '*', '/'</h2>
<p>There are not implemented yet and continued fractions are not the best representation for doing them. Here, you must use numerators and denominators to perform computations with these fractions.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Arithmetic operations will soon be implemented with usual arithmetic operations on numerators and denominators. Furthermore, a dedicated system for performing arithmetic operations using only quotients (and guaranteed O(log(k)) complexity) is also under development.</dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 1 2021 17:06:17 for DGtal by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
