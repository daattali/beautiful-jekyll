<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>DGtal: DGtal Namespace Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">0.5.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">DGtal Namespace Reference<div class="ingroups"><a class="el" href="group__Concepts.html">DGtal Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceDGtal_1_1ConceptUtils"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1ConceptUtils.html">ConceptUtils</a></td></tr>
<tr class="memitem:namespaceDGtal_1_1deprecated"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1deprecated.html">deprecated</a></td></tr>
<tr class="memitem:namespaceDGtal_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1detail.html">detail</a></td></tr>
<tr class="memitem:namespaceDGtal_1_1details"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1details.html">details</a></td></tr>
<tr class="memitem:namespaceDGtal_1_1experimental"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1experimental.html">experimental</a></td></tr>
<tr class="memitem:namespaceDGtal_1_1Z2i"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1Z2i.html">Z2i</a></td></tr>
<tr class="memitem:namespaceDGtal_1_1Z3i"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal_1_1Z3i.html">Z3i</a></td></tr>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CBidirectionalIteratorArchetype.html">CBidirectionalIteratorArchetype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An archetype of BidirectionalIterator.  <a href="structDGtal_1_1CBidirectionalIteratorArchetype.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CConstBidirectionalIteratorArchetype.html">CConstBidirectionalIteratorArchetype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An archetype of ConstBidirectionalIterator.  <a href="structDGtal_1_1CConstBidirectionalIteratorArchetype.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CForwardIteratorArchetype.html">CForwardIteratorArchetype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An archetype of ForwardIterator.  <a href="structDGtal_1_1CForwardIteratorArchetype.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1TrueBoolFct0.html">TrueBoolFct0</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1FalseBoolFct0.html">FalseBoolFct0</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IdentityBoolFct1.html">IdentityBoolFct1</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NotBoolFct1.html">NotBoolFct1</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1AndBoolFct2.html">AndBoolFct2</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1OrBoolFct2.html">OrBoolFct2</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1XorBoolFct2.html">XorBoolFct2</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ImpliesBoolFct2.html">ImpliesBoolFct2</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1MinFunctor.html">MinFunctor</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1MaxFunctor.html">MaxFunctor</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1MinusFunctor.html">MinusFunctor</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1AbsFunctor.html">AbsFunctor</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Bits.html">Bits</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CBackInsertable.html">CBackInsertable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents types for which a std::back_insert_iterator can be constructed with std::back_inserter. Back Insertion Sequence are refinements of <a class="el" href="structDGtal_1_1CBackInsertable.html" title="Aim: Represents types for which a std::back_insert_iterator can be constructed with std::back_inserte...">CBackInsertable</a>. They require more services than <a class="el" href="structDGtal_1_1CBackInsertable.html" title="Aim: Represents types for which a std::back_insert_iterator can be constructed with std::back_inserte...">CBackInsertable</a>, for instance read services or erase services.  <a href="structDGtal_1_1CBackInsertable.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CBidirectionalOutputRange.html">CBidirectionalOutputRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of bidirectional range which require that a reverse output iterator exists.  <a href="structDGtal_1_1CBidirectionalOutputRange.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CBidirectionalOutputRangeFromPoint.html">CBidirectionalOutputRangeFromPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of single pass range with an routputIterator() method from a point.  <a href="structDGtal_1_1CBidirectionalOutputRangeFromPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CBidirectionalRange.html">CBidirectionalRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a bidirectional range.  <a href="structDGtal_1_1CBidirectionalRange.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CBidirectionalRangeFromPoint.html">CBidirectionalRangeFromPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of single pass range with a begin() method from a point.  <a href="structDGtal_1_1CBidirectionalRangeFromPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CConstBidirectionalRange.html">CConstBidirectionalRange</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CConstBidirectionalRangeFromPoint.html">CConstBidirectionalRangeFromPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of const bidirectional range with a begin() method from a point.  <a href="structDGtal_1_1CConstBidirectionalRangeFromPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CConstSinglePassRange.html">CConstSinglePassRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a const range.  <a href="structDGtal_1_1CConstSinglePassRange.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CConstSinglePassRangeFromPoint.html">CConstSinglePassRangeFromPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of const single pass range with a begin() method from a point.  <a href="structDGtal_1_1CConstSinglePassRangeFromPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1forward__circulator__tag.html">forward_circulator_tag</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1bidirectional__circulator__tag.html">bidirectional_circulator_tag</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1random__access__circulator__tag.html">random_access_circulator_tag</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ForwardCategory.html">ForwardCategory</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1BidirectionalCategory.html">BidirectionalCategory</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1RandomAccessCategory.html">RandomAccessCategory</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits.html">IteratorCirculatorTagTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Provides the category of the iterator (resp. circulator) {<a class="el" href="structDGtal_1_1ForwardCategory.html">ForwardCategory</a>,<a class="el" href="structDGtal_1_1BidirectionalCategory.html">BidirectionalCategory</a>,<a class="el" href="structDGtal_1_1RandomAccessCategory.html">RandomAccessCategory</a>} and the type {<a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a>,<a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a>}.  <a href="structDGtal_1_1IteratorCirculatorTagTraits.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits_3_01forward__circulator__tag_01_4.html">IteratorCirculatorTagTraits&lt; forward_circulator_tag &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits_3_01bidirectional__circulator__tag_01_4.html">IteratorCirculatorTagTraits&lt; bidirectional_circulator_tag &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits_3_01random__access__circulator__tag_01_4.html">IteratorCirculatorTagTraits&lt; random_access_circulator_tag &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits_3_01std_1_1forward__iterator__tag_01_4.html">IteratorCirculatorTagTraits&lt; std::forward_iterator_tag &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits_3_01std_1_1bidirectional__iterator__tag_01_4.html">IteratorCirculatorTagTraits&lt; std::bidirectional_iterator_tag &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTagTraits_3_01std_1_1random__access__iterator__tag_01_4.html">IteratorCirculatorTagTraits&lt; std::random_access_iterator_tag &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTraits.html">IteratorCirculatorTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Provides definition types for both iterators and circulators: Type, Category, Value, Difference, Pointer and Reference.  <a href="structDGtal_1_1IteratorCirculatorTraits.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IteratorCirculatorTraits_3_01T_01_5_01_4.html">IteratorCirculatorTraits&lt; T * &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CirculatorTagTraits.html">CirculatorTagTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Transform std::forward_iterator_tag into <a class="el" href="structDGtal_1_1forward__circulator__tag.html">forward_circulator_tag</a> Transform std::bidirectional_iterator_tag into <a class="el" href="structDGtal_1_1bidirectional__circulator__tag.html">bidirectional_circulator_tag</a> Transform std::random_access_iterator_tag into <a class="el" href="structDGtal_1_1random__access__circulator__tag.html">random_access_circulator_tag</a>.  <a href="structDGtal_1_1CirculatorTagTraits.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CirculatorTagTraits_3_01std_1_1forward__iterator__tag_01_4.html">CirculatorTagTraits&lt; std::forward_iterator_tag &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CirculatorTagTraits_3_01std_1_1bidirectional__iterator__tag_01_4.html">CirculatorTagTraits&lt; std::bidirectional_iterator_tag &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CirculatorTagTraits_3_01std_1_1random__access__iterator__tag_01_4.html">CirculatorTagTraits&lt; std::random_access_iterator_tag &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Circulator.html">Circulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Provides an adapter for STL iterators that can iterate through the underlying data structure as in a loop. The increment (resp. decrement if at least bidirectionnal) operator encapsulates the validity test and the assignement to the first (resp. last) iterator of a given range. For instance, the pre-increment operator does:  <a href="classDGtal_1_1Circulator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CLabel.html">CLabel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define the concept of <a class="el" href="namespaceDGtal.html" title="Aim: Defines the concept describing a bidirectional const range.">DGtal</a> labels. Models of <a class="el" href="structDGtal_1_1CLabel.html" title="Aim: Define the concept of DGtal labels. Models of CLabel can be default-constructible, assignable and equality comparable.">CLabel</a> can be default-constructible, assignable and equality comparable.  <a href="structDGtal_1_1CLabel.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Clock.html">Clock</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawableWithDisplay3D.html">DrawableWithDisplay3D</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawableWithBoard2D.html">DrawableWithBoard2D</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1TagFalse.html">TagFalse</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1TagTrue.html">TagTrue</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1TagUnknown.html">TagUnknown</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Negate.html">Negate</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Negate_3_01TagTrue_01_4.html">Negate&lt; TagTrue &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Negate_3_01TagFalse_01_4.html">Negate&lt; TagFalse &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DummyObject.html">DummyObject</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ConstIteratorAdapter.html">ConstIteratorAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class adapts any iterator (at least forward) so that operator* returns another element than the one pointed to by the iterator.  <a href="classDGtal_1_1ConstIteratorAdapter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ConstRangeAdapter.html">ConstRangeAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of <a class="el" href="structDGtal_1_1CConstBidirectionalRange.html">CConstBidirectionalRange</a> that adapts any range of elements bounded by two iterators [itb, ite) and provides services to (circularly)iterate over it (in a read-only manner).  <a href="classDGtal_1_1ConstRangeAdapter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ConstRangeFromPointAdapter.html">ConstRangeFromPointAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of <a class="el" href="structDGtal_1_1CConstBidirectionalRangeFromPoint.html" title="Aim: refined concept of const bidirectional range with a begin() method from a point.">CConstBidirectionalRangeFromPoint</a> that adapts any bidirectional range and provides services to iterate over it (in a read-only manner).  <a href="classDGtal_1_1ConstRangeFromPointAdapter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CountedPtr.html">CountedPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Smart pointer based on reference counts.  <a href="classDGtal_1_1CountedPtr.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CowPtr.html">CowPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Copy on write shared pointer.  <a href="classDGtal_1_1CowPtr.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CPredicate.html">CPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a predicate function, ie. a functor mapping a domain into the set of booleans.  <a href="structDGtal_1_1CPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CQuantity.html">CQuantity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: defines the concept of quantity in <a class="el" href="namespaceDGtal.html" title="Aim: Defines the concept describing a bidirectional const range.">DGtal</a>.  <a href="structDGtal_1_1CQuantity.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSinglePassOutputRange.html">CSinglePassOutputRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of single pass range which require that an output iterator exists.  <a href="structDGtal_1_1CSinglePassOutputRange.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSinglePassOutputRangeFromPoint.html">CSinglePassOutputRangeFromPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of single pass range with a outputIterator() method from a point.  <a href="structDGtal_1_1CSinglePassOutputRangeFromPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSinglePassRange.html">CSinglePassRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a range.  <a href="structDGtal_1_1CSinglePassRange.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSinglePassRangeFromPoint.html">CSinglePassRangeFromPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: refined concept of single pass range with a begin() method from a point.  <a href="structDGtal_1_1CSinglePassRangeFromPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CUnaryFunctor.html">CUnaryFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a unary functor, which associates arguments to results.  <a href="structDGtal_1_1CUnaryFunctor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IOException.html">IOException</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1InputException.html">InputException</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ConnectivityException.html">ConnectivityException</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MemoryException.html">MemoryException</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1InfiniteNumberException.html">InfiniteNumberException</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1POW.html">POW</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1POW_3_01X_00_011_01_4.html">POW&lt; X, 1 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LOG2.html">LOG2</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LOG2_3_012_01_4.html">LOG2&lt; 2 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LOG2_3_011_01_4.html">LOG2&lt; 1 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1InputIteratorWithRankOnSequence.html">InputIteratorWithRankOnSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Useful to create an iterator that returns a pair (value,rank) when visiting a sequence. The sequence is smartly copied within the iterator. Hence, the given sequence need not to persist during the visit. Since it is only an input sequence, it is not necessary to give a valid sequence when creating the end() iterator.  <a href="classDGtal_1_1InputIteratorWithRankOnSequence.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IteratorAdapter.html">IteratorAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class adapts any iterator (at least forward) so that operator* returns a member on the element pointed to by the iterator, instead the element itself.  <a href="classDGtal_1_1IteratorAdapter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1OpInSTLContainers.html">OpInSTLContainers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implementation of an adapter for erase and insert methods of STL containers so that they not only work for the iterator type, but also for the reverse_iterator type.  <a href="structDGtal_1_1OpInSTLContainers.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1OpInSTLContainers_3_01Container_00_01std_1_1reverse__iterator_3_01typename_01Container_1_1iterator_01_4_01_4.html">OpInSTLContainers&lt; Container, std::reverse_iterator&lt; typename Container::iterator &gt; &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1OrderedAlphabet.html">OrderedAlphabet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Describes an alphabet over an interval of (ascii) letters, where the lexicographic order can be changed (shifted, reversed, ...). Useful for the arithmetic minimum length polygon (AMLP).  <a href="classDGtal_1_1OrderedAlphabet.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1OutputIteratorAdapter.html">OutputIteratorAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Adapts an output iterator i with a unary functor f, both given at construction, so that the element pointed to by i is updated with a given value through f.  <a href="classDGtal_1_1OutputIteratorAdapter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SimpleConstRange.html">SimpleConstRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of CConstRange that adapts any range of elements bounded by two iterators [itb, ite) and provides services to (circularly)iterate over it (in a read-only manner).  <a href="classDGtal_1_1SimpleConstRange.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SimpleRandomAccessConstRangeFromPoint.html">SimpleRandomAccessConstRangeFromPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of <a class="el" href="structDGtal_1_1CConstBidirectionalRangeFromPoint.html" title="Aim: refined concept of const bidirectional range with a begin() method from a point.">CConstBidirectionalRangeFromPoint</a> that adapts any range of elements bounded by two iterators [itb, ite) and provides services to (circularly)iterate over it (in a read-only manner).  <a href="classDGtal_1_1SimpleRandomAccessConstRangeFromPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SimpleRandomAccessRangeFromPoint.html">SimpleRandomAccessRangeFromPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of <a class="el" href="structDGtal_1_1CBidirectionalRangeFromPoint.html" title="Aim: refined concept of single pass range with a begin() method from a point.">CBidirectionalRangeFromPoint</a> that adapts any range of elements bounded by two iterators [itb, ite) and provides services to (circularly)iterate over it (in a read-only manner).  <a href="classDGtal_1_1SimpleRandomAccessRangeFromPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Statistic.html">Statistic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class processes a set of sample values for one variable and can then compute different statistics, like sample mean, sample variance, sample unbiased variance, etc. It is minimalistic for space efficiency. For multiple variables, sample storage and others, see Statistics class.  <a href="classDGtal_1_1Statistic.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1StdMapRebinder.html">StdMapRebinder</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Trace.html">Trace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of basic methods to trace out messages with indentation levels.  <a href="classDGtal_1_1Trace.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TraceWriter.html">TraceWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual Class to implement trace writers.  <a href="classDGtal_1_1TraceWriter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TraceWriterFile.html">TraceWriterFile</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TraceWriterTerm.html">TraceWriterTerm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements trace prefix for color terminals.  <a href="classDGtal_1_1TraceWriterTerm.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1BLUELocalLengthEstimator.html">BLUELocalLengthEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Best Linear Unbiased Two step length estimator.  <a href="classDGtal_1_1BLUELocalLengthEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CompareLocalEstimators.html">CompareLocalEstimators</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Functor to compare two local geometric estimators.  <a href="structDGtal_1_1CompareLocalEstimators.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DSSLengthEstimator.html">DSSLengthEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a model of CGlobalCurveEstimator that segments the digital curve into DSS and computes the length of the resulting (not uniquely defined) polygon.  <a href="classDGtal_1_1DSSLengthEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1FPLengthEstimator.html">FPLengthEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a model of CGlobalCurveEstimator that computes the length of a digital curve using its <a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a> (faithful polygon)  <a href="classDGtal_1_1FPLengthEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1L1LengthEstimator.html">L1LengthEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a simple model of CGlobalCurveEstimator that compute the length of a curve using the l_1 metric (just add 1/h for every step).  <a href="classDGtal_1_1L1LengthEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MLPLengthEstimator.html">MLPLengthEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a model of CGlobalCurveEstimator that computes the length of a digital curve using its MLP (given by the <a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a>)  <a href="classDGtal_1_1MLPLengthEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MostCenteredMaximalSegmentEstimator.html">MostCenteredMaximalSegmentEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim:Computes a quantity to each element of a range associated to the most centered maximal segment.  <a href="classDGtal_1_1MostCenteredMaximalSegmentEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ParametricShapeArcLengthFunctor.html">ParametricShapeArcLengthFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements a functor that estimates the arc length of a paramtric curve.  <a href="classDGtal_1_1ParametricShapeArcLengthFunctor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ParametricShapeCurvatureFunctor.html">ParametricShapeCurvatureFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements a functor that computes the curvature at a given point of a parametric shape.  <a href="classDGtal_1_1ParametricShapeCurvatureFunctor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ParametricShapeTangentFunctor.html">ParametricShapeTangentFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements a functor that computes the tangent vector at a given point of a parametric shape.  <a href="classDGtal_1_1ParametricShapeTangentFunctor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1RosenProffittLocalLengthEstimator.html">RosenProffittLocalLengthEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Rosen-Proffitt Length Estimator.  <a href="classDGtal_1_1RosenProffittLocalLengthEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TangentFromDSSFunctor.html">TangentFromDSSFunctor</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TangentAngleFromDSSFunctor.html">TangentAngleFromDSSFunctor</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CurvatureFromDSSLengthFunctor.html">CurvatureFromDSSLengthFunctor</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CurvatureFromDSSFunctor.html">CurvatureFromDSSFunctor</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TrueGlobalEstimatorOnPoints.html">TrueGlobalEstimatorOnPoints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Computes the true quantity to each element of a range associated to a parametric shape.  <a href="classDGtal_1_1TrueGlobalEstimatorOnPoints.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TrueLocalEstimatorOnPoints.html">TrueLocalEstimatorOnPoints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Computes the true quantity to each element of a range associated to a parametric shape.  <a href="classDGtal_1_1TrueLocalEstimatorOnPoints.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1TwoStepLocalLengthEstimator.html">TwoStepLocalLengthEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a simple model of CGlobalCurveEstimator that compute the length of a curve using the l_1 metric (just add 1/h for every step).  <a href="classDGtal_1_1TwoStepLocalLengthEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1BinomialConvolver.html">BinomialConvolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class represents a 2D contour convolved by some binomial. It computes first and second order derivatives so as to be able to estimate tangent and curvature. In particular, it smoothes digital contours but could be used for other kind of contours.  <a href="classDGtal_1_1BinomialConvolver.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1TangentFromBinomialConvolverFunctor.html">TangentFromBinomialConvolverFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is a functor for getting the tangent vector of a binomial convolver.  <a href="structDGtal_1_1TangentFromBinomialConvolverFunctor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CurvatureFromBinomialConvolverFunctor.html">CurvatureFromBinomialConvolverFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is a functor for getting the tangent vector of a binomial convolver.  <a href="structDGtal_1_1CurvatureFromBinomialConvolverFunctor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1BinomialConvolverEstimator.html">BinomialConvolverEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class encapsulates a <a class="el" href="classDGtal_1_1BinomialConvolver.html" title="Aim: This class represents a 2D contour convolved by some binomial. It computes first and second orde...">BinomialConvolver</a> and a functor on <a class="el" href="classDGtal_1_1BinomialConvolver.html" title="Aim: This class represents a 2D contour convolved by some binomial. It computes first and second orde...">BinomialConvolver</a> so as to be a model of CLocalGeometricEstimator.  <a href="classDGtal_1_1BinomialConvolverEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Dynamic recognition of a digital straight segment (DSS) defined as the sequence of simply connected points (x,y) such that mu &lt;= ax - by &lt; mu + omega.  <a href="classDGtal_1_1ArithmeticalDSS.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ArithmeticalDSS3d.html">ArithmeticalDSS3d</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Dynamic recognition of a 3d-digital straight segment (DSS)  <a href="classDGtal_1_1ArithmeticalDSS3d.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html">CBidirectionalSegmentComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a bidirectional segment computer, ie. a model of <a class="el" href="structDGtal_1_1CSegment.html" title="Aim: Defines the concept describing a segment of a range, ie. a valid and not empty subrange...">CSegment</a> that can extend itself in the two possible directions.  <a href="structDGtal_1_1CBidirectionalSegmentComputer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html">CDynamicBidirectionalSegmentComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie. a model of <a class="el" href="structDGtal_1_1CSegment.html" title="Aim: Defines the concept describing a segment of a range, ie. a valid and not empty subrange...">CSegment</a> that can extend and retract itself in either direction.  <a href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDynamicSegmentComputer.html">CDynamicSegmentComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a dynamic segment computer, ie. a model of <a class="el" href="structDGtal_1_1CSegment.html" title="Aim: Defines the concept describing a segment of a range, ie. a valid and not empty subrange...">CSegment</a> that can extend and retract itself (in the direction that is relative to the underlying iterator).  <a href="structDGtal_1_1CDynamicSegmentComputer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CForwardSegmentComputer.html">CForwardSegmentComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a forward segment computer, ie. a model of <a class="el" href="structDGtal_1_1CSegment.html" title="Aim: Defines the concept describing a segment of a range, ie. a valid and not empty subrange...">CSegment</a> that can extend itself (in the direction that is relative to the underlying iterator).  <a href="structDGtal_1_1CForwardSegmentComputer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CombinatorialDSS.html">CombinatorialDSS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim:  <a href="classDGtal_1_1CombinatorialDSS.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSegment.html">CSegment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a segment of a range, ie. a valid and not empty subrange.  <a href="structDGtal_1_1CSegment.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CTrivialSegmentComputer.html">CTrivialSegmentComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing the most trivial segment computer, ie. a model of <a class="el" href="structDGtal_1_1CSegment.html" title="Aim: Defines the concept describing a segment of a range, ie. a valid and not empty subrange...">CSegment</a> that can extend itself.  <a href="structDGtal_1_1CTrivialSegmentComputer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Adapter.html">Adapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: abstract adapter for <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: Dynamic recognition of a digital straight segment (DSS) defined as the sequence of simply connec...">ArithmeticalDSS</a>. Has 2 virtual methods:  <a href="classDGtal_1_1Adapter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Adapter4ConvexPart.html">Adapter4ConvexPart</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: adapter for <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: Dynamic recognition of a digital straight segment (DSS) defined as the sequence of simply connec...">ArithmeticalDSS</a> used by <a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a> in convex parts. Has 2 methods:  <a href="classDGtal_1_1Adapter4ConvexPart.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Adapter4ConcavePart.html">Adapter4ConcavePart</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: adapter for <a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: Dynamic recognition of a digital straight segment (DSS) defined as the sequence of simply connec...">ArithmeticalDSS</a> used by <a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a> in concave parts. Has 2 methods:  <a href="classDGtal_1_1Adapter4ConcavePart.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1FP.html">FP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Computes the faithful polygon (<a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a>) of a range of 4/8-connected 2D Points.  <a href="classDGtal_1_1FP.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1FreemanChain.html">FreemanChain</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1GeometricalDCA.html">GeometricalDCA</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: On-line recognition of a digital circular arcs (DCA) defined as a sequence of connected grid edges such that there is at least one (Euclidean) circle that separates the centers of the two incident pixels of each grid edge.  <a href="classDGtal_1_1GeometricalDCA.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1GeometricalDSS.html">GeometricalDSS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: On-line recognition of a digital straight segment (DSS) defined as a sequence of connected grid edges such that there is at least one straight line that separates the centers of the two incident pixels of each grid edge.  <a href="classDGtal_1_1GeometricalDSS.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1GreedySegmentation.html">GreedySegmentation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Computes the greedy segmentation of a range given by a pair of ConstIterators. The last element of a given segment is the first one one of the next segment.  <a href="classDGtal_1_1GreedySegmentation.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1GridCurve.html">GridCurve</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: describes an alternative sequence of signed 0-cell (pointels) and 1-cell (linels) in any dimension, closed or open. For instance, the topological boundary of a simply connected digital set is a closed grid curve in 2d.  <a href="classDGtal_1_1GridCurve.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SaturatedSegmentation.html">SaturatedSegmentation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Computes the saturated segmentation, that is the whole set of maximal segments within a range given by a pair of ConstIterators (maximal segments are segments that cannot be included in greater segments).  <a href="classDGtal_1_1SaturatedSegmentation.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">ForwardSegmentComputer</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">BidirectionalSegmentComputer</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DynamicSegmentComputer</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DynamicBidirectionalSegmentComputer</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SegmentComputerTraits.html">SegmentComputerTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Provides the category of the segment computer {<a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">ForwardSegmentComputer</a>,<a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">BidirectionalSegmentComputer</a>, <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DynamicSegmentComputer</a>, <a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DynamicBidirectionalSegmentComputer</a>}.  <a href="structDGtal_1_1SegmentComputerTraits.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ContourHelper.html">ContourHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a helper class to process sequences of points.  <a href="classDGtal_1_1ContourHelper.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ConstantConvolutionWeights.html">ConstantConvolutionWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implement a trivial constant convolution kernel which returns 1 to each distance.  <a href="classDGtal_1_1ConstantConvolutionWeights.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1GaussianConvolutionWeights.html">GaussianConvolutionWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implement a Gaussian centered convolution kernel.  <a href="classDGtal_1_1GaussianConvolutionWeights.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CConvolutionWeights.html">CConvolutionWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: defines models of centered convolution kernel used for normal vector integration for instance.  <a href="structDGtal_1_1CConvolutionWeights.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CNormalVectorEstimator.html">CNormalVectorEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents the concept of estimator of normal vector along digital surfaces.  <a href="structDGtal_1_1CNormalVectorEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSurfaceEmbedderWithNormalVectorEstimator.html">DigitalSurfaceEmbedderWithNormalVectorEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Combines a digital surface embedder with a normal vector estimator to get a model of <a class="el" href="structDGtal_1_1CDigitalSurfaceEmbedder.html" title="Aim: A digital surface embedder is a specialized mapping from signed cells to Euclidean points...">CDigitalSurfaceEmbedder</a> and <a class="el" href="structDGtal_1_1CWithGradientMap.html" title="Aim: Such object provides a gradient map that associates to each argument some real vector...">CWithGradientMap</a>. (also default constructible, copy constructible, assignable).  <a href="classDGtal_1_1DigitalSurfaceEmbedderWithNormalVectorEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSurfaceEmbedderWithNormalVectorEstimatorGradientMap.html">DigitalSurfaceEmbedderWithNormalVectorEstimatorGradientMap</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LocalConvolutionNormalVectorEstimator.html">LocalConvolutionNormalVectorEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Computes the normal vector at a surface element by convolution of elementary normal vector to adjacent surfel.  <a href="classDGtal_1_1LocalConvolutionNormalVectorEstimator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1NormalVectorEstimatorLinearCellEmbedder.html">NormalVectorEstimatorLinearCellEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of cellular embedder for normal vector estimators on digital surface, (default constructible, copy constructible, assignable).  <a href="classDGtal_1_1NormalVectorEstimatorLinearCellEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Preimage2D.html">Preimage2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Computes the preimage of the 2D Euclidean shapes crossing a sequence of n straigth segments in O(n), with the algorithm of O'Rourke (1981).  <a href="classDGtal_1_1Preimage2D.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSeparableMetric.html">CSeparableMetric</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DistanceTransformation.html">DistanceTransformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implementation of the linear in time distance transformation.  <a href="classDGtal_1_1DistanceTransformation.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1FMM.html">FMM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Fast Marching Method (<a class="el" href="classDGtal_1_1FMM.html" title="Aim: Fast Marching Method (FMM) for nd distance transforms.">FMM</a>) for nd distance transforms.  <a href="classDGtal_1_1FMM.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1L2FirstOrderLocalDistance.html">L2FirstOrderLocalDistance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Class for the computation of the Euclidean distance at some point p, from the available distance values of some points lying in the 1-neighborhood of p (ie. points at a L1-distance to p equal to 1).  <a href="classDGtal_1_1L2FirstOrderLocalDistance.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1L2SecondOrderLocalDistance.html">L2SecondOrderLocalDistance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Class for the computation of the Euclidean distance at some point p, from the available distance values of some points lying in the neighborhood of p, such that only one of their coordinate differ from the coordinates of p by at most two.  <a href="classDGtal_1_1L2SecondOrderLocalDistance.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LInfLocalDistance.html">LInfLocalDistance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Class for the computation of the LInf-distance at some point p, from the available distance values of some points lying in the 1-neighborhood of p (ie. points at a L1-distance to p equal to 1).  <a href="classDGtal_1_1LInfLocalDistance.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1L1LocalDistance.html">L1LocalDistance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Class for the computation of the L1-distance at some point p, from the available distance values of some points lying in the 1-neighborhood of p (ie. points at a L1-distance to p equal to 1).  <a href="classDGtal_1_1L1LocalDistance.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1L2FirstOrderLocalDistanceFromCells.html">L2FirstOrderLocalDistanceFromCells</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Class for the computation of the Euclidean distance at some point p, from the available distance values in the neighborhood of p. Contrary to <a class="el" href="classDGtal_1_1L2FirstOrderLocalDistance.html" title="Aim: Class for the computation of the Euclidean distance at some point p, from the available distance...">L2FirstOrderLocalDistance</a>, the distance values are not available from the points adjacent to p but instead from the (d-1)-cells lying between p and these points.  <a href="classDGtal_1_1L2FirstOrderLocalDistanceFromCells.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SpeedExtrapolator.html">SpeedExtrapolator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Class for the computation of the a speed value at some point p, from the available distance values and speed values of some points lying in the 1-neighborhood of p (ie. points at a L1-distance to p equal to 1) in order to extrapolate a speed field in the normal direction to the interface.  <a href="classDGtal_1_1SpeedExtrapolator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ReverseDistanceTransformation.html">ReverseDistanceTransformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implementation of the linear in time reverse distance transformation.  <a href="classDGtal_1_1ReverseDistanceTransformation.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SeparableMetricHelper.html">SeparableMetricHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implements basic functions associated to metrics used by separable volumetric algorithms.  <a href="structDGtal_1_1SeparableMetricHelper.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SeparableMetricHelper_3_01TAbscissa_00_01TInternalValue_00_012_01_4.html">SeparableMetricHelper&lt; TAbscissa, TInternalValue, 2 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SeparableMetricHelper_3_01TAbscissa_00_01TInternalValue_00_011_01_4.html">SeparableMetricHelper&lt; TAbscissa, TInternalValue, 1 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SeparableMetricHelper_3_01TAbscissa_00_01TInternalValue_00_010_01_4.html">SeparableMetricHelper&lt; TAbscissa, TInternalValue, 0 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Measure.html">Measure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implements a simple measure computation (in the Lesbegue sens) of a set. In dimension 2, it corresponds to the area of the set, to the volume in dimension 3,...  <a href="classDGtal_1_1Measure.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CConstImage.html">CConstImage</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CImage.html">CImage</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ConstImageAdapter.html">ConstImageAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements a model of <a class="el" href="structDGtal_1_1CConstImage.html">CConstImage</a> that adapts an underlying image.  <a href="classDGtal_1_1ConstImageAdapter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CTrivialConstImage.html">CTrivialConstImage</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CTrivialImage.html">CTrivialImage</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DefaultConstImageRange.html">DefaultConstImageRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of <a class="el" href="structDGtal_1_1CConstBidirectionalRangeFromPoint.html" title="Aim: refined concept of const bidirectional range with a begin() method from a point.">CConstBidirectionalRangeFromPoint</a> that adapts the domain of an image in order to iterate over the values associated to its domain points (in a read-only as well as a write-only manner).  <a href="classDGtal_1_1DefaultConstImageRange.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DefaultImageRange.html">DefaultImageRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of <a class="el" href="structDGtal_1_1CConstBidirectionalRangeFromPoint.html" title="Aim: refined concept of const bidirectional range with a begin() method from a point.">CConstBidirectionalRangeFromPoint</a> and <a class="el" href="structDGtal_1_1CBidirectionalOutputRangeFromPoint.html" title="Aim: refined concept of single pass range with an routputIterator() method from a point...">CBidirectionalOutputRangeFromPoint</a> that adapts the domain of an image in order to iterate over the values associated to its domain points (in a read-only as well as a write-only manner).  <a href="classDGtal_1_1DefaultImageRange.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Image.html">Image</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements association bewteen points lying in a digital domain and values.  <a href="classDGtal_1_1Image.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImageContainerByHashTree.html">ImageContainerByHashTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Model of CImageContainer implementing the association key&lt;-&gt;Value using a hash tree. This class provides a built-in iterator.  <a href="classDGtal_1_1ImageContainerByHashTree.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DistanceFunctorFromPoint.html">DistanceFunctorFromPoint</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImageLinearCellEmbedder.html">ImageLinearCellEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a cellular embedder for images. (default constructible, copy constructible, assignable). Model of <a class="el" href="structDGtal_1_1CCellEmbedder.html" title="Aim: A cell embedder is a mapping from unsigned cells to Euclidean points. It adds inner types to fun...">CCellEmbedder</a>.  <a href="classDGtal_1_1ImageLinearCellEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ImageSelector.html">ImageSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Automatically defines an adequate image type according to the hints given by the user.  <a href="structDGtal_1_1ImageSelector.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ImageSelector_3_01Domain_00_01Value_00_01LOW__ITER__I_09LOW__BEL__I_01_4.html">ImageSelector&lt; Domain, Value, LOW_ITER_I+LOW_BEL_I &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ImageFromSet.html">ImageFromSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define utilities to convert a digital set into an image.  <a href="structDGtal_1_1ImageFromSet.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IntervalForegroundPredicate.html">IntervalForegroundPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define a simple Foreground predicate thresholding image values between two constant values.  <a href="classDGtal_1_1IntervalForegroundPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SetFromImage.html">SetFromImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define utilities to convert a digital set into an image.  <a href="structDGtal_1_1SetFromImage.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SimpleThresholdForegroundPredicate.html">SimpleThresholdForegroundPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Define a simple Foreground predicate thresholding image values given a single thresold. More precisely, the functor operator() returns true if the value is greater than a given threshold.  <a href="classDGtal_1_1SimpleThresholdForegroundPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Morton.html">Morton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implements the binary <a class="el" href="classDGtal_1_1Morton.html" title="Aim: Implements the binary Morton code construction in nD.">Morton</a> code construction in nD.  <a href="classDGtal_1_1Morton.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SetValueIterator.html">SetValueIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements an output iterator, which is able to write values in an underlying image, by calling its setValue method.  <a href="classDGtal_1_1SetValueIterator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Board2D.html">Board2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class specializes a 'Board' class so as to display <a class="el" href="namespaceDGtal.html" title="Aim: Defines the concept describing a bidirectional const range.">DGtal</a> objects more naturally (with &lt;&lt;). The user has simply to declare a <a class="el" href="classDGtal_1_1Board2D.html" title="Aim: This class specializes a &#39;Board&#39; class so as to display DGtal objects more naturally (with &lt;&lt;)...">Board2D</a> object and uses stream operators to display most digital objects. Furthermore, one can use this class to modify the current style for drawing.  <a href="classDGtal_1_1Board2D.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawWithBoardModifier.html">DrawWithBoardModifier</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CustomStyle.html">CustomStyle</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SetMode.html">SetMode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifier class in a <a class="el" href="classDGtal_1_1Board2D.html" title="Aim: This class specializes a &#39;Board&#39; class so as to display DGtal objects more naturally (with &lt;&lt;)...">Board2D</a> stream. Useful to choose your own mode for a given class. Realizes the concept <a class="el" href="structDGtal_1_1CDrawableWithBoard2D.html">CDrawableWithBoard2D</a>.  <a href="structDGtal_1_1SetMode.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CustomColors.html">CustomColors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom style class redefining the pen color and the fill color. You may use Board2D::Color::None for transparent color.  <a href="structDGtal_1_1CustomColors.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CustomPenColor.html">CustomPenColor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom style class redefining the pen color. You may use Board2D::Color::None for transparent color.  <a href="structDGtal_1_1CustomPenColor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CustomFillColor.html">CustomFillColor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom style class redefining the fill color. You may use Board2D::Color::None for transparent color.  <a href="structDGtal_1_1CustomFillColor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CustomPen.html">CustomPen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom style class redefining the pen attributes. You may use Board2D::Color::None for transparent color.  <a href="structDGtal_1_1CustomPen.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Board3DTo2D.html">Board3DTo2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for PDF, PNG, PS, EPS, SVG export drawings with Cairo with 3D-&gt;2D projection.  <a href="classDGtal_1_1Board3DTo2D.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDrawableWithBoard2D.html">CDrawableWithBoard2D</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDrawableWithDisplay3D.html">CDrawableWithDisplay3D</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Color.html">Color</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing an RGB triple.  <a href="classDGtal_1_1Color.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CColorMap.html">CColorMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a color map. A color map converts a value within a given range into an RGB triple.  <a href="structDGtal_1_1CColorMap.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ColorBrightnessColorMap.html">ColorBrightnessColorMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class template may be used to (linearly) convert scalar values in a given range into a color with given lightness.  <a href="classDGtal_1_1ColorBrightnessColorMap.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1GradientColorMap.html">GradientColorMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class template may be used to (linearly) convert scalar values in a given range into a color in a gradient defined by two or more colors.  <a href="classDGtal_1_1GradientColorMap.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1GrayscaleColorMap.html">GrayscaleColorMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class template may be used to (linearly) convert scalar values in a given range into gray levels.  <a href="classDGtal_1_1GrayscaleColorMap.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1HueShadeColorMap.html">HueShadeColorMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class template may be used to (linearly) convert scalar values in a given range into a color in a <em>cyclic</em> hue shade colormap, maybe aka rainbow color map. This color map is suitable, for example, to colorize distance functions. By default, only one hue cycle is used.  <a href="classDGtal_1_1HueShadeColorMap.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1RandomColorMap.html">RandomColorMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: access to random color from a gradientColorMap.  <a href="classDGtal_1_1RandomColorMap.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Display3D.html">Display3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like <a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes.">PointVector</a>, <a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html" title="Aim: A container class for storing sets of digital points within some given domain.">DigitalSetBySTLSet</a>, <a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a> ...). The class <a class="el" href="classDGtal_1_1Viewer3D.html" title="Aim: Display 3D primitive (like PointVector, DigitalSetBySTLSet, Object ...). This class uses the lib...">Viewer3D</a> and <a class="el" href="classDGtal_1_1Board3DTo2D.html" title="Class for PDF, PNG, PS, EPS, SVG export drawings with Cairo with 3D-&gt;2D projection.">Board3DTo2D</a> implement two different ways to display 3D objects. The first one (<a class="el" href="classDGtal_1_1Viewer3D.html" title="Aim: Display 3D primitive (like PointVector, DigitalSetBySTLSet, Object ...). This class uses the lib...">Viewer3D</a>), permits an interactive visualisation (based on  OpenGL ) and the second one (<a class="el" href="classDGtal_1_1Board3DTo2D.html" title="Class for PDF, PNG, PS, EPS, SVG export drawings with Cairo with 3D-&gt;2D projection.">Board3DTo2D</a>) provides 3D visualisation from 2D vectorial display (based on the CAIRO library)  <a href="classDGtal_1_1Display3D.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Display3DFactory.html">Display3DFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for GPL <a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like PointVector...">Display3D</a>:  <a href="structDGtal_1_1Display3DFactory.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DrawWithDisplay3DModifier.html">DrawWithDisplay3DModifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class specifying the methods for classes which intend to modify a <a class="el" href="classDGtal_1_1Viewer3D.html" title="Aim: Display 3D primitive (like PointVector, DigitalSetBySTLSet, Object ...). This class uses the lib...">Viewer3D</a> stream.  <a href="structDGtal_1_1DrawWithDisplay3DModifier.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SetMode3D.html">SetMode3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifier class in a <a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like PointVector...">Display3D</a> stream. Useful to choose your own mode for a given class. Realizes the concept <a class="el" href="structDGtal_1_1CDrawableWithDisplay3D.html">CDrawableWithDisplay3D</a>.  <a href="structDGtal_1_1SetMode3D.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CustomStyle3D.html">CustomStyle3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifier class in a <a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like PointVector...">Display3D</a> stream. Useful to choose your own style for a given class. Realizes the concept <a class="el" href="structDGtal_1_1CDrawableWithDisplay3D.html">CDrawableWithDisplay3D</a>.  <a href="structDGtal_1_1CustomStyle3D.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CustomColors3D.html">CustomColors3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom style class redefining the fill color and the gl_LINE/gl_POINT color. You can use <a class="el" href="classDGtal_1_1Color.html" title="Structure representing an RGB triple.">DGtal::Color</a> with alpha transparency value but you nedd to take into account the z-buffer during the Open-GL based rendering.  <a href="structDGtal_1_1CustomColors3D.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ClippingPlane.html">ClippingPlane</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for adding a Clipping plane through the <a class="el" href="classDGtal_1_1Viewer3D.html" title="Aim: Display 3D primitive (like PointVector, DigitalSetBySTLSet, Object ...). This class uses the lib...">Viewer3D</a> stream. Realizes the concept CDrawableWithViewer3D.  <a href="structDGtal_1_1ClippingPlane.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CameraPosition.html">CameraPosition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structDGtal_1_1CameraPosition.html" title="CameraPosition class to set camera position.">CameraPosition</a> class to set camera position.  <a href="structDGtal_1_1CameraPosition.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CameraDirection.html">CameraDirection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structDGtal_1_1CameraDirection.html" title="CameraDirection class to set camera direction.">CameraDirection</a> class to set camera direction.  <a href="structDGtal_1_1CameraDirection.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CameraUpVector.html">CameraUpVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structDGtal_1_1CameraUpVector.html" title="CameraUpVector class to set camera up-vector.">CameraUpVector</a> class to set camera up-vector.  <a href="structDGtal_1_1CameraUpVector.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CameraZNearFar.html">CameraZNearFar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structDGtal_1_1CameraZNearFar.html" title="CameraZNearFar class to set near and far distance.">CameraZNearFar</a> class to set near and far distance.  <a href="structDGtal_1_1CameraZNearFar.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1LongvolReader.html">LongvolReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements methods to read a "Longvol" file format (with <a class="el" href="namespaceDGtal.html#ab33c0c25b8cc3cd86de343bca34329f5" title="unsigned 64-bit integer.">DGtal::uint64_t</a> value type).  <a href="structDGtal_1_1LongvolReader.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1MagickReader.html">MagickReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements methods to read a 2D image using the ImageMagick library.  <a href="structDGtal_1_1MagickReader.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1PNMReader.html">PNMReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Import a 2D or 3D using the Netpbm formats (ASCII mode).  <a href="structDGtal_1_1PNMReader.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1PointListReader.html">PointListReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implements method to read a set of points represented in each line of a file.  <a href="structDGtal_1_1PointListReader.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1RawReader.html">RawReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements methods to read a "Vol" file format.  <a href="structDGtal_1_1RawReader.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1VolReader.html">VolReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: implements methods to read a "Vol" file format.  <a href="structDGtal_1_1VolReader.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyleCircular__AngleLinearMinimizer.html">DefaultDrawStyleCircular_AngleLinearMinimizer</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyleBB__ArithmeticalDSS.html">DefaultDrawStyleBB_ArithmeticalDSS</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStylePoints__ArithmeticalDSS.html">DefaultDrawStylePoints_ArithmeticalDSS</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyle__DigitalSetBySTLSet.html">DefaultDrawStyle_DigitalSetBySTLSet</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyle__DigitalSetBySTLVector.html">DefaultDrawStyle_DigitalSetBySTLVector</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyle__FP.html">DefaultDrawStyle_FP</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyleGrid__FreemanChain.html">DefaultDrawStyleGrid_FreemanChain</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyleInterGrid__FreemanChain.html">DefaultDrawStyleInterGrid_FreemanChain</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyle__GeometricalDSS.html">DefaultDrawStyle_GeometricalDSS</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyle__GeometricalDCA.html">DefaultDrawStyle_GeometricalDCA</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStylePaving__HyperRectDomain.html">DefaultDrawStylePaving_HyperRectDomain</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyleGrid__HyperRectDomain.html">DefaultDrawStyleGrid_HyperRectDomain</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyle__ImageContainerByHashTree.html">DefaultDrawStyle_ImageContainerByHashTree</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyle__ImageContainerBySTLVector.html">DefaultDrawStyle_ImageContainerBySTLVector</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyle__KhalimskyCell.html">DefaultDrawStyle_KhalimskyCell</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyle__Object.html">DefaultDrawStyle_Object</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStylePaving__PointVector.html">DefaultDrawStylePaving_PointVector</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyleGrid__PointVector.html">DefaultDrawStyleGrid_PointVector</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DefaultDrawStyle__SignedKhalimskyCell.html">DefaultDrawStyle_SignedKhalimskyCell</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DGtalInventor.html">DGtalInventor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A stream object based on Open Inventor for exporting or displaying <a class="el" href="namespaceDGtal.html" title="Aim: Defines the concept describing a bidirectional const range.">DGtal</a> objects.  <a href="classDGtal_1_1DGtalInventor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IVViewer.html">IVViewer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A facade to represent an inventor window for 3D objects. May be a SoXt or a SoQt examiner viewer. NB: backported from ImaGeneUtils library.  <a href="classDGtal_1_1IVViewer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Lattice.html">Lattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents an n-dimensional integer lattice in an m-dimensional real vector space.  <a href="classDGtal_1_1Lattice.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Viewer3D.html">Viewer3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Display 3D primitive (like <a class="el" href="classDGtal_1_1PointVector.html" title="Aim: Implements basic operations that will be used in Point and Vector classes.">PointVector</a>, <a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html" title="Aim: A container class for storing sets of digital points within some given domain.">DigitalSetBySTLSet</a>, <a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a> ...). This class uses the libQGLViewer library (<a href="http://www.libqglviewer.com">http://www.libqglviewer.com </a>). It inherits of the class <a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like PointVector...">Display3D</a> and permits to display object using a simple stream mechanism of "&lt;&lt;".  <a href="classDGtal_1_1Viewer3D.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1LongvolWriter.html">LongvolWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Export a 3D <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a> using the Longvol formats (volumetric image with <a class="el" href="namespaceDGtal.html#ab33c0c25b8cc3cd86de343bca34329f5" title="unsigned 64-bit integer.">DGtal::uint64_t</a> value type).  <a href="structDGtal_1_1LongvolWriter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1PNMWriter.html">PNMWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Export a 2D and a 3D <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a> using the Netpbm formats (ASCII mode).  <a href="structDGtal_1_1PNMWriter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1RawWriter.html">RawWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Raw binary export of an <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a>.  <a href="structDGtal_1_1RawWriter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1VolWriter.html">VolWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Export a 3D <a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a> using the Vol formats.  <a href="structDGtal_1_1VolWriter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Projector.html">Projector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Functor that maps a point P of dimension i to a point Q of dimension j. The member <em>myDims</em> is an array containing the coordinates - (0, 1, ..., j-1) by default - that are copied from P to Q.  <a href="structDGtal_1_1Projector.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ConstantPointPredicate.html">ConstantPointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate that returns always the same value boolCst.  <a href="structDGtal_1_1ConstantPointPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1TruePointPredicate.html">TruePointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate that returns always true.  <a href="structDGtal_1_1TruePointPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1FalsePointPredicate.html">FalsePointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate that returns always false.  <a href="structDGtal_1_1FalsePointPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IsLowerPointPredicate.html">IsLowerPointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returns true when the point is below (or equal) the given upper bound.  <a href="structDGtal_1_1IsLowerPointPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IsUpperPointPredicate.html">IsUpperPointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returns true when the point is above (or equal) the given lower bound.  <a href="structDGtal_1_1IsUpperPointPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1IsWithinPointPredicate.html">IsWithinPointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returns true when the point is within the given bounds.  <a href="structDGtal_1_1IsWithinPointPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NotPointPredicate.html">NotPointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returns true when the point predicate given at construction return false. Thus inverse a predicate: NOT operator.  <a href="structDGtal_1_1NotPointPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1EqualPointPredicate.html">EqualPointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returns true when the point given as argument equals the reference point given at construction.  <a href="structDGtal_1_1EqualPointPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1BinaryPointPredicate.html">BinaryPointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returns true when the given binary functor returns true for the two PointPredicates given at construction.  <a href="structDGtal_1_1BinaryPointPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1PointFunctorPredicate.html">PointFunctorPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returns true when the predicate returns true for the value assigned to a given point in the point functor.  <a href="structDGtal_1_1PointFunctorPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CanonicCellEmbedder.html">CanonicCellEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A trivial embedder for unsigned cell, which corresponds to the canonic injection of cell centroids into Rn.  <a href="structDGtal_1_1CanonicCellEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CanonicDigitalSurfaceEmbedder.html">CanonicDigitalSurfaceEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A trivial embedder for digital surfaces, which corresponds to the canonic injection of cell centroids into Rn.  <a href="structDGtal_1_1CanonicDigitalSurfaceEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CanonicEmbedder.html">CanonicEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A trivial embedder for digital points, which corresponds to the canonic injection of Zn into Rn.  <a href="structDGtal_1_1CanonicEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CanonicSCellEmbedder.html">CanonicSCellEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A trivial embedder for signed cell, which corresponds to the canonic injection of cell centroids into Rn.  <a href="structDGtal_1_1CanonicSCellEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CBoundedInteger.html">CBoundedInteger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The concept <a class="el" href="structDGtal_1_1CBoundedInteger.html" title="Aim: The concept CBoundedInteger specifies what are the bounded integer numbers. Hence, it is a refinement of CInteger Concept ensuring that the numbers are bounded.">CBoundedInteger</a> specifies what are the bounded integer numbers. Hence, it is a refinement of <a class="el" href="structDGtal_1_1CInteger.html" title="Aim: The concept CInteger specifies what are the usual integer numbers, more precisely the ones that ...">CInteger</a> Concept ensuring that the numbers are bounded.  <a href="structDGtal_1_1CBoundedInteger.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CCommutativeRing.html">CCommutativeRing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the mathematical concept equivalent to a unitary commutative ring.  <a href="structDGtal_1_1CCommutativeRing.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CEuclideanRing.html">CEuclideanRing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the mathematical concept equivalent to a unitary commutative ring with a division operator.  <a href="structDGtal_1_1CEuclideanRing.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CInteger.html">CInteger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The concept <a class="el" href="structDGtal_1_1CInteger.html" title="Aim: The concept CInteger specifies what are the usual integer numbers, more precisely the ones that ...">CInteger</a> specifies what are the usual integer numbers, more precisely the ones that are representable on a computer.  <a href="structDGtal_1_1CInteger.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CPointEmbedder.html">CPointEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A point embedder is a mapping from digital points to Euclidean points. It adds inner types to functor.  <a href="structDGtal_1_1CPointEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CPointFunctor.html">CPointFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a functor on points.  <a href="structDGtal_1_1CPointFunctor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CPointPredicate.html">CPointPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a predicate on a point.  <a href="structDGtal_1_1CPointPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSignedInteger.html">CSignedInteger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Concept checking for Signed Integer.  <a href="structDGtal_1_1CSignedInteger.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSpace.html">CSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines the concept describing a digital space, ie a cartesian product of integer lines.  <a href="structDGtal_1_1CSpace.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CUnsignedInteger.html">CUnsignedInteger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Concept checking for Unsigned Integer.  <a href="structDGtal_1_1CUnsignedInteger.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CWithGradientMap.html">CWithGradientMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Such object provides a gradient map that associates to each argument some real vector.  <a href="structDGtal_1_1CWithGradientMap.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDomain.html">CDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept represents a digital domain, i.e. a non mutable subset of points of the given digital space.  <a href="structDGtal_1_1CDomain.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CDomainArchetype.html">CDomainArchetype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The archetype of a class that represents a digital domain, i.e. a non mutable subset of points of the given digital space.  <a href="classDGtal_1_1CDomainArchetype.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DomainPredicate.html">DomainPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returning true iff the point is in the domain given at construction. It is just a wrapper class around the methods Domain::isInside( const Point &amp; ), where <code>Domain</code> stands for any model of <a class="el" href="structDGtal_1_1CDomain.html" title="Aim: This concept represents a digital domain, i.e. a non mutable subset of points of the given digit...">CDomain</a>.  <a href="structDGtal_1_1DomainPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1HyperRectDomain.html">HyperRectDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Parallelepidec region of a digital space, model of a '<a class="el" href="structDGtal_1_1CDomain.html" title="Aim: This concept represents a digital domain, i.e. a non mutable subset of points of the given digit...">CDomain</a>'.  <a href="classDGtal_1_1HyperRectDomain.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1HyperRectDomain__Iterator.html">HyperRectDomain_Iterator</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1HyperRectDomain__subIterator.html">HyperRectDomain_subIterator</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1LinearAlgebra.html">LinearAlgebra</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A utility class that contains methods to perform integral linear algebra.  <a href="structDGtal_1_1LinearAlgebra.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits.html">NumberTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The traits class for all models of Cinteger.  <a href="structDGtal_1_1NumberTraits.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01uint16__t_01_4.html">NumberTraits&lt; uint16_t &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01int16__t_01_4.html">NumberTraits&lt; int16_t &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01uint8__t_01_4.html">NumberTraits&lt; uint8_t &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01int8__t_01_4.html">NumberTraits&lt; int8_t &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01uint32__t_01_4.html">NumberTraits&lt; uint32_t &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01int32__t_01_4.html">NumberTraits&lt; int32_t &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01uint64__t_01_4.html">NumberTraits&lt; uint64_t &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01int64__t_01_4.html">NumberTraits&lt; int64_t &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01float_01_4.html">NumberTraits&lt; float &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01double_01_4.html">NumberTraits&lt; double &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1NumberTraits_3_01long_01double_01_4.html">NumberTraits&lt; long double &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Warning__promote__trait__not__specialized__for__this__case.html">Warning_promote_trait_not_specialized_for_this_case</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1promote__trait.html">promote_trait</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1promote__trait_3_01int32__t_00_01int64__t_01_4.html">promote_trait&lt; int32_t, int64_t &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1PointVector.html">PointVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Implements basic operations that will be used in Point and Vector classes.  <a href="classDGtal_1_1PointVector.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1RegularPointEmbedder.html">RegularPointEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A simple point embedder where grid steps are given for each axis. Note that the real point (0,...,0) is mapped onto the digital point (0,...,0).  <a href="classDGtal_1_1RegularPointEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDigitalSet.html">CDigitalSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a set of points within the given domain. This set of points is modifiable by the user.  <a href="structDGtal_1_1CDigitalSet.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CDigitalSetArchetype.html">CDigitalSetArchetype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The archetype of a container class for storing sets of digital points within some given domain.  <a href="classDGtal_1_1CDigitalSetArchetype.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html">DigitalSetBySTLSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A container class for storing sets of digital points within some given domain.  <a href="classDGtal_1_1DigitalSetBySTLSet.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSetBySTLVector.html">DigitalSetBySTLVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Realizes the concept <a class="el" href="structDGtal_1_1CDigitalSet.html" title="Aim: Represents a set of points within the given domain. This set of points is modifiable by the user...">CDigitalSet</a> by using the STL container std::vector.  <a href="classDGtal_1_1DigitalSetBySTLVector.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DigitalSetConverter.html">DigitalSetConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Utility class to convert between types of sets.  <a href="structDGtal_1_1DigitalSetConverter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSetDomain.html">DigitalSetDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Constructs a domain limited to the given digital set.  <a href="classDGtal_1_1DigitalSetDomain.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSetFromMap.html">DigitalSetFromMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: An adapter for viewing an associative image container like <a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a> as a simple digital set. This class is merely based on an aliasing pointer on the image, which must exists elsewhere.  <a href="classDGtal_1_1DigitalSetFromMap.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSetInserter.html">DigitalSetInserter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: this output iterator class is designed to allow algorithms to insert points in the digital set. Using the assignment operator, even when dereferenced, causes the digital set to insert a point.  <a href="classDGtal_1_1DigitalSetInserter.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DigitalSetSelector.html">DigitalSetSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Automatically defines an adequate digital set type according to the hints given by the user.  <a href="structDGtal_1_1DigitalSetSelector.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DigitalSetSelector_3_01Domain_00_01SMALL__DS_09LOW__VAR__DS_09LOW__ITER__DS_09LOW__BEL__DS_01_4.html">DigitalSetSelector&lt; Domain, SMALL_DS+LOW_VAR_DS+LOW_ITER_DS+LOW_BEL_DS &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1DigitalSetSelector_3_01Domain_00_01SMALL__DS_09LOW__VAR__DS_09HIGH__ITER__DS_09LOW__BEL__DS_01_4.html">DigitalSetSelector&lt; Domain, SMALL_DS+LOW_VAR_DS+HIGH_ITER_DS+LOW_BEL_DS &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SetPredicate.html">SetPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returning true iff the point is in the domain given at construction.  <a href="structDGtal_1_1SetPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SpaceND.html">SpaceND</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: <a class="el" href="classDGtal_1_1SpaceND.html" title="Aim: SpaceND is a utility class that defines the fundamental structure of a Digital Space in ND...">SpaceND</a> is a utility class that defines the fundamental structure of a Digital Space in ND.  <a href="classDGtal_1_1SpaceND.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1AngleComputer.html">AngleComputer</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1AngleLinearMinimizer.html">AngleLinearMinimizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Used to minimize the angle variation between different angles while taking into accounts min and max constraints. Example (.  <a href="classDGtal_1_1AngleLinearMinimizer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1AngleLinearMinimizerByRelaxation.html">AngleLinearMinimizerByRelaxation</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1AngleLinearMinimizerByGradientDescent.html">AngleLinearMinimizerByGradientDescent</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1AngleLinearMinimizerByAdaptiveStepGradientDescent.html">AngleLinearMinimizerByAdaptiveStepGradientDescent</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CPositiveIrreducibleFraction.html">CPositiveIrreducibleFraction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines positive irreducible fractions, i.e. fraction p/q, p and q non-negative integers, with gcd(p,q)=1.  <a href="structDGtal_1_1CPositiveIrreducibleFraction.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IntegerComputer.html">IntegerComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class gathers several types and methods to make computation with integers.  <a href="classDGtal_1_1IntegerComputer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LighterSternBrocot.html">LighterSternBrocot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The Stern-Brocot tree is the tree of irreducible fractions. This class allows to construct it progressively and to navigate within fractions in O(1) time for most operations. It is well known that the structure of this tree is a coding of the continued fraction representation of fractions.  <a href="classDGtal_1_1LighterSternBrocot.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LightSternBrocot.html">LightSternBrocot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The Stern-Brocot tree is the tree of irreducible fractions. This class allows to construct it progressively and to navigate within fractions in O(1) time for most operations. It is well known that the structure of this tree is a coding of the continued fraction representation of fractions.  <a href="classDGtal_1_1LightSternBrocot.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ModuloComputer.html">ModuloComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implements basic functions on modular arithmetic.  <a href="classDGtal_1_1ModuloComputer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Pattern.html">Pattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class represents a pattern, i.e. the path between two consecutive upper leaning points on a digital straight line.  <a href="classDGtal_1_1Pattern.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1StandardDSLQ0.html">StandardDSLQ0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a digital straight line with slope in the first quadrant (Q0: x &gt;= 0, y &gt;= 0 ).  <a href="classDGtal_1_1StandardDSLQ0.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SternBrocot.html">SternBrocot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The Stern-Brocot tree is the tree of irreducible fractions. This class allows to construct it progressively and to navigate within fractions in O(1) time for most operations. It is well known that the structure of this tree is a coding of the continued fraction representation of fractions.  <a href="classDGtal_1_1SternBrocot.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MeasureOfStraightLines.html">MeasureOfStraightLines</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The aim of this class is to compute the measure in the Lebesgues sense of the set of straight lines associated to domains defined as polygons in the (a,b)-parameter space. This parameter space maps the line $ax-y+b=0$ to the point $(a,b)$.  <a href="classDGtal_1_1MeasureOfStraightLines.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomialEvaluatorImpl_3_011_00_01TRing_00_01TOwner_00_01TAlloc_00_01TX_01_4.html">MPolynomialEvaluatorImpl&lt; 1, TRing, TOwner, TAlloc, TX &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomialEvaluatorImpl.html">MPolynomialEvaluatorImpl</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomialEvaluator_3_011_00_01TRing_00_01TAlloc_00_01TX_01_4.html">MPolynomialEvaluator&lt; 1, TRing, TAlloc, TX &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomialEvaluator.html">MPolynomialEvaluator</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomial_3_010_00_01TRing_00_01TAlloc_01_4.html">MPolynomial&lt; 0, TRing, TAlloc &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Specialization of <a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial</a> for degree 0.  <a href="classDGtal_1_1MPolynomial_3_010_00_01TRing_00_01TAlloc_01_4.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IVector.html">IVector</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1IVector_3_01T_00_01TAlloc_00_01true_01_4.html">IVector&lt; T, TAlloc, true &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a multivariate polynomial, i.e. an element of <img class="formulaInl" alt="$ K[X_0, ..., X_{n-1}] $" src="form_70.png"/>, where <em>K</em> is some ring or field.  <a href="classDGtal_1_1MPolynomial.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Xe__kComputer.html">Xe_kComputer</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Xe__kComputer_3_010_00_01Ring_00_01Alloc_01_4.html">Xe_kComputer&lt; 0, Ring, Alloc &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomialDerivativeComputer_3_010_00_01n_00_01Ring_00_01Alloc_01_4.html">MPolynomialDerivativeComputer&lt; 0, n, Ring, Alloc &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomialDerivativeComputer.html">MPolynomialDerivativeComputer</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomialDerivativeComputer_3_010_00_010_00_01Ring_00_01Alloc_01_4.html">MPolynomialDerivativeComputer&lt; 0, 0, Ring, Alloc &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MPolynomialDerivativeComputer_3_01N_00_010_00_01Ring_00_01Alloc_01_4.html">MPolynomialDerivativeComputer&lt; N, 0, Ring, Alloc &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SignalData.html">SignalData</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Signal.html">Signal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a discrete signal, periodic or not. The signal can be passed by value since it is only cloned when modified.  <a href="classDGtal_1_1Signal.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDigitalBoundedShape.html">CDigitalBoundedShape</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDigitalOrientedShape.html">CDigitalOrientedShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: characterizes models of digital oriented shapes. For example, models should provide an orientation method for points on a <a class="el" href="classDGtal_1_1SpaceND.html" title="Aim: SpaceND is a utility class that defines the fundamental structure of a Digital Space in ND...">SpaceND</a>. Returned value type corresponds to <a class="el" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41">DGtal::Orientation</a>.  <a href="structDGtal_1_1CDigitalOrientedShape.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CEuclideanBoundedShape.html">CEuclideanBoundedShape</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CEuclideanOrientedShape.html">CEuclideanOrientedShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: characterizes models of digital oriented shapes. For example, models should provide an orientation method for real points. Returned value type corresponds to <a class="el" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41">DGtal::Orientation</a>.  <a href="structDGtal_1_1CEuclideanOrientedShape.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CircleFrom2Points.html">CircleFrom2Points</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a circle that passes through a given point and that is thus uniquely defined by two other points. It is able to return for any given point its signed distance to itself.  <a href="classDGtal_1_1CircleFrom2Points.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CircleFrom3Points.html">CircleFrom3Points</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a circle uniquely defined by three 2D points and that is able to return for any given 2D point its signed distance to itself.  <a href="classDGtal_1_1CircleFrom3Points.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Point2ShapePredicate.html">Point2ShapePredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Predicate returning 'true' iff a given point is in the 'interior' of a given shape, 'false' otherwise.  <a href="classDGtal_1_1Point2ShapePredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Point2ShapePredicateComparator.html">Point2ShapePredicateComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A small struct with an operator that compares two values according to two bool template parameters.  <a href="structDGtal_1_1Point2ShapePredicateComparator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Point2ShapePredicateComparator_3_01T_00_01false_00_01false_01_4.html">Point2ShapePredicateComparator&lt; T, false, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A small struct with an operator that compares two values (&lt;).  <a href="structDGtal_1_1Point2ShapePredicateComparator_3_01T_00_01false_00_01false_01_4.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Point2ShapePredicateComparator_3_01T_00_01false_00_01true_01_4.html">Point2ShapePredicateComparator&lt; T, false, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A small struct with an operator that compares two values (&lt;=).  <a href="structDGtal_1_1Point2ShapePredicateComparator_3_01T_00_01false_00_01true_01_4.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Point2ShapePredicateComparator_3_01T_00_01true_00_01false_01_4.html">Point2ShapePredicateComparator&lt; T, true, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A small struct with an operator that compares two values (&gt;).  <a href="structDGtal_1_1Point2ShapePredicateComparator_3_01T_00_01true_00_01false_01_4.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1Point2ShapePredicateComparator_3_01T_00_01true_00_01true_01_4.html">Point2ShapePredicateComparator&lt; T, true, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A small struct with an operator that compares two values (&gt;=).  <a href="structDGtal_1_1Point2ShapePredicateComparator_3_01T_00_01true_00_01true_01_4.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1StraightLineFrom2Points.html">StraightLineFrom2Points</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a straight line uniquely defined by two 2D points and that is able to return for any given 2D point its signed distance to itself.  <a href="classDGtal_1_1StraightLineFrom2Points.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1GaussDigitizer.html">GaussDigitizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A class for computing the Gauss digitization of some Euclidean shape, i.e. its intersection with some <img class="formulaInl" alt="$ h_1 Z \times h_2 Z \times \cdots \times h_n Z $" src="form_76.png"/>. Note that the real point (0,...,0) is mapped onto the digital point (0,...,0).  <a href="classDGtal_1_1GaussDigitizer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CImplicitFunction.html">CImplicitFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Describes any function of the form f(x), where x is some real point in the given space, and f(x) is some value.  <a href="structDGtal_1_1CImplicitFunction.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CImplicitFunctionDiff1.html">CImplicitFunctionDiff1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Describes a 1-differentiable function of the form f(x), where x is some real point in the given space, and f(x) is some value.  <a href="structDGtal_1_1CImplicitFunctionDiff1.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitBall.html">ImplicitBall</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of <a class="el" href="structDGtal_1_1CEuclideanOrientedShape.html" title="Aim: characterizes models of digital oriented shapes. For example, models should provide an orientati...">CEuclideanOrientedShape</a> and <a class="el" href="structDGtal_1_1CEuclideanBoundedShape.html">CEuclideanBoundedShape</a> concepts to create a ball in nD..  <a href="classDGtal_1_1ImplicitBall.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitFunctionDiff1LinearCellEmbedder.html">ImplicitFunctionDiff1LinearCellEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a cellular embedder for implicit functions, (default constructible, copy constructible, assignable). Model of <a class="el" href="structDGtal_1_1CCellEmbedder.html" title="Aim: A cell embedder is a mapping from unsigned cells to Euclidean points. It adds inner types to fun...">CCellEmbedder</a> and <a class="el" href="structDGtal_1_1CWithGradientMap.html" title="Aim: Such object provides a gradient map that associates to each argument some real vector...">CWithGradientMap</a>.  <a href="classDGtal_1_1ImplicitFunctionDiff1LinearCellEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ImplicitFunctionDiff1LinearCellEmbedderGradientMap.html">ImplicitFunctionDiff1LinearCellEmbedderGradientMap</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitFunctionLinearCellEmbedder.html">ImplicitFunctionLinearCellEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: a cellular embedder for implicit functions, (default constructible, copy constructible, assignable). Model of <a class="el" href="structDGtal_1_1CCellEmbedder.html" title="Aim: A cell embedder is a mapping from unsigned cells to Euclidean points. It adds inner types to fun...">CCellEmbedder</a>.  <a href="classDGtal_1_1ImplicitFunctionLinearCellEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitHyperCube.html">ImplicitHyperCube</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of <a class="el" href="structDGtal_1_1CEuclideanOrientedShape.html" title="Aim: characterizes models of digital oriented shapes. For example, models should provide an orientati...">CEuclideanOrientedShape</a> and <a class="el" href="structDGtal_1_1CEuclideanBoundedShape.html">CEuclideanBoundedShape</a> concepts to create an hypercube in nD..  <a href="classDGtal_1_1ImplicitHyperCube.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitNorm1Ball.html">ImplicitNorm1Ball</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of <a class="el" href="structDGtal_1_1CEuclideanOrientedShape.html" title="Aim: characterizes models of digital oriented shapes. For example, models should provide an orientati...">CEuclideanOrientedShape</a> and <a class="el" href="structDGtal_1_1CEuclideanBoundedShape.html">CEuclideanBoundedShape</a> concepts to create a ball for the L_1 norm in nD.  <a href="classDGtal_1_1ImplicitNorm1Ball.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitPolynomial3Shape.html">ImplicitPolynomial3Shape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of <a class="el" href="structDGtal_1_1CEuclideanOrientedShape.html" title="Aim: characterizes models of digital oriented shapes. For example, models should provide an orientati...">CEuclideanOrientedShape</a> concepts to create a shape from a polynomial.  <a href="classDGtal_1_1ImplicitPolynomial3Shape.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitRoundedHyperCube.html">ImplicitRoundedHyperCube</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: model of <a class="el" href="structDGtal_1_1CEuclideanOrientedShape.html" title="Aim: characterizes models of digital oriented shapes. For example, models should provide an orientati...">CEuclideanOrientedShape</a> and <a class="el" href="structDGtal_1_1CEuclideanBoundedShape.html">CEuclideanBoundedShape</a> concepts to create a rounded hypercube in nD..  <a href="classDGtal_1_1ImplicitRoundedHyperCube.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1AccFlower2D.html">AccFlower2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Model of the concept StarShaped represents any accelerated flower in the plane.  <a href="classDGtal_1_1AccFlower2D.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Ball2D.html">Ball2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Model of the concept StarShaped represents any circle in the plane.  <a href="classDGtal_1_1Ball2D.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Ellipse2D.html">Ellipse2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Model of the concept StarShaped represents any ellipse in the plane.  <a href="classDGtal_1_1Ellipse2D.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Flower2D.html">Flower2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Model of the concept StarShaped represents any flower with k-petals in the plane.  <a href="classDGtal_1_1Flower2D.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1NGon2D.html">NGon2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Model of the concept StarShaped represents any regular k-gon in the plane.  <a href="classDGtal_1_1NGon2D.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1StarShaped2D.html">StarShaped2D</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Shapes.html">Shapes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A utility class for constructing different shapes (balls, diamonds, and others).  <a href="classDGtal_1_1Shapes.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1BreadthFirstVisitor.html">BreadthFirstVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is useful to perform a breadth-first exploration of a graph given a starting point or set (called initial core).  <a href="classDGtal_1_1BreadthFirstVisitor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CAdjacency.html">CAdjacency</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The concept <a class="el" href="structDGtal_1_1CAdjacency.html" title="Aim: The concept CAdjacency defines an elementary adjacency relation between points of a digital spac...">CAdjacency</a> defines an elementary adjacency relation between points of a digital space.  <a href="structDGtal_1_1CAdjacency.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CCellEmbedder.html">CCellEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A cell embedder is a mapping from unsigned cells to Euclidean points. It adds inner types to functor.  <a href="structDGtal_1_1CCellEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CCellularGridSpaceND.html">CCellularGridSpaceND</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This concept describes a cellular grid space in nD. In these spaces obtained by cartesian product, cells have a cubic shape that depends on the dimension: 0-cells are points, 1-cells are unit segments, 2-cells are squares, 3-cells are cubes, and so on.  <a href="structDGtal_1_1CCellularGridSpaceND.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDigitalSurfaceContainer.html">CDigitalSurfaceContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim:  <a href="structDGtal_1_1CDigitalSurfaceContainer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDigitalSurfaceEmbedder.html">CDigitalSurfaceEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A digital surface embedder is a specialized mapping from signed cells to Euclidean points. It adds inner types to functor as well as a method to access the digital surface.  <a href="structDGtal_1_1CDigitalSurfaceEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDigitalSurfaceTracker.html">CDigitalSurfaceTracker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim:  <a href="structDGtal_1_1CDigitalSurfaceTracker.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CDomainAdjacency.html">CDomainAdjacency</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Refines the concept <a class="el" href="structDGtal_1_1CAdjacency.html" title="Aim: The concept CAdjacency defines an elementary adjacency relation between points of a digital spac...">CAdjacency</a> by telling that the adjacency is specific to a given domain of the embedding digital space.  <a href="structDGtal_1_1CDomainAdjacency.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSCellEmbedder.html">CSCellEmbedder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A cell embedder is a mapping from signed cells to Euclidean points. It adds inner types to functor.  <a href="structDGtal_1_1CSCellEmbedder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CSurfelPredicate.html">CSurfelPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a predicate on a surfel.  <a href="structDGtal_1_1CSurfelPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CUndirectedSimpleGraph.html">CUndirectedSimpleGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents the concept of local graph: each vertex has neighboring vertices, but we do not necessarily know all the vertices.  <a href="structDGtal_1_1CUndirectedSimpleGraph.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CUndirectedSimpleLocalGraph.html">CUndirectedSimpleLocalGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents the concept of local graph: each vertex has neighboring vertices, but we do not necessarily know all the vertices.  <a href="structDGtal_1_1CUndirectedSimpleLocalGraph.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1CVertexPredicate.html">CVertexPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Defines a predicate on a vertex.  <a href="structDGtal_1_1CVertexPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSetBoundary.html">DigitalSetBoundary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A model of <a class="el" href="structDGtal_1_1CDigitalSurfaceContainer.html" title="Aim:">CDigitalSurfaceContainer</a> which defines the digital surface as the boundary of a given digital set.  <a href="classDGtal_1_1DigitalSetBoundary.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSurface.html">DigitalSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cells. Therefore, a digital surface is a pure cubical complex (model of CCubicalComplex), made of k-cells, 0 &lt;= k &lt; n. This complex is generally not a manifold (i.e. a kind of surface), except when it has the property of being well-composed.  <a href="classDGtal_1_1DigitalSurface.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalSurface2DSlice.html">DigitalSurface2DSlice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a 2-dimensional slice in a <a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>. In a sense, it is a 4-connected contour, open or not. To be valid, it must be connected to some digital surface and a starting surfel.  <a href="classDGtal_1_1DigitalSurface2DSlice.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DigitalTopology.html">DigitalTopology</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represents a digital topology as a couple of adjacency relations.  <a href="classDGtal_1_1DigitalTopology.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1DomainAdjacency.html">DomainAdjacency</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Given a domain and an adjacency, limits the given adjacency to the specified domain for all adjacency and neighborhood computations.  <a href="classDGtal_1_1DomainAdjacency.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Expander.html">Expander</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is useful to visit an object by adjacencies, layer by layer.  <a href="classDGtal_1_1Expander.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html">ExplicitDigitalSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A model of <a class="el" href="structDGtal_1_1CDigitalSurfaceContainer.html" title="Aim:">CDigitalSurfaceContainer</a> which defines the digital surface as connected surfels. The shape is determined by a predicate telling whether a given surfel belongs or not to the shape boundary. Compute once the boundary of the surface with a tracking.  <a href="classDGtal_1_1ExplicitDigitalSurface.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1BoundaryPredicate.html">BoundaryPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate on surfels that represents the frontier between a region and its complementary in an image. It can be used with <a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">ExplicitDigitalSurface</a> or <a class="el" href="classDGtal_1_1LightExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">LightExplicitDigitalSurface</a> so as to define a digital surface. Such surfaces may of course be open.  <a href="classDGtal_1_1BoundaryPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1FrontierPredicate.html">FrontierPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate on surfels that represents the frontier between two regions in an image. It can be used with <a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">ExplicitDigitalSurface</a> or <a class="el" href="classDGtal_1_1LightExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">LightExplicitDigitalSurface</a> so as to define a digital surface. Such surfaces may of course be open.  <a href="classDGtal_1_1FrontierPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A utility class for constructing surfaces (i.e. set of (n-1)-cells).  <a href="classDGtal_1_1Surfaces.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1ImplicitDigitalSurface.html">ImplicitDigitalSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A model of <a class="el" href="structDGtal_1_1CDigitalSurfaceContainer.html" title="Aim:">CDigitalSurfaceContainer</a> which defines the digital surface as the boundary of an implicitly define shape. Compute once the boundary of the surface with a tracking.  <a href="classDGtal_1_1ImplicitDigitalSurface.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1KhalimskyCell.html">KhalimskyCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an (unsigned) cell in a cellular grid space by its Khalimsky coordinates.  <a href="structDGtal_1_1KhalimskyCell.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SignedKhalimskyCell.html">SignedKhalimskyCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a signed cell in a cellular grid space by its Khalimsky coordinates and a boolean value.  <a href="structDGtal_1_1SignedKhalimskyCell.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1CellDirectionIterator.html">CellDirectionIterator</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1KhalimskySpaceND.html">KhalimskySpaceND</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This class is a model of <a class="el" href="structDGtal_1_1CCellularGridSpaceND.html" title="Aim: This concept describes a cellular grid space in nD. In these spaces obtained by cartesian produc...">CCellularGridSpaceND</a>. It represents the cubical grid as a cell complex, whose cells are defined as an array of integers. The topology of the cells is defined by the parity of the coordinates (even: closed, odd: open).  <a href="classDGtal_1_1KhalimskySpaceND.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LightExplicitDigitalSurface.html">LightExplicitDigitalSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A model of <a class="el" href="structDGtal_1_1CDigitalSurfaceContainer.html" title="Aim:">CDigitalSurfaceContainer</a> which defines the digital surface as connected surfels. The shape is determined by a predicate telling whether a given surfel belongs or not to the shape boundary. The whole boundary is not precomputed nor stored. You may use an iterator to visit it.  <a href="classDGtal_1_1LightExplicitDigitalSurface.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1LightImplicitDigitalSurface.html">LightImplicitDigitalSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A model of <a class="el" href="structDGtal_1_1CDigitalSurfaceContainer.html" title="Aim:">CDigitalSurfaceContainer</a> which defines the digital surface as the boundary of an implicitly define shape. The whole boundary is not precomputed nor stored. You may use an iterator to visit it.  <a href="classDGtal_1_1LightImplicitDigitalSurface.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MetricAdjacency.html">MetricAdjacency</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Describes digital adjacencies in digital spaces that are defined with the 1-norm and the infinity-norm.  <a href="classDGtal_1_1MetricAdjacency.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MetricAdjacency_3_01TSpace_00_012_00_012_01_4.html">MetricAdjacency&lt; TSpace, 2, 2 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1MetricAdjacency_3_01TSpace_00_011_00_012_01_4.html">MetricAdjacency&lt; TSpace, 1, 2 &gt;</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Object.html">Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: An object (or digital object) represents a set in some digital space associated with a digital topology.  <a href="classDGtal_1_1Object.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SCellToPoint.html">SCellToPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a scell into a point.  <a href="classDGtal_1_1SCellToPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SCellToMidPoint.html">SCellToMidPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a scell into a real point (the coordinates are divided by 2)  <a href="classDGtal_1_1SCellToMidPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SCellToArrow.html">SCellToArrow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a signed cell into an arrow, ie. a pair point-vector.  <a href="classDGtal_1_1SCellToArrow.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SCellToInnerPoint.html">SCellToInnerPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a signed cell c into a point corresponding to the signed cell of greater dimension that is indirectly incident to c.  <a href="classDGtal_1_1SCellToInnerPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SCellToOuterPoint.html">SCellToOuterPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a signed cell c into a point corresponding to the signed cell of greater dimension that is directly incident to c.  <a href="classDGtal_1_1SCellToOuterPoint.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SCellToIncidentPoints.html">SCellToIncidentPoints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a signed cell c into a pair of points corresponding to the signed cells of greater dimension that are indirectly and directly incident to c.  <a href="classDGtal_1_1SCellToIncidentPoints.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SCellToCode.html">SCellToCode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: transforms a 2d signed cell, basically a linel, into a code (0,1,2 or 3),.  <a href="classDGtal_1_1SCellToCode.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SetOfSurfels.html">SetOfSurfels</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: A model of <a class="el" href="structDGtal_1_1CDigitalSurfaceContainer.html" title="Aim:">CDigitalSurfaceContainer</a> which defines the digital surface as connected surfels. The shape is determined by the set of surfels that composed the surface. The set of surfels is stored in this container.  <a href="classDGtal_1_1SetOfSurfels.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Represent adjacencies between surfel elements, telling if it follows an interior to exterior ordering or exterior to interior ordering. It allows tracking of boundaries and of surfaces.  <a href="classDGtal_1_1SurfelAdjacency.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1SurfelNeighborhood.html">SurfelNeighborhood</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: This helper class is useful to compute the neighboring surfels of a given surfel, especially over a digital surface or over an object boundary. Two signed surfels are incident if they share a common n-2 cell. This class uses a <a class="el" href="classDGtal_1_1SurfelAdjacency.html" title="Aim: Represent adjacencies between surfel elements, telling if it follows an interior to exterior ord...">SurfelAdjacency</a> so as to determine adjacent surfels (either looking for them from interior to exterior or inversely).  <a href="classDGtal_1_1SurfelNeighborhood.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1SurfelSetPredicate.html">SurfelSetPredicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: The predicate returning true iff the point is in the domain given at construction.  <a href="structDGtal_1_1SurfelSetPredicate.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1UmbrellaComputer.html">UmbrellaComputer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aim: Useful for computing umbrellas on '<a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>'s, ie set of n-1 cells around a n-3 cell.  <a href="classDGtal_1_1UmbrellaComputer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDGtal_1_1ImplicitDigitalEllipse3.html">ImplicitDigitalEllipse3</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a40f198468aea6d0121b11cd49e599e92"><td class="memItemLeft" align="right" valign="top">typedef boost::function0&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a40f198468aea6d0121b11cd49e599e92">BoolFunction0</a></td></tr>
<tr class="memitem:a9a92f37472d9010932be3fe6d28f94cb"><td class="memItemLeft" align="right" valign="top">typedef boost::function1&lt; bool, <br class="typebreak"/>
bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9a92f37472d9010932be3fe6d28f94cb">BoolFunction1</a></td></tr>
<tr class="memitem:a7d57d4419aa9656ae4be838f903b5dd2"><td class="memItemLeft" align="right" valign="top">typedef boost::function2&lt; bool, <br class="typebreak"/>
bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">BoolFunction2</a></td></tr>
<tr class="memitem:a1bbf050f10f3c666dc5e170e893d8e57"><td class="memItemLeft" align="right" valign="top">typedef boost::function3&lt; bool, <br class="typebreak"/>
bool, bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1bbf050f10f3c666dc5e170e893d8e57">BoolFunction3</a></td></tr>
<tr class="memitem:a3f01c0f785c605d021be8e328180f502"><td class="memItemLeft" align="right" valign="top">typedef boost::uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3f01c0f785c605d021be8e328180f502">uint8_t</a></td></tr>
<tr class="memitem:a30f912c6a9d587320495d627df2719ba"><td class="memItemLeft" align="right" valign="top">typedef boost::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a30f912c6a9d587320495d627df2719ba">uint16_t</a></td></tr>
<tr class="memitem:a27c59126488e9c545120667959d2fc4e"><td class="memItemLeft" align="right" valign="top">typedef boost::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a27c59126488e9c545120667959d2fc4e">uint32_t</a></td></tr>
<tr class="memitem:ab33c0c25b8cc3cd86de343bca34329f5"><td class="memItemLeft" align="right" valign="top">typedef boost::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab33c0c25b8cc3cd86de343bca34329f5">uint64_t</a></td></tr>
<tr class="memitem:ac28d51e0b1672afa52b3c218a32a6a01"><td class="memItemLeft" align="right" valign="top">typedef boost::int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac28d51e0b1672afa52b3c218a32a6a01">int8_t</a></td></tr>
<tr class="memitem:ac62de8348789e05494b7515c6525baa0"><td class="memItemLeft" align="right" valign="top">typedef boost::int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac62de8348789e05494b7515c6525baa0">int16_t</a></td></tr>
<tr class="memitem:ac1e9ac6a329319ae13c51c0c9e92486a"><td class="memItemLeft" align="right" valign="top">typedef boost::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac1e9ac6a329319ae13c51c0c9e92486a">int32_t</a></td></tr>
<tr class="memitem:a1c09e3f63904ff371f1b99f45069fc63"><td class="memItemLeft" align="right" valign="top">typedef boost::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63">int64_t</a></td></tr>
<tr class="memitem:a8fbe8c8d47ca5c36ced14284ac62613d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespaceDGtal.html#a27c59126488e9c545120667959d2fc4e">DGtal::uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9f6cc75dc44e45506a66cd233e0deb41"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41">Orientation</a> { <a class="el" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41a528af0eaf947edc94796219523aa9553">INSIDE</a> =  0, 
<a class="el" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41a7671a5416d92f37137f9999ca23dd65e">ON</a> =  1, 
<a class="el" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41a5f4bdeccc29812b7de1cc0c05b724734">OUTSIDE</a> =  2
 }</td></tr>
<tr class="memitem:a7f3384cac6dea91b4d46cc1421854dda"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7f3384cac6dea91b4d46cc1421854dda">ImageIterability</a> { <a class="el" href="namespaceDGtal.html#a7f3384cac6dea91b4d46cc1421854ddaacf7975d858b926cba1cc047885d1765c">HIGH_ITER_IMAGE</a> =  0, 
<a class="el" href="namespaceDGtal.html#a7f3384cac6dea91b4d46cc1421854ddaa66f45381ecc834daac482ee3493a79f7">LOW_ITER_I</a> =  1
 }</td></tr>
<tr class="memitem:afbda75b83fdb9094d0e38931838c8d6a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afbda75b83fdb9094d0e38931838c8d6a">ImageBelongTestability</a> { <a class="el" href="namespaceDGtal.html#afbda75b83fdb9094d0e38931838c8d6aa3417447f6aa436ccbf37e0c359adac12">HIGH_BEL_I</a> =  0, 
<a class="el" href="namespaceDGtal.html#afbda75b83fdb9094d0e38931838c8d6aa5bb4ca524cc66ff98e8b4ad4b4138630">LOW_BEL_I</a> =  2
 }</td></tr>
<tr class="memitem:a0a142484d2c7efc3d29f5bbde3b449b7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0a142484d2c7efc3d29f5bbde3b449b7">ImageSpecificContainer</a> { <a class="el" href="namespaceDGtal.html#a0a142484d2c7efc3d29f5bbde3b449b7a0a9f2a6126427332825d75e775f59388">NORMAL_CONTAINER_I</a> =  0, 
<a class="el" href="namespaceDGtal.html#a0a142484d2c7efc3d29f5bbde3b449b7ad4deed74c04fa5f801b7c2638d536c1d">VTKIMAGEDATA_CONTAINER_I</a> =  4
 }</td></tr>
<tr class="memitem:a2526218ffac7b4842d393facbedd9ee3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2526218ffac7b4842d393facbedd9ee3">DomainDrawMode</a> { <a class="el" href="namespaceDGtal.html#a2526218ffac7b4842d393facbedd9ee3a6cfb206d9d6225066329a79e83db654e">GRID</a> =  0, 
<a class="el" href="namespaceDGtal.html#a2526218ffac7b4842d393facbedd9ee3ad788351651a8e983ca1b5b30861ad8ba">PAVING</a> =  1
 }</td></tr>
<tr class="memitem:aa68309838cffd86a3c671c44ef129cb2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2">ColorGradientPreset</a> { <br/>
&#160;&#160;<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a97a652eb81107a63d65d0d091f48e320">CMAP_CUSTOM</a> =  0, 
<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a03f20e9e057e38ce03220e2a43b1a366">CMAP_GRAYSCALE</a>, 
<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2ad222787b0de6a7d74f0e403da496266c">CMAP_SPRING</a>, 
<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2aa5b0ef9d5b1e2e496ac149d9a42dd3e7">CMAP_SUMMER</a>, 
<br/>
&#160;&#160;<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a3ff3c09197871bad3bb5921e30223533">CMAP_AUTUMN</a>, 
<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2acd0da059abca1decd6b75ecc6d131be7">CMAP_WINTER</a>, 
<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a40d9e19d8fbedda0f45c0673c6c6dcbf">CMAP_COOL</a>, 
<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a2b8eab305f63590e49a6dab0b628ae33">CMAP_COPPER</a>, 
<br/>
&#160;&#160;<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a075659185495ce61ea5b09ab439e2abe">CMAP_HOT</a>, 
<a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2ac677c31e4299bc29c4e591063b4fc9bb">CMAP_JET</a>
<br/>
 }</td></tr>
<tr class="memitem:a65228f031a436d2f4edd698ae733ba31"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31">BoundEnum</a> { <a class="el" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31a4b4e195031215bcfc63b5bf65c1c1035">BOUNDED</a> =  0, 
<a class="el" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31a1906bfa4ce33f3c129b1e974826f686d">UNBOUNDED</a> =  1, 
<a class="el" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31aec51247a223f33a421840eb3cbd5598e">BOUND_UNKNOWN</a> =  2
 }</td></tr>
<tr class="memitem:a679e16b34aad98ff340decf89d1c86db"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86db">SignEnum</a> { <a class="el" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86dbae3e0717ad611faed845dd64931b1f99c">SIGNED</a> =  0, 
<a class="el" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86dba4e5cd9a9d62617341034f3f1c0f79b32">UNSIGNED</a> =  1, 
<a class="el" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86dba23888a413fb400a53deeb0b0e17d3100">SIGN_UNKNOWN</a> =  2
 }</td></tr>
<tr class="memitem:a07a2f5d6c861cd13dd680ea2e64e2dd4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4">DigitalSetSize</a> { <a class="el" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4acf48b00343e26a7f40a1fdbbc7af4d70">SMALL_DS</a> =  0, 
<a class="el" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4a0df10d7a38d07b6795da39a66cbe97cc">MEDIUM_DS</a> =  1, 
<a class="el" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4a37af4f429983b8069af58a2334f776a0">BIG_DS</a> =  2, 
<a class="el" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4ac6f14eff3712732f6fa6d608f11e79fe">WHOLE_DS</a> =  3
 }</td></tr>
<tr class="memitem:ae37267b68e31ee8f7531488f7e88426a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae37267b68e31ee8f7531488f7e88426a">DigitalSetVariability</a> { <a class="el" href="namespaceDGtal.html#ae37267b68e31ee8f7531488f7e88426aa453acc6bba092ef2476618fad08d47f3">LOW_VAR_DS</a> =  0, 
<a class="el" href="namespaceDGtal.html#ae37267b68e31ee8f7531488f7e88426aabef0d75c93891808eaa54c78aa08484a">HIGH_VAR_DS</a> =  4
 }</td></tr>
<tr class="memitem:abae5017e6f3a3d5e0c4debd8142e8ccc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abae5017e6f3a3d5e0c4debd8142e8ccc">DigitalSetIterability</a> { <a class="el" href="namespaceDGtal.html#abae5017e6f3a3d5e0c4debd8142e8ccca73f1c02534747463a70f05e94ad50b3d">LOW_ITER_DS</a> =  0, 
<a class="el" href="namespaceDGtal.html#abae5017e6f3a3d5e0c4debd8142e8ccca0f85b8033e1532f5c4a0ff3d59a187bc">HIGH_ITER_DS</a> =  8
 }</td></tr>
<tr class="memitem:a0f37e197740e9d7742426109610c513a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0f37e197740e9d7742426109610c513a">DigitalSetBelongTestability</a> { <a class="el" href="namespaceDGtal.html#a0f37e197740e9d7742426109610c513aac54bafeace89b71100756e99a7ef368e">LOW_BEL_DS</a> =  0, 
<a class="el" href="namespaceDGtal.html#a0f37e197740e9d7742426109610c513aadcca3a30244180b4238a80ae3a06e01d">HIGH_BEL_DS</a> =  16
 }</td></tr>
<tr class="memitem:a9f57dcd68d3056024eec6b4205f7083d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083d">DigitalTopologyProperties</a> { <a class="el" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083dabce62ac78855e24784c74bdd7d8e4e88">UNKNOWN_DT</a> =  0, 
<a class="el" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083da76d2c48b4a35a0dcb5ca4e6cf2462ff0">NOT_JORDAN_DT</a> =  1, 
<a class="el" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083da731ee8276af4e05e2fe322cf2a4fd179">JORDAN_DT</a> =  2
 }</td></tr>
<tr class="memitem:a5df441c76f46779791d077a80f0b902e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5df441c76f46779791d077a80f0b902e">Connectedness</a> { <a class="el" href="namespaceDGtal.html#a5df441c76f46779791d077a80f0b902ea3188ed38ab448384424887958f44beea">DISCONNECTED</a> =  0, 
<a class="el" href="namespaceDGtal.html#a5df441c76f46779791d077a80f0b902ea71b8166fccee5ea03cd61a4a9b3ece1a">CONNECTED</a> =  1, 
<a class="el" href="namespaceDGtal.html#a5df441c76f46779791d077a80f0b902ea01966050c6ac7ceb9818c946cd229fc4">UNKNOWN</a> =  2
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6b49e997d09ccb163eb82529e8970996"><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr class="memitem:a6b49e997d09ccb163eb82529e8970996"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6b49e997d09ccb163eb82529e8970996">isEmpty</a> (const IC &amp;itb, const IC &amp;ite)</td></tr>
<tr class="memitem:a6f1b22211474c60437654c3a0decb8ef"><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr class="memitem:a6f1b22211474c60437654c3a0decb8ef"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6f1b22211474c60437654c3a0decb8ef">isNotEmpty</a> (const IC &amp;itb, const IC &amp;ite)</td></tr>
<tr class="memitem:ac4d5198d8a044649b47cf6ccecf43549"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac4d5198d8a044649b47cf6ccecf43549">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Clock.html">Clock</a> &amp;object)</td></tr>
<tr class="memitem:a700746047887dc625f6d85e5c4923ae1"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TFunctor , typename TReturnType &gt; </td></tr>
<tr class="memitem:a700746047887dc625f6d85e5c4923ae1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1ConstIteratorAdapter.html">ConstIteratorAdapter</a><br class="typebreak"/>
&lt; TIterator, TFunctor, <br class="typebreak"/>
TReturnType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a700746047887dc625f6d85e5c4923ae1">operator+</a> (typename <a class="el" href="structDGtal_1_1IteratorCirculatorTraits.html">IteratorCirculatorTraits</a>&lt; TIterator &gt;::Difference d, <a class="el" href="classDGtal_1_1ConstIteratorAdapter.html">ConstIteratorAdapter</a>&lt; TIterator, TFunctor, TReturnType &gt; &amp;object)</td></tr>
<tr class="memitem:aa5ad29732984e904acf8a15b5f36f391"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa5ad29732984e904acf8a15b5f36f391"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa5ad29732984e904acf8a15b5f36f391">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1CountedPtr.html">CountedPtr</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a3b43a30839ecc0499b0b5d2d71952233"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3b43a30839ecc0499b0b5d2d71952233"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3b43a30839ecc0499b0b5d2d71952233">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1CowPtr.html">CowPtr</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:af78ce7935f43397801a6d65785f71df5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af78ce7935f43397801a6d65785f71df5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af78ce7935f43397801a6d65785f71df5">minDGtal</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memitem:a5da3e5d223f3f741760a4e0fc3483c3a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5da3e5d223f3f741760a4e0fc3483c3a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5da3e5d223f3f741760a4e0fc3483c3a">maxDGtal</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memitem:a54cd4c3ec97c9ec323a52de71339f589"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a54cd4c3ec97c9ec323a52de71339f589"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a54cd4c3ec97c9ec323a52de71339f589">abs</a> (const T &amp;a)</td></tr>
<tr class="memitem:a7b3757780615da753f109e91c107bbd3"><td class="memTemplParams" colspan="2">template&lt;typename TSequence , typename TRank &gt; </td></tr>
<tr class="memitem:a7b3757780615da753f109e91c107bbd3"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7b3757780615da753f109e91c107bbd3">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1InputIteratorWithRankOnSequence.html">InputIteratorWithRankOnSequence</a>&lt; TSequence, TRank &gt; &amp;object)</td></tr>
<tr class="memitem:a411c7581c1016c57eae331f090729c37"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TFunctor , typename TReturnType &gt; </td></tr>
<tr class="memitem:a411c7581c1016c57eae331f090729c37"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1IteratorAdapter.html">IteratorAdapter</a>&lt; TIterator, <br class="typebreak"/>
TFunctor, TReturnType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a411c7581c1016c57eae331f090729c37">operator+</a> (typename <a class="el" href="structDGtal_1_1IteratorCirculatorTraits.html">IteratorCirculatorTraits</a>&lt; TIterator &gt;::Difference d, <a class="el" href="classDGtal_1_1IteratorAdapter.html">IteratorAdapter</a>&lt; TIterator, TFunctor, TReturnType &gt; &amp;object)</td></tr>
<tr class="memitem:a0213a561c03e9d90b12581abcf2ea54d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0213a561c03e9d90b12581abcf2ea54d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1OrderedAlphabet.html">OrderedAlphabet</a> &amp;object)</td></tr>
<tr class="memitem:a2129e2cee3ca511648fd20bcf90635f4"><td class="memTemplParams" colspan="2">template&lt;typename RealNumberType &gt; </td></tr>
<tr class="memitem:a2129e2cee3ca511648fd20bcf90635f4"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2129e2cee3ca511648fd20bcf90635f4">operator&lt;&lt;</a> (std::ostream &amp;thatStream, const <a class="el" href="classDGtal_1_1Statistic.html">Statistic</a>&lt; RealNumberType &gt; &amp;that_object_to_display)</td></tr>
<tr class="memitem:ae5cfe3192eb33036ed5a6afdce4fa90c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae5cfe3192eb33036ed5a6afdce4fa90c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Trace.html">Trace</a> &amp;object)</td></tr>
<tr class="memitem:aa1a0c72f3ea963c433d33b86d1fba535"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa1a0c72f3ea963c433d33b86d1fba535">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1TraceWriter.html">TraceWriter</a> &amp;object)</td></tr>
<tr class="memitem:abb0ae3e476260be1ddbbe6c881738e81"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abb0ae3e476260be1ddbbe6c881738e81">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1TraceWriterFile.html">TraceWriterFile</a> &amp;object)</td></tr>
<tr class="memitem:aa60540f21dc15c6580824e2e370a7600"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa60540f21dc15c6580824e2e370a7600">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1TraceWriterTerm.html">TraceWriterTerm</a> &amp;object)</td></tr>
<tr class="memitem:a2e60731c3d380a3d904efbf5c088cf07"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e60731c3d380a3d904efbf5c088cf07"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2e60731c3d380a3d904efbf5c088cf07">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1BLUELocalLengthEstimator.html">BLUELocalLengthEstimator</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:ac81440dbce679bb785c1679dc6b226af"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac81440dbce679bb785c1679dc6b226af"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac81440dbce679bb785c1679dc6b226af">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DSSLengthEstimator.html">DSSLengthEstimator</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a9611bc4af426ac90cd62f4f0d147d686"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9611bc4af426ac90cd62f4f0d147d686"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9611bc4af426ac90cd62f4f0d147d686">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1FPLengthEstimator.html">FPLengthEstimator</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a8b8a89999c5ec643ec73f257abe6c488"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8b8a89999c5ec643ec73f257abe6c488"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8b8a89999c5ec643ec73f257abe6c488">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1L1LengthEstimator.html">L1LengthEstimator</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a5b8eb9b80ef38f0b355c23ce44caec57"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5b8eb9b80ef38f0b355c23ce44caec57"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5b8eb9b80ef38f0b355c23ce44caec57">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1MLPLengthEstimator.html">MLPLengthEstimator</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a4b1f11e76731f6b53d58741593de1718"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b1f11e76731f6b53d58741593de1718"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a4b1f11e76731f6b53d58741593de1718">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1RosenProffittLocalLengthEstimator.html">RosenProffittLocalLengthEstimator</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a3ebfff66f1d6cdbd2b15f83c2ee8c55b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ebfff66f1d6cdbd2b15f83c2ee8c55b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3ebfff66f1d6cdbd2b15f83c2ee8c55b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1TwoStepLocalLengthEstimator.html">TwoStepLocalLengthEstimator</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a352f8e878ed0810de6b9166501d8f33a"><td class="memTemplParams" colspan="2">template&lt;typename TConstIteratorOnPoints , typename TValue &gt; </td></tr>
<tr class="memitem:a352f8e878ed0810de6b9166501d8f33a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a352f8e878ed0810de6b9166501d8f33a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1BinomialConvolver.html">BinomialConvolver</a>&lt; TConstIteratorOnPoints, TValue &gt; &amp;object)</td></tr>
<tr class="memitem:a36a2459f7913ffe2255193bdfc4536d8"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TInteger , int connectivity&gt; </td></tr>
<tr class="memitem:a36a2459f7913ffe2255193bdfc4536d8"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a36a2459f7913ffe2255193bdfc4536d8">operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TIterator, TInteger, connectivity &gt; &amp;object)</td></tr>
<tr class="memitem:aaabd5b098d8beabcd7e4bc7d4316586a"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TInteger , int connectivity&gt; </td></tr>
<tr class="memitem:aaabd5b098d8beabcd7e4bc7d4316586a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aaabd5b098d8beabcd7e4bc7d4316586a">operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="classDGtal_1_1ArithmeticalDSS3d.html">ArithmeticalDSS3d</a>&lt; TIterator, TInteger, connectivity &gt; &amp;object)</td></tr>
<tr class="memitem:ab3a7c82e86886176e1633ffa720003cb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ab3a7c82e86886176e1633ffa720003cb"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab3a7c82e86886176e1633ffa720003cb">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1CombinatorialDSS.html">CombinatorialDSS</a>&lt; T1, T2 &gt; &amp;object)</td></tr>
<tr class="memitem:a6ba93e4cd388ebab2cb5ec533a303962"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TInteger , int connectivity&gt; </td></tr>
<tr class="memitem:a6ba93e4cd388ebab2cb5ec533a303962"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6ba93e4cd388ebab2cb5ec533a303962">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1FP.html">FP</a>&lt; TIterator, TInteger, connectivity &gt; &amp;object)</td></tr>
<tr class="memitem:a85c3c4d290e6b5c6de7e46b431d4c4fe"><td class="memTemplParams" colspan="2">template&lt;typename TInteger &gt; </td></tr>
<tr class="memitem:a85c3c4d290e6b5c6de7e46b431d4c4fe"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a85c3c4d290e6b5c6de7e46b431d4c4fe">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1FreemanChain.html">FreemanChain</a>&lt; TInteger &gt; &amp;object)</td></tr>
<tr class="memitem:a62707785131f3a712ab96fdc6525f956"><td class="memTemplParams" colspan="2">template&lt;typename TConstIterator &gt; </td></tr>
<tr class="memitem:a62707785131f3a712ab96fdc6525f956"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a62707785131f3a712ab96fdc6525f956">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1GeometricalDCA.html">GeometricalDCA</a>&lt; TConstIterator &gt; &amp;object)</td></tr>
<tr class="memitem:af36416f9fdefcffddd2b2953f551257b"><td class="memTemplParams" colspan="2">template&lt;typename TConstIterator &gt; </td></tr>
<tr class="memitem:af36416f9fdefcffddd2b2953f551257b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af36416f9fdefcffddd2b2953f551257b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1GeometricalDSS.html">GeometricalDSS</a>&lt; TConstIterator &gt; &amp;object)</td></tr>
<tr class="memitem:a52995248ae36d8cd61977cf8e37c63bc"><td class="memTemplParams" colspan="2">template&lt;typename SegmentComputer &gt; </td></tr>
<tr class="memitem:a52995248ae36d8cd61977cf8e37c63bc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a52995248ae36d8cd61977cf8e37c63bc">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1GreedySegmentation.html">GreedySegmentation</a>&lt; SegmentComputer &gt; &amp;object)</td></tr>
<tr class="memitem:a6f39f856a5dc3683cd3fdb8e22afa143"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace &gt; </td></tr>
<tr class="memitem:a6f39f856a5dc3683cd3fdb8e22afa143"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6f39f856a5dc3683cd3fdb8e22afa143">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1GridCurve.html">GridCurve</a>&lt; TKSpace &gt; &amp;object)</td></tr>
<tr class="memitem:a86a932423c11c531c9ecfe4631704aab"><td class="memTemplParams" colspan="2">template&lt;typename SegmentComputer &gt; </td></tr>
<tr class="memitem:a86a932423c11c531c9ecfe4631704aab"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a86a932423c11c531c9ecfe4631704aab">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1SaturatedSegmentation.html">SaturatedSegmentation</a>&lt; SegmentComputer &gt; &amp;object)</td></tr>
<tr class="memitem:a8c4fb1b2976e5fc35dc1b4073149408e"><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr class="memitem:a8c4fb1b2976e5fc35dc1b4073149408e"><td class="memTemplItemLeft" align="right" valign="top">IC&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8c4fb1b2976e5fc35dc1b4073149408e">getMiddleIterator</a> (const IC &amp;itb, const IC &amp;ite, <a class="el" href="structDGtal_1_1RandomAccessCategory.html">RandomAccessCategory</a>)</td></tr>
<tr class="memitem:a9cf4e9405b276ba5b8b931f72d180d9d"><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr class="memitem:a9cf4e9405b276ba5b8b931f72d180d9d"><td class="memTemplItemLeft" align="right" valign="top">IC&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9cf4e9405b276ba5b8b931f72d180d9d">getMiddleIterator</a> (const IC &amp;itb, const IC &amp;ite, <a class="el" href="structDGtal_1_1BidirectionalCategory.html">BidirectionalCategory</a>)</td></tr>
<tr class="memitem:a8f53c482fe83e31093accf95ec7190d9"><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr class="memitem:a8f53c482fe83e31093accf95ec7190d9"><td class="memTemplItemLeft" align="right" valign="top">IC&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8f53c482fe83e31093accf95ec7190d9">getMiddleIterator</a> (const IC &amp;itb, const IC &amp;ite, <a class="el" href="structDGtal_1_1ForwardCategory.html">ForwardCategory</a>)</td></tr>
<tr class="memitem:a318f9e3e73cd0988af98b3a66a543334"><td class="memTemplParams" colspan="2">template&lt;typename IC &gt; </td></tr>
<tr class="memitem:a318f9e3e73cd0988af98b3a66a543334"><td class="memTemplItemLeft" align="right" valign="top">IC&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a318f9e3e73cd0988af98b3a66a543334">getMiddleIterator</a> (const IC &amp;itb, const IC &amp;ite)</td></tr>
<tr class="memitem:a4718031e09102bb8f73a874c47e10aaf"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a4718031e09102bb8f73a874c47e10aaf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a4718031e09102bb8f73a874c47e10aaf">maximalExtension</a> (SC &amp;s, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a>)</td></tr>
<tr class="memitem:a367841808f36fa49eceaa1671718f3ee"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a367841808f36fa49eceaa1671718f3ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a367841808f36fa49eceaa1671718f3ee">maximalExtension</a> (SC &amp;s, const typename SC::ConstIterator &amp;, <a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a>)</td></tr>
<tr class="memitem:a21c7d5ea8b24456694c6fa5f6a25f4cc"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a21c7d5ea8b24456694c6fa5f6a25f4cc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a21c7d5ea8b24456694c6fa5f6a25f4cc">maximalExtension</a> (SC &amp;s, const typename SC::ConstIterator &amp;end)</td></tr>
<tr class="memitem:a462eaaf587bc04ebd2e6141bed3fc21e"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a462eaaf587bc04ebd2e6141bed3fc21e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a462eaaf587bc04ebd2e6141bed3fc21e">oppositeEndMaximalExtension</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin, <a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a>)</td></tr>
<tr class="memitem:a9f50b26bc3256332ab287e1bb2a3e7cf"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a9f50b26bc3256332ab287e1bb2a3e7cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9f50b26bc3256332ab287e1bb2a3e7cf">oppositeEndMaximalExtension</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin, <a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a>)</td></tr>
<tr class="memitem:a567c997ae858c829256cc8a13c04d230"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a567c997ae858c829256cc8a13c04d230"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a567c997ae858c829256cc8a13c04d230">oppositeEndMaximalExtension</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin)</td></tr>
<tr class="memitem:ad8d73948fddeeb1f2e0fa94c4c9b03a9"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:ad8d73948fddeeb1f2e0fa94c4c9b03a9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad8d73948fddeeb1f2e0fa94c4c9b03a9">maximalSymmetricExtension</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a>)</td></tr>
<tr class="memitem:a04bd5266c4907488dc943c3fd18b72a0"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a04bd5266c4907488dc943c3fd18b72a0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a04bd5266c4907488dc943c3fd18b72a0">maximalSymmetricExtension</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a>)</td></tr>
<tr class="memitem:ad09a396e60a1ff248a246cc2f365fb31"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:ad09a396e60a1ff248a246cc2f365fb31"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad09a396e60a1ff248a246cc2f365fb31">maximalSymmetricExtension</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end)</td></tr>
<tr class="memitem:ad4831d5ff3c1c70bd1c6a26403297a9a"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:ad4831d5ff3c1c70bd1c6a26403297a9a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad4831d5ff3c1c70bd1c6a26403297a9a">maximalRetraction</a> (SC &amp;s, const typename SC::ConstIterator &amp;end)</td></tr>
<tr class="memitem:a137f26d321873e90065142afff6fa928"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a137f26d321873e90065142afff6fa928"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a137f26d321873e90065142afff6fa928">oppositeEndMaximalRetraction</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin)</td></tr>
<tr class="memitem:a2034305fadb5376a987519daba4c982a"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a2034305fadb5376a987519daba4c982a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">longestSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1IteratorType.html">IteratorType</a>)</td></tr>
<tr class="memitem:a67994f04a54230cdb524e46dba46a127"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a67994f04a54230cdb524e46dba46a127"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a67994f04a54230cdb524e46dba46a127">longestSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1CirculatorType.html">CirculatorType</a>)</td></tr>
<tr class="memitem:a464c32dc87cc7ded90f601f4657664a1"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a464c32dc87cc7ded90f601f4657664a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a464c32dc87cc7ded90f601f4657664a1">longestSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;end)</td></tr>
<tr class="memitem:ae6d3175b6c7d86845a0c259f566bd7ea"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:ae6d3175b6c7d86845a0c259f566bd7ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae6d3175b6c7d86845a0c259f566bd7ea">firstMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>)</td></tr>
<tr class="memitem:ae37d5f56ebcd83255b9c93038deff781"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:ae37d5f56ebcd83255b9c93038deff781"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae37d5f56ebcd83255b9c93038deff781">firstMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>)</td></tr>
<tr class="memitem:a8b81102d807d1ec5629d25c6e13ddae7"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a8b81102d807d1ec5629d25c6e13ddae7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8b81102d807d1ec5629d25c6e13ddae7">firstMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>)</td></tr>
<tr class="memitem:aae8ba2a7a4a42e59741df4afed37f449"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:aae8ba2a7a4a42e59741df4afed37f449"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aae8ba2a7a4a42e59741df4afed37f449">firstMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>)</td></tr>
<tr class="memitem:a18c5282eb177f64a2957c29bf51b0e1c"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a18c5282eb177f64a2957c29bf51b0e1c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a18c5282eb177f64a2957c29bf51b0e1c">firstMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end)</td></tr>
<tr class="memitem:a1b3f25b1f654c74c78819624604e4950"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a1b3f25b1f654c74c78819624604e4950"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1b3f25b1f654c74c78819624604e4950">mostCenteredMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>)</td></tr>
<tr class="memitem:ad153558eaa4afb851f884b64680f4631"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:ad153558eaa4afb851f884b64680f4631"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad153558eaa4afb851f884b64680f4631">mostCenteredMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>)</td></tr>
<tr class="memitem:a07a2cb535d2b0befce8f080d9d1a2414"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a07a2cb535d2b0befce8f080d9d1a2414"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a07a2cb535d2b0befce8f080d9d1a2414">mostCenteredMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>)</td></tr>
<tr class="memitem:aa43392e8f5aeba868858b9b2c1e52cf7"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:aa43392e8f5aeba868858b9b2c1e52cf7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa43392e8f5aeba868858b9b2c1e52cf7">mostCenteredMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>)</td></tr>
<tr class="memitem:adb7b7f5908ea811a44f41186c7a01e8e"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:adb7b7f5908ea811a44f41186c7a01e8e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#adb7b7f5908ea811a44f41186c7a01e8e">mostCenteredMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end)</td></tr>
<tr class="memitem:a19f04b5f095862ee00e620f8246df2f8"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a19f04b5f095862ee00e620f8246df2f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a19f04b5f095862ee00e620f8246df2f8">lastMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>)</td></tr>
<tr class="memitem:a8c5dc0554703f63c1ec705f764f2ba3a"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a8c5dc0554703f63c1ec705f764f2ba3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8c5dc0554703f63c1ec705f764f2ba3a">lastMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">BidirectionalSegmentComputer</a>)</td></tr>
<tr class="memitem:a652ebafea1d9e8891f40d9b0af8fcb02"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a652ebafea1d9e8891f40d9b0af8fcb02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a652ebafea1d9e8891f40d9b0af8fcb02">lastMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>)</td></tr>
<tr class="memitem:a47282aa7c7fc28d49e7a52a3f8eeee3c"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a47282aa7c7fc28d49e7a52a3f8eeee3c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a47282aa7c7fc28d49e7a52a3f8eeee3c">lastMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>)</td></tr>
<tr class="memitem:afa3e824f983193de48aaf18590edaa52"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:afa3e824f983193de48aaf18590edaa52"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afa3e824f983193de48aaf18590edaa52">lastMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;i, const typename SC::ConstIterator &amp;begin, const typename SC::ConstIterator &amp;end)</td></tr>
<tr class="memitem:a91c1293187f38e931f5f353d1a38f71c"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a91c1293187f38e931f5f353d1a38f71c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a91c1293187f38e931f5f353d1a38f71c">nextMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>)</td></tr>
<tr class="memitem:a0f4fc5b05689abd850faa6637a64505c"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a0f4fc5b05689abd850faa6637a64505c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0f4fc5b05689abd850faa6637a64505c">nextMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>)</td></tr>
<tr class="memitem:a6ee548c7f570f6bdb18ce2cc592cb009"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a6ee548c7f570f6bdb18ce2cc592cb009"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6ee548c7f570f6bdb18ce2cc592cb009">nextMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>)</td></tr>
<tr class="memitem:ae9e6d98ecc15fc5062f30060d4452706"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:ae9e6d98ecc15fc5062f30060d4452706"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae9e6d98ecc15fc5062f30060d4452706">nextMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>)</td></tr>
<tr class="memitem:a325d2a962cd3410424a45f83c1b32b7a"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a325d2a962cd3410424a45f83c1b32b7a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a325d2a962cd3410424a45f83c1b32b7a">nextMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;end)</td></tr>
<tr class="memitem:adabb9ea04f81cba914f3ac178439ffd4"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:adabb9ea04f81cba914f3ac178439ffd4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#adabb9ea04f81cba914f3ac178439ffd4">previousMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin, <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>)</td></tr>
<tr class="memitem:a8e35d35160afaea835678e7bf4a3458c"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:a8e35d35160afaea835678e7bf4a3458c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8e35d35160afaea835678e7bf4a3458c">previousMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin, <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>)</td></tr>
<tr class="memitem:afa1f75e59b72ea5e69760c965e20b3ff"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:afa1f75e59b72ea5e69760c965e20b3ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afa1f75e59b72ea5e69760c965e20b3ff">previousMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin, <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>)</td></tr>
<tr class="memitem:ad14e74091568436294698404dc08c9c5"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:ad14e74091568436294698404dc08c9c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad14e74091568436294698404dc08c9c5">previousMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;end, <a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>)</td></tr>
<tr class="memitem:af03fbf680fc202a21ef0801ee9240934"><td class="memTemplParams" colspan="2">template&lt;typename SC &gt; </td></tr>
<tr class="memitem:af03fbf680fc202a21ef0801ee9240934"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af03fbf680fc202a21ef0801ee9240934">previousMaximalSegment</a> (SC &amp;s, const typename SC::ConstIterator &amp;begin)</td></tr>
<tr class="memitem:a3e210a0da2db0fe767f88859a7ec00ba"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3e210a0da2db0fe767f88859a7ec00ba">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ContourHelper.html">ContourHelper</a> &amp;object)</td></tr>
<tr class="memitem:a311a8c89ec31846a61238a44a48c51c9"><td class="memTemplParams" colspan="2">template&lt;typename TDigitalSurfaceEmbedder , typename TNormalVectorEstimator &gt; </td></tr>
<tr class="memitem:a311a8c89ec31846a61238a44a48c51c9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a311a8c89ec31846a61238a44a48c51c9">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSurfaceEmbedderWithNormalVectorEstimator.html">DigitalSurfaceEmbedderWithNormalVectorEstimator</a>&lt; TDigitalSurfaceEmbedder, TNormalVectorEstimator &gt; &amp;object)</td></tr>
<tr class="memitem:a855e675db4e5e115051b87a6c79c6f36"><td class="memTemplParams" colspan="2">template&lt;typename TDigitalSurface , typename TNormalVectorEstimator , typename TEmbedder &gt; </td></tr>
<tr class="memitem:a855e675db4e5e115051b87a6c79c6f36"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a855e675db4e5e115051b87a6c79c6f36">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1NormalVectorEstimatorLinearCellEmbedder.html">NormalVectorEstimatorLinearCellEmbedder</a>&lt; TDigitalSurface, TNormalVectorEstimator, TEmbedder &gt; &amp;object)</td></tr>
<tr class="memitem:af1add10c7a26535a4feb8d370bd6fb4e"><td class="memTemplParams" colspan="2">template&lt;typename Shape &gt; </td></tr>
<tr class="memitem:af1add10c7a26535a4feb8d370bd6fb4e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af1add10c7a26535a4feb8d370bd6fb4e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Preimage2D.html">Preimage2D</a>&lt; Shape &gt; &amp;object)</td></tr>
<tr class="memitem:ad3c376126e05e1f797bb688366dd30f5"><td class="memTemplParams" colspan="2">template&lt;typename TImage , typename TSet , typename TPointPredicate , typename TPointFunctor &gt; </td></tr>
<tr class="memitem:ad3c376126e05e1f797bb688366dd30f5"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad3c376126e05e1f797bb688366dd30f5">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1FMM.html">FMM</a>&lt; TImage, TSet, TPointPredicate, TPointFunctor &gt; &amp;object)</td></tr>
<tr class="memitem:a71ebae2f928719f51222d9830f580ab6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a71ebae2f928719f51222d9830f580ab6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a71ebae2f928719f51222d9830f580ab6">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Measure.html">Measure</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a33aab58c74f85bff95f973d4ba9afde4"><td class="memTemplParams" colspan="2">template&lt;typename TImage , typename TFunctor , typename TValue &gt; </td></tr>
<tr class="memitem:a33aab58c74f85bff95f973d4ba9afde4"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a33aab58c74f85bff95f973d4ba9afde4">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ConstImageAdapter.html">ConstImageAdapter</a>&lt; TImage, TFunctor, TValue &gt; &amp;object)</td></tr>
<tr class="memitem:a3611cd19b341d3f70a23a0023e6aff2d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3611cd19b341d3f70a23a0023e6aff2d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3611cd19b341d3f70a23a0023e6aff2d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Image.html">Image</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:adcd8d9d47caf12b58c0270ee77c7ec5e"><td class="memTemplParams" colspan="2">template&lt;typename TDomain , typename TValue , typename THashKey &gt; </td></tr>
<tr class="memitem:adcd8d9d47caf12b58c0270ee77c7ec5e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#adcd8d9d47caf12b58c0270ee77c7ec5e">operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="classDGtal_1_1ImageContainerByHashTree.html">ImageContainerByHashTree</a>&lt; TDomain, TValue, THashKey &gt; &amp;object)</td></tr>
<tr class="memitem:ad5f4caac3598001543faa58512905fa1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TV &gt; </td></tr>
<tr class="memitem:ad5f4caac3598001543faa58512905fa1"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad5f4caac3598001543faa58512905fa1">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1experimental_1_1ImageContainerByITKImage.html">experimental::ImageContainerByITKImage</a>&lt; T, TV &gt; &amp;object)</td></tr>
<tr class="memitem:a44bf615980e20b3cd46b582b7141a6a4"><td class="memTemplParams" colspan="2">template&lt;typename TDomain , typename TValue &gt; </td></tr>
<tr class="memitem:a44bf615980e20b3cd46b582b7141a6a4"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a44bf615980e20b3cd46b582b7141a6a4">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1experimental_1_1ImageContainerByITKImage.html">experimental::ImageContainerByITKImage</a>&lt; TDomain, TValue &gt; &amp;object)</td></tr>
<tr class="memitem:a30d8ad5b6fd2dc5b1a3cff0afc4e3a5c"><td class="memTemplParams" colspan="2">template&lt;typename TDomain , typename TValue &gt; </td></tr>
<tr class="memitem:a30d8ad5b6fd2dc5b1a3cff0afc4e3a5c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a30d8ad5b6fd2dc5b1a3cff0afc4e3a5c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a>&lt; TDomain, TValue &gt; &amp;object)</td></tr>
<tr class="memitem:afec460eda081b4dc6922174819cae6cc"><td class="memTemplParams" colspan="2">template&lt;typename Domain , typename V &gt; </td></tr>
<tr class="memitem:afec460eda081b4dc6922174819cae6cc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afec460eda081b4dc6922174819cae6cc">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>&lt; Domain, V &gt; &amp;object)</td></tr>
<tr class="memitem:ad67647d42db11b7b3d3533e1cba6c2ba"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O , typename P &gt; </td></tr>
<tr class="memitem:ad67647d42db11b7b3d3533e1cba6c2ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad67647d42db11b7b3d3533e1cba6c2ba">setFromPointsRangeAndPredicate</a> (const I &amp;itb, const I &amp;ite, const O &amp;ito, const P &amp;aPred)</td></tr>
<tr class="memitem:ad57d4465e40fe4c1982ec2e01985be73"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O , typename F &gt; </td></tr>
<tr class="memitem:ad57d4465e40fe4c1982ec2e01985be73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad57d4465e40fe4c1982ec2e01985be73">setFromPointsRangeAndFunctor</a> (const I &amp;itb, const I &amp;ite, const O &amp;ito, const F &amp;aFunctor, const typename F::Value &amp;aThreshold=0)</td></tr>
<tr class="memitem:a202be24e94b5bdfba2d8563d0947f373"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:a202be24e94b5bdfba2d8563d0947f373"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a202be24e94b5bdfba2d8563d0947f373">setFromImage</a> (const I &amp;aImg, const O &amp;ito, const typename I::Value &amp;aThreshold=0)</td></tr>
<tr class="memitem:aecddf53312d4b765f34a022b049627c3"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:aecddf53312d4b765f34a022b049627c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aecddf53312d4b765f34a022b049627c3">setFromImage</a> (const I &amp;aImg, const O &amp;ito, const typename I::Value &amp;low, const typename I::Value &amp;up)</td></tr>
<tr class="memitem:ac1511d84bd2b82df82bea3aefc3af2dd"><td class="memTemplParams" colspan="2">template&lt;typename It , typename Im &gt; </td></tr>
<tr class="memitem:ac1511d84bd2b82df82bea3aefc3af2dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac1511d84bd2b82df82bea3aefc3af2dd">imageFromRangeAndValue</a> (const It &amp;itb, const It &amp;ite, Im &amp;aImg, const typename Im::Value &amp;aValue=0)</td></tr>
<tr class="memitem:aff03c6c44f0ec8ad182440aad1b4e86a"><td class="memTemplParams" colspan="2">template&lt;typename R , typename I &gt; </td></tr>
<tr class="memitem:aff03c6c44f0ec8ad182440aad1b4e86a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aff03c6c44f0ec8ad182440aad1b4e86a">imageFromRangeAndValue</a> (const R &amp;aRange, I &amp;aImg, const typename I::Value &amp;aValue=0)</td></tr>
<tr class="memitem:a46234d3693677caa52b0ffb6db059d5d"><td class="memTemplParams" colspan="2">template&lt;typename I , typename F &gt; </td></tr>
<tr class="memitem:a46234d3693677caa52b0ffb6db059d5d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a46234d3693677caa52b0ffb6db059d5d">imageFromFunctor</a> (I &amp;aImg, const F &amp;aFun)</td></tr>
<tr class="memitem:a6e6f5a9c305d047a2e9c6315ca17832c"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a6e6f5a9c305d047a2e9c6315ca17832c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6e6f5a9c305d047a2e9c6315ca17832c">imageFromImage</a> (I &amp;aImg1, const I &amp;aImg2)</td></tr>
<tr class="memitem:a5f01a70f2cf84e9c08d1308e77911a08"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S &gt; </td></tr>
<tr class="memitem:a5f01a70f2cf84e9c08d1308e77911a08"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5f01a70f2cf84e9c08d1308e77911a08">insertAndSetValue</a> (I &amp;aImg, S &amp;aSet, const typename I::Point &amp;aPoint, const typename I::Value &amp;aValue)</td></tr>
<tr class="memitem:ac920bc98f866a2e17ee53faddc67ff80"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S &gt; </td></tr>
<tr class="memitem:ac920bc98f866a2e17ee53faddc67ff80"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac920bc98f866a2e17ee53faddc67ff80">insertAndAlwaysSetValue</a> (I &amp;aImg, S &amp;aSet, const typename I::Point &amp;aPoint, const typename I::Value &amp;aValue)</td></tr>
<tr class="memitem:a3f73d6217f05eef8225781a523efc077"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S &gt; </td></tr>
<tr class="memitem:a3f73d6217f05eef8225781a523efc077"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3f73d6217f05eef8225781a523efc077">findAndGetValue</a> (const I &amp;aImg, const S &amp;aSet, const typename I::Point &amp;aPoint, typename I::Value &amp;aValue)</td></tr>
<tr class="memitem:a7272fa4a71b37b89de44110188769338"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TImage , typename TEmbedder &gt; </td></tr>
<tr class="memitem:a7272fa4a71b37b89de44110188769338"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7272fa4a71b37b89de44110188769338">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImageLinearCellEmbedder.html">ImageLinearCellEmbedder</a>&lt; TKSpace, TImage, TEmbedder &gt; &amp;object)</td></tr>
<tr class="memitem:ac3c6d87ade0e0da551f72c4e645771e1"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac3c6d87ade0e0da551f72c4e645771e1">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Board2D.html">Board2D</a> &amp;object)</td></tr>
<tr class="memitem:aa32e43bdffbdc24f45de94ad9102978a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa32e43bdffbdc24f45de94ad9102978a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Board3DTo2D.html">Board3DTo2D</a> &amp;object)</td></tr>
<tr class="memitem:abb59a7087b1ca526c94078e5cc499672"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abb59a7087b1ca526c94078e5cc499672">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Color.html">Color</a> &amp;aColor)</td></tr>
<tr class="memitem:a0cadab732dfb13c3b84f49566f5b9c11"><td class="memTemplParams" colspan="2">template&lt;typename PValue , int PDefaultColor&gt; </td></tr>
<tr class="memitem:a0cadab732dfb13c3b84f49566f5b9c11"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0cadab732dfb13c3b84f49566f5b9c11">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ColorBrightnessColorMap.html">ColorBrightnessColorMap</a>&lt; PValue, PDefaultColor &gt; &amp;object)</td></tr>
<tr class="memitem:a1cfec935d23b12fc18c32eece2a8ab1e"><td class="memTemplParams" colspan="2">template&lt;typename PValue , int PDefaultPreset, int PDefaultFirstColor, int PDefaultLastColor&gt; </td></tr>
<tr class="memitem:a1cfec935d23b12fc18c32eece2a8ab1e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1cfec935d23b12fc18c32eece2a8ab1e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1GradientColorMap.html">GradientColorMap</a>&lt; PValue, PDefaultPreset, PDefaultFirstColor, PDefaultLastColor &gt; &amp;object)</td></tr>
<tr class="memitem:a485151b618f71a80d057c3c7d35e84ca"><td class="memTemplParams" colspan="2">template&lt;typename PValue &gt; </td></tr>
<tr class="memitem:a485151b618f71a80d057c3c7d35e84ca"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a485151b618f71a80d057c3c7d35e84ca">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1GrayscaleColorMap.html">GrayscaleColorMap</a>&lt; PValue &gt; &amp;object)</td></tr>
<tr class="memitem:a69f3490f30f770c8fc9fc6dd445cd93c"><td class="memTemplParams" colspan="2">template&lt;typename PValue , int DefaultCycles&gt; </td></tr>
<tr class="memitem:a69f3490f30f770c8fc9fc6dd445cd93c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a69f3490f30f770c8fc9fc6dd445cd93c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1HueShadeColorMap.html">HueShadeColorMap</a>&lt; PValue, DefaultCycles &gt; &amp;object)</td></tr>
<tr class="memitem:a0862dd8a38f8e16ed9bc34ad6ba2bc55"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0862dd8a38f8e16ed9bc34ad6ba2bc55">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1RandomColorMap.html">RandomColorMap</a> &amp;object)</td></tr>
<tr class="memitem:a7b632be90297f1d6a81a58c1a0a4bdc3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7b632be90297f1d6a81a58c1a0a4bdc3">cross</a> (double dst[3], double srcA[3], double srcB[3])</td></tr>
<tr class="memitem:a5953d43d65a342438b932b5fac6a0334"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5953d43d65a342438b932b5fac6a0334">normalize</a> (double vec[3])</td></tr>
<tr class="memitem:ab58d2ea12ddf3ceb1b0d9fef20ae6875"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab58d2ea12ddf3ceb1b0d9fef20ae6875">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Display3D.html">Display3D</a> &amp;object)</td></tr>
<tr class="memitem:a008281343ea4fc3971b69a6543b9b842"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:a008281343ea4fc3971b69a6543b9b842"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a008281343ea4fc3971b69a6543b9b842">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DGtalInventor.html">DGtalInventor</a>&lt; TSpace &gt; &amp;object)</td></tr>
<tr class="memitem:adbf9270f5f724d5e51d1356f3372783c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#adbf9270f5f724d5e51d1356f3372783c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1IVViewer.html">IVViewer</a> &amp;object)</td></tr>
<tr class="memitem:a2d3fcda6867c1a6cae9a2011a8c1b30c"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:a2d3fcda6867c1a6cae9a2011a8c1b30c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2d3fcda6867c1a6cae9a2011a8c1b30c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Lattice.html">Lattice</a>&lt; TSpace &gt; &amp;object)</td></tr>
<tr class="memitem:ac2a53895055b003622553da7cb636570"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac2a53895055b003622553da7cb636570">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Viewer3D.html">Viewer3D</a> &amp;object)</td></tr>
<tr class="memitem:a61e5d3bce501d46ca6cb4baee8590389"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace &gt; </td></tr>
<tr class="memitem:a61e5d3bce501d46ca6cb4baee8590389"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a61e5d3bce501d46ca6cb4baee8590389">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1CanonicCellEmbedder.html">CanonicCellEmbedder</a>&lt; TKSpace &gt; &amp;object)</td></tr>
<tr class="memitem:abbf878eedd1e61f021f337b903ac1a5e"><td class="memTemplParams" colspan="2">template&lt;typename TDigitalSurface &gt; </td></tr>
<tr class="memitem:abbf878eedd1e61f021f337b903ac1a5e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abbf878eedd1e61f021f337b903ac1a5e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1CanonicDigitalSurfaceEmbedder.html">CanonicDigitalSurfaceEmbedder</a>&lt; TDigitalSurface &gt; &amp;object)</td></tr>
<tr class="memitem:a1c198285c212e189cc6b3775282d971b"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:a1c198285c212e189cc6b3775282d971b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1c198285c212e189cc6b3775282d971b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1CanonicEmbedder.html">CanonicEmbedder</a>&lt; TSpace &gt; &amp;object)</td></tr>
<tr class="memitem:afc39fa68fdb704b43c5f89b871030b30"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace &gt; </td></tr>
<tr class="memitem:afc39fa68fdb704b43c5f89b871030b30"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afc39fa68fdb704b43c5f89b871030b30">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1CanonicSCellEmbedder.html">CanonicSCellEmbedder</a>&lt; TKSpace &gt; &amp;object)</td></tr>
<tr class="memitem:a65fe5e7517f127b50ab8d9daa779a55e"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:a65fe5e7517f127b50ab8d9daa779a55e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a65fe5e7517f127b50ab8d9daa779a55e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1HyperRectDomain.html">HyperRectDomain</a>&lt; TSpace &gt; &amp;object)</td></tr>
<tr class="memitem:a44d1dd3f9097cf9d2b7f280c95e34b1e"><td class="memTemplParams" colspan="2">template&lt;Dimension dim, typename Container &gt; </td></tr>
<tr class="memitem:a44d1dd3f9097cf9d2b7f280c95e34b1e"><td class="memTemplItemLeft" align="right" valign="top">std::bitset&lt; dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a44d1dd3f9097cf9d2b7f280c95e34b1e">setDimensionsIn</a> (const Container &amp;dimensions)</td></tr>
<tr class="memitem:ae405036e4e10cc9ecee7918e5fb10dd9"><td class="memTemplParams" colspan="2">template&lt;Dimension dim, typename Container &gt; </td></tr>
<tr class="memitem:ae405036e4e10cc9ecee7918e5fb10dd9"><td class="memTemplItemLeft" align="right" valign="top">std::bitset&lt; dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae405036e4e10cc9ecee7918e5fb10dd9">setDimensionsNotIn</a> (const Container &amp;dimensions)</td></tr>
<tr class="memitem:a484bbc565292ed3fd276d70c3e71afac"><td class="memTemplParams" colspan="2">template&lt;Dimension dim, typename Component &gt; </td></tr>
<tr class="memitem:a484bbc565292ed3fd276d70c3e71afac"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a484bbc565292ed3fd276d70c3e71afac">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; dim, Component &gt; &amp;object)</td></tr>
<tr class="memitem:aa22cc58968d7134d4ec338d8b6d49f47"><td class="memTemplParams" colspan="2">template&lt;typename TSpace &gt; </td></tr>
<tr class="memitem:aa22cc58968d7134d4ec338d8b6d49f47"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa22cc58968d7134d4ec338d8b6d49f47">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1RegularPointEmbedder.html">RegularPointEmbedder</a>&lt; TSpace &gt; &amp;object)</td></tr>
<tr class="memitem:a294f23451c7c99ae08e19bd5eea76469"><td class="memTemplParams" colspan="2">template&lt;typename Domain &gt; </td></tr>
<tr class="memitem:a294f23451c7c99ae08e19bd5eea76469"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a294f23451c7c99ae08e19bd5eea76469">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html">DigitalSetBySTLSet</a>&lt; Domain &gt; &amp;object)</td></tr>
<tr class="memitem:a133f736b6505cf0359ccc7e8be803c46"><td class="memTemplParams" colspan="2">template&lt;typename Domain &gt; </td></tr>
<tr class="memitem:a133f736b6505cf0359ccc7e8be803c46"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a133f736b6505cf0359ccc7e8be803c46">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSetBySTLVector.html">DigitalSetBySTLVector</a>&lt; Domain &gt; &amp;object)</td></tr>
<tr class="memitem:a64c1c0996bfe10bd42952cad2d72ecdb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a64c1c0996bfe10bd42952cad2d72ecdb"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a64c1c0996bfe10bd42952cad2d72ecdb">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSetDomain.html">DigitalSetDomain</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a6f97c9e9c01d4864725d8d606a5535a6"><td class="memTemplParams" colspan="2">template&lt;typename TMapImage &gt; </td></tr>
<tr class="memitem:a6f97c9e9c01d4864725d8d606a5535a6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a6f97c9e9c01d4864725d8d606a5535a6">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSetFromMap.html">DigitalSetFromMap</a>&lt; TMapImage &gt; &amp;object)</td></tr>
<tr class="memitem:a5684b6b55398b599ed5aaa9a70f3a0cc"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5684b6b55398b599ed5aaa9a70f3a0cc">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1AngleLinearMinimizer.html">AngleLinearMinimizer</a> &amp;object)</td></tr>
<tr class="memitem:a196a8c122d6e58d73ecd46c249b8b849"><td class="memTemplParams" colspan="2">template&lt;typename TInteger &gt; </td></tr>
<tr class="memitem:a196a8c122d6e58d73ecd46c249b8b849"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a196a8c122d6e58d73ecd46c249b8b849">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1IntegerComputer.html">IntegerComputer</a>&lt; TInteger &gt; &amp;object)</td></tr>
<tr class="memitem:ae4f0a1e7a73fe21a13f6809e3a47ff0c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae4f0a1e7a73fe21a13f6809e3a47ff0c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae4f0a1e7a73fe21a13f6809e3a47ff0c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ModuloComputer.html">ModuloComputer</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a5f14f15bee0a8b951c870363e278a94e"><td class="memTemplParams" colspan="2">template&lt;typename TFraction &gt; </td></tr>
<tr class="memitem:a5f14f15bee0a8b951c870363e278a94e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5f14f15bee0a8b951c870363e278a94e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Pattern.html">Pattern</a>&lt; TFraction &gt; &amp;object)</td></tr>
<tr class="memitem:aa0e2794580b8d7d35c4b4761f264d08e"><td class="memTemplParams" colspan="2">template&lt;typename TFraction &gt; </td></tr>
<tr class="memitem:aa0e2794580b8d7d35c4b4761f264d08e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa0e2794580b8d7d35c4b4761f264d08e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1StandardDSLQ0.html">StandardDSLQ0</a>&lt; TFraction &gt; &amp;object)</td></tr>
<tr class="memitem:a0c685b28cb1a025847d30274b28d0edd"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0c685b28cb1a025847d30274b28d0edd">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1MeasureOfStraightLines.html">MeasureOfStraightLines</a> &amp;object)</td></tr>
<tr class="memitem:a2bbdffe7efc4f8af031964cecfe477a7"><td class="memTemplParams" colspan="2">template&lt;typename TRing , typename TAlloc &gt; </td></tr>
<tr class="memitem:a2bbdffe7efc4f8af031964cecfe477a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a2bbdffe7efc4f8af031964cecfe477a7">euclidDiv</a> (const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, TRing, TAlloc &gt; &amp;f, const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, TRing, TAlloc &gt; &amp;g, <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, TRing, TAlloc &gt; &amp;q, <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, TRing, TAlloc &gt; &amp;r)</td></tr>
<tr class="memitem:aade413b000d41b595aa32414aaa564a9"><td class="memTemplParams" colspan="2">template&lt;int N, typename TRing , class TAlloc &gt; </td></tr>
<tr class="memitem:aade413b000d41b595aa32414aaa564a9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aade413b000d41b595aa32414aaa564a9">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; N, TRing, TAlloc &gt; &amp;object)</td></tr>
<tr class="memitem:a948cc02e8fe7e8ab1051bce164421fa8"><td class="memTemplParams" colspan="2">template&lt;int n, typename Ring , typename Alloc &gt; </td></tr>
<tr class="memitem:a948cc02e8fe7e8ab1051bce164421fa8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; n, Ring, Alloc &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a948cc02e8fe7e8ab1051bce164421fa8">Xe_k</a> (unsigned int k, unsigned int e)</td></tr>
<tr class="memitem:ad099005ab7d493b2ea19026e2fb96a32"><td class="memTemplParams" colspan="2">template&lt;int n, typename Ring &gt; </td></tr>
<tr class="memitem:ad099005ab7d493b2ea19026e2fb96a32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; n, Ring, <br class="typebreak"/>
std::allocator&lt; Ring &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad099005ab7d493b2ea19026e2fb96a32">Xe_k</a> (unsigned int k, unsigned int e)</td></tr>
<tr class="memitem:a770659cf50cd49c0ce6c3d4ab08abb46"><td class="memTemplParams" colspan="2">template&lt;typename Ring , typename Alloc &gt; </td></tr>
<tr class="memitem:a770659cf50cd49c0ce6c3d4ab08abb46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a770659cf50cd49c0ce6c3d4ab08abb46">mmonomial</a> (unsigned int e)</td></tr>
<tr class="memitem:ad04b582eb75ae0cfc14dfc40d57c03f2"><td class="memTemplParams" colspan="2">template&lt;typename Ring , typename Alloc &gt; </td></tr>
<tr class="memitem:ad04b582eb75ae0cfc14dfc40d57c03f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 2, Ring, Alloc &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad04b582eb75ae0cfc14dfc40d57c03f2">mmonomial</a> (unsigned int e, unsigned int f)</td></tr>
<tr class="memitem:a46b41f1ac0f88d213c7fb8bee8931799"><td class="memTemplParams" colspan="2">template&lt;typename Ring , typename Alloc &gt; </td></tr>
<tr class="memitem:a46b41f1ac0f88d213c7fb8bee8931799"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 3, Ring, Alloc &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a46b41f1ac0f88d213c7fb8bee8931799">mmonomial</a> (unsigned int e, unsigned int f, unsigned int g)</td></tr>
<tr class="memitem:ae6ba6c1f73137c9da0365c16635c92e9"><td class="memTemplParams" colspan="2">template&lt;typename Ring , typename Alloc &gt; </td></tr>
<tr class="memitem:ae6ba6c1f73137c9da0365c16635c92e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 4, Ring, Alloc &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae6ba6c1f73137c9da0365c16635c92e9">mmonomial</a> (unsigned int e, unsigned int f, unsigned int g, unsigned int h)</td></tr>
<tr class="memitem:a9ef248272fbf9b379c272e0ec632289c"><td class="memTemplParams" colspan="2">template&lt;typename Ring &gt; </td></tr>
<tr class="memitem:a9ef248272fbf9b379c272e0ec632289c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, <br class="typebreak"/>
std::allocator&lt; Ring &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9ef248272fbf9b379c272e0ec632289c">mmonomial</a> (unsigned int e)</td></tr>
<tr class="memitem:a9ac70e986a68541f5a9e2b9a4035da2c"><td class="memTemplParams" colspan="2">template&lt;typename Ring &gt; </td></tr>
<tr class="memitem:a9ac70e986a68541f5a9e2b9a4035da2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 2, Ring, <br class="typebreak"/>
std::allocator&lt; Ring &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9ac70e986a68541f5a9e2b9a4035da2c">mmonomial</a> (unsigned int e, unsigned int f)</td></tr>
<tr class="memitem:a4f44e0a9fc1e30d29e52646daeca211d"><td class="memTemplParams" colspan="2">template&lt;typename Ring &gt; </td></tr>
<tr class="memitem:a4f44e0a9fc1e30d29e52646daeca211d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 3, Ring, <br class="typebreak"/>
std::allocator&lt; Ring &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a4f44e0a9fc1e30d29e52646daeca211d">mmonomial</a> (unsigned int e, unsigned int f, unsigned int g)</td></tr>
<tr class="memitem:a4a679186eed201b0844c7bf6f83e76c8"><td class="memTemplParams" colspan="2">template&lt;typename Ring &gt; </td></tr>
<tr class="memitem:a4a679186eed201b0844c7bf6f83e76c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 4, Ring, <br class="typebreak"/>
std::allocator&lt; Ring &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a4a679186eed201b0844c7bf6f83e76c8">mmonomial</a> (unsigned int e, unsigned int f, unsigned int g, unsigned int h)</td></tr>
<tr class="memitem:afd55a2a73cd7b4552dbaf0b62980b323"><td class="memTemplParams" colspan="2">template&lt;int N, int n, typename Ring , typename Alloc &gt; </td></tr>
<tr class="memitem:afd55a2a73cd7b4552dbaf0b62980b323"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; n, Ring, Alloc &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afd55a2a73cd7b4552dbaf0b62980b323">derivative</a> (const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; n, Ring, Alloc &gt; &amp;p)</td></tr>
<tr class="memitem:a9aedf0fbd5b7c5814911d1299be81cb9"><td class="memTemplParams" colspan="2">template&lt;int N, int n, typename Ring &gt; </td></tr>
<tr class="memitem:a9aedf0fbd5b7c5814911d1299be81cb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; n, Ring, <br class="typebreak"/>
std::allocator&lt; Ring &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9aedf0fbd5b7c5814911d1299be81cb9">derivative</a> (const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; n, Ring, std::allocator&lt; Ring &gt; &gt; &amp;p)</td></tr>
<tr class="memitem:afc4718ecc21bcecf1618414e982b951c"><td class="memTemplParams" colspan="2">template&lt;typename Ring , typename Alloc &gt; </td></tr>
<tr class="memitem:afc4718ecc21bcecf1618414e982b951c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#afc4718ecc21bcecf1618414e982b951c">euclidDiv</a> (const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;f, const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;g, <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;q, <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;r)</td></tr>
<tr class="memitem:a57e756b9529892b5019066b6d4a4310c"><td class="memTemplParams" colspan="2">template&lt;typename Ring &gt; </td></tr>
<tr class="memitem:a57e756b9529892b5019066b6d4a4310c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a57e756b9529892b5019066b6d4a4310c">euclidDiv</a> (const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;f, const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;g, <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;q, <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;r)</td></tr>
<tr class="memitem:a38fc7e3a7ad4420d8b0b5950ae21c32e"><td class="memTemplParams" colspan="2">template&lt;typename Ring , typename Alloc &gt; </td></tr>
<tr class="memitem:a38fc7e3a7ad4420d8b0b5950ae21c32e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a38fc7e3a7ad4420d8b0b5950ae21c32e">gcd</a> (const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;f, const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;g)</td></tr>
<tr class="memitem:ab28649140d0b09a9b25515660a3e6f12"><td class="memTemplParams" colspan="2">template&lt;typename Ring &gt; </td></tr>
<tr class="memitem:ab28649140d0b09a9b25515660a3e6f12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, <br class="typebreak"/>
std::allocator&lt; Ring &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ab28649140d0b09a9b25515660a3e6f12">gcd</a> (const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;f, const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;g)</td></tr>
<tr class="memitem:a7bf8ccb5fec38dffae46efd2c0d5c2c7"><td class="memTemplParams" colspan="2">template&lt;typename TValue &gt; </td></tr>
<tr class="memitem:a7bf8ccb5fec38dffae46efd2c0d5c2c7"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7bf8ccb5fec38dffae46efd2c0d5c2c7">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Signal.html">Signal</a>&lt; TValue &gt; &amp;object)</td></tr>
<tr class="memitem:a585a463f4055c1df3774c34bc4d1c5fb"><td class="memTemplParams" colspan="2">template&lt;typename TPoint &gt; </td></tr>
<tr class="memitem:a585a463f4055c1df3774c34bc4d1c5fb"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a585a463f4055c1df3774c34bc4d1c5fb">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1CircleFrom2Points.html">CircleFrom2Points</a>&lt; TPoint &gt; &amp;object)</td></tr>
<tr class="memitem:a5ee88b42fe08c64c833f2b785139063c"><td class="memTemplParams" colspan="2">template&lt;typename TPoint &gt; </td></tr>
<tr class="memitem:a5ee88b42fe08c64c833f2b785139063c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5ee88b42fe08c64c833f2b785139063c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1CircleFrom3Points.html">CircleFrom3Points</a>&lt; TPoint &gt; &amp;object)</td></tr>
<tr class="memitem:a8b6273f070d1edcf9c510601044863d4"><td class="memTemplParams" colspan="2">template&lt;typename TSurface , bool isUpward, bool isClosed&gt; </td></tr>
<tr class="memitem:a8b6273f070d1edcf9c510601044863d4"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8b6273f070d1edcf9c510601044863d4">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Point2ShapePredicate.html">Point2ShapePredicate</a>&lt; TSurface, isUpward, isClosed &gt; &amp;object)</td></tr>
<tr class="memitem:a9c9db375c56d37d5a38a7599c7e02e07"><td class="memTemplParams" colspan="2">template&lt;typename TPoint &gt; </td></tr>
<tr class="memitem:a9c9db375c56d37d5a38a7599c7e02e07"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9c9db375c56d37d5a38a7599c7e02e07">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1StraightLineFrom2Points.html">StraightLineFrom2Points</a>&lt; TPoint &gt; &amp;object)</td></tr>
<tr class="memitem:aebacbf3c61709a7e0d1fc250f1f0204f"><td class="memTemplParams" colspan="2">template&lt;typename TSpace , typename TEuclideanShape &gt; </td></tr>
<tr class="memitem:aebacbf3c61709a7e0d1fc250f1f0204f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aebacbf3c61709a7e0d1fc250f1f0204f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1GaussDigitizer.html">GaussDigitizer</a>&lt; TSpace, TEuclideanShape &gt; &amp;object)</td></tr>
<tr class="memitem:abd178d36151704c1413d4ad614e7f774"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd178d36151704c1413d4ad614e7f774"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#abd178d36151704c1413d4ad614e7f774">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImplicitBall.html">ImplicitBall</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:accdbde97ed9607a15ec962171d6d933e"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TImplicitFunctionDiff1 , typename TEmbedder &gt; </td></tr>
<tr class="memitem:accdbde97ed9607a15ec962171d6d933e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#accdbde97ed9607a15ec962171d6d933e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImplicitFunctionDiff1LinearCellEmbedder.html">ImplicitFunctionDiff1LinearCellEmbedder</a>&lt; TKSpace, TImplicitFunctionDiff1, TEmbedder &gt; &amp;object)</td></tr>
<tr class="memitem:aeebf10a683d3e958f2b53c11af2e8548"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TImplicitFunction , typename TEmbedder &gt; </td></tr>
<tr class="memitem:aeebf10a683d3e958f2b53c11af2e8548"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aeebf10a683d3e958f2b53c11af2e8548">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImplicitFunctionLinearCellEmbedder.html">ImplicitFunctionLinearCellEmbedder</a>&lt; TKSpace, TImplicitFunction, TEmbedder &gt; &amp;object)</td></tr>
<tr class="memitem:a8a88c744566a4a1adce2dd7d55256bbd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a88c744566a4a1adce2dd7d55256bbd"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8a88c744566a4a1adce2dd7d55256bbd">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImplicitHyperCube.html">ImplicitHyperCube</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a670552923873f4f08a0c8d2ecf75cbe9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a670552923873f4f08a0c8d2ecf75cbe9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a670552923873f4f08a0c8d2ecf75cbe9">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImplicitNorm1Ball.html">ImplicitNorm1Ball</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a31c3aec34372e12bb2a4b530ebefb1b6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a31c3aec34372e12bb2a4b530ebefb1b6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a31c3aec34372e12bb2a4b530ebefb1b6">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImplicitPolynomial3Shape.html">ImplicitPolynomial3Shape</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a094a29952a05e86998aaf467bb013d1b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a094a29952a05e86998aaf467bb013d1b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a094a29952a05e86998aaf467bb013d1b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImplicitRoundedHyperCube.html">ImplicitRoundedHyperCube</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a9d6116d3f522841ef300a0a3d0a22dd6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9d6116d3f522841ef300a0a3d0a22dd6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9d6116d3f522841ef300a0a3d0a22dd6">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1AccFlower2D.html">AccFlower2D</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a1d0842bcae55bdd9b262e906c5b3a79d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1d0842bcae55bdd9b262e906c5b3a79d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1d0842bcae55bdd9b262e906c5b3a79d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Ball2D.html">Ball2D</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a0e209bc654b6b3088e3d880d4eb24a96"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0e209bc654b6b3088e3d880d4eb24a96"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0e209bc654b6b3088e3d880d4eb24a96">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Ellipse2D.html">Ellipse2D</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a87b130f95ae2c59b8ce9a2d9b3eb00eb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a87b130f95ae2c59b8ce9a2d9b3eb00eb"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a87b130f95ae2c59b8ce9a2d9b3eb00eb">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Flower2D.html">Flower2D</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:ae1caecda191f889867656183eabae2f7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae1caecda191f889867656183eabae2f7"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae1caecda191f889867656183eabae2f7">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1NGon2D.html">NGon2D</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a0da05652e14a44efd06ab37c830fb00c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0da05652e14a44efd06ab37c830fb00c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a0da05652e14a44efd06ab37c830fb00c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1StarShaped2D.html">StarShaped2D</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a30df8b8fe139c899b9f825d7e5f6398d"><td class="memTemplParams" colspan="2">template&lt;typename TDomain &gt; </td></tr>
<tr class="memitem:a30df8b8fe139c899b9f825d7e5f6398d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a30df8b8fe139c899b9f825d7e5f6398d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Shapes.html">Shapes</a>&lt; TDomain &gt; &amp;object)</td></tr>
<tr class="memitem:a60cb8329ec7e317f1beb03c8b322cf13"><td class="memTemplParams" colspan="2">template&lt;typename TGraph , typename TMarkSet &gt; </td></tr>
<tr class="memitem:a60cb8329ec7e317f1beb03c8b322cf13"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a60cb8329ec7e317f1beb03c8b322cf13">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1BreadthFirstVisitor.html">BreadthFirstVisitor</a>&lt; TGraph, TMarkSet &gt; &amp;object)</td></tr>
<tr class="memitem:a8600426252610144c749a003e93274f6"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TDigitalSet &gt; </td></tr>
<tr class="memitem:a8600426252610144c749a003e93274f6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8600426252610144c749a003e93274f6">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSetBoundary.html">DigitalSetBoundary</a>&lt; TKSpace, TDigitalSet &gt; &amp;object)</td></tr>
<tr class="memitem:a1f3fe65ff2eec5a590b6a2c550725e7e"><td class="memTemplParams" colspan="2">template&lt;typename TDigitalSurfaceContainer &gt; </td></tr>
<tr class="memitem:a1f3fe65ff2eec5a590b6a2c550725e7e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1f3fe65ff2eec5a590b6a2c550725e7e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSurface.html">DigitalSurface</a>&lt; TDigitalSurfaceContainer &gt; &amp;object)</td></tr>
<tr class="memitem:a432b6b35fc11ee6b9c11fb54d193b366"><td class="memTemplParams" colspan="2">template&lt;typename TDigitalSurfaceTracker &gt; </td></tr>
<tr class="memitem:a432b6b35fc11ee6b9c11fb54d193b366"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a432b6b35fc11ee6b9c11fb54d193b366">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalSurface2DSlice.html">DigitalSurface2DSlice</a>&lt; TDigitalSurfaceTracker &gt; &amp;object)</td></tr>
<tr class="memitem:aa8be5db54eccfba7fd8916763cbf00da"><td class="memTemplParams" colspan="2">template&lt;typename TForegroundAdjacency , typename TBackgroundAdjacency &gt; </td></tr>
<tr class="memitem:aa8be5db54eccfba7fd8916763cbf00da"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa8be5db54eccfba7fd8916763cbf00da">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DigitalTopology.html">DigitalTopology</a>&lt; TForegroundAdjacency, TBackgroundAdjacency &gt; &amp;object)</td></tr>
<tr class="memitem:ac9e45359f1676fa161c263f50cbee30d"><td class="memTemplParams" colspan="2">template&lt;typename TDomain , typename TAdjacency &gt; </td></tr>
<tr class="memitem:ac9e45359f1676fa161c263f50cbee30d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac9e45359f1676fa161c263f50cbee30d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1DomainAdjacency.html">DomainAdjacency</a>&lt; TDomain, TAdjacency &gt; &amp;object)</td></tr>
<tr class="memitem:aa92bbcb0c90cddb06c7f84134c1e4a5f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa92bbcb0c90cddb06c7f84134c1e4a5f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa92bbcb0c90cddb06c7f84134c1e4a5f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Expander.html">Expander</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:ac2a3ce65944bf6a16aeb2ebce2c9cd00"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TSurfelPredicate &gt; </td></tr>
<tr class="memitem:ac2a3ce65944bf6a16aeb2ebce2c9cd00"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac2a3ce65944bf6a16aeb2ebce2c9cd00">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html">ExplicitDigitalSurface</a>&lt; TKSpace, TSurfelPredicate &gt; &amp;object)</td></tr>
<tr class="memitem:af0a7679f68647399382399dc1608a6dc"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TImage &gt; </td></tr>
<tr class="memitem:af0a7679f68647399382399dc1608a6dc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af0a7679f68647399382399dc1608a6dc">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1BoundaryPredicate.html">BoundaryPredicate</a>&lt; TKSpace, TImage &gt; &amp;object)</td></tr>
<tr class="memitem:ac60851b0fad3cc7d11289811fd942728"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TImage &gt; </td></tr>
<tr class="memitem:ac60851b0fad3cc7d11289811fd942728"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac60851b0fad3cc7d11289811fd942728">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1FrontierPredicate.html">FrontierPredicate</a>&lt; TKSpace, TImage &gt; &amp;object)</td></tr>
<tr class="memitem:a1b2bc070ca54bd515c2948faae24b179"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace &gt; </td></tr>
<tr class="memitem:a1b2bc070ca54bd515c2948faae24b179"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1b2bc070ca54bd515c2948faae24b179">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a>&lt; TKSpace &gt; &amp;object)</td></tr>
<tr class="memitem:aa8c04085996bfcb483774f35e6a6ffda"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TPointPredicate &gt; </td></tr>
<tr class="memitem:aa8c04085996bfcb483774f35e6a6ffda"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa8c04085996bfcb483774f35e6a6ffda">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1ImplicitDigitalSurface.html">ImplicitDigitalSurface</a>&lt; TKSpace, TPointPredicate &gt; &amp;object)</td></tr>
<tr class="memitem:a105d0f6359b68e48600e22cf765f4aaa"><td class="memTemplParams" colspan="2">template&lt;Dimension dim, typename TInteger &gt; </td></tr>
<tr class="memitem:a105d0f6359b68e48600e22cf765f4aaa"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a105d0f6359b68e48600e22cf765f4aaa">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1KhalimskyCell.html">KhalimskyCell</a>&lt; dim, TInteger &gt; &amp;object)</td></tr>
<tr class="memitem:a075acfb401c86aea97863e49764f7e74"><td class="memTemplParams" colspan="2">template&lt;Dimension dim, typename TInteger &gt; </td></tr>
<tr class="memitem:a075acfb401c86aea97863e49764f7e74"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a075acfb401c86aea97863e49764f7e74">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structDGtal_1_1SignedKhalimskyCell.html">SignedKhalimskyCell</a>&lt; dim, TInteger &gt; &amp;object)</td></tr>
<tr class="memitem:ac9d84c5b0391cb2973795d314b7a26ca"><td class="memTemplParams" colspan="2">template&lt;Dimension dim, typename TInteger &gt; </td></tr>
<tr class="memitem:ac9d84c5b0391cb2973795d314b7a26ca"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ac9d84c5b0391cb2973795d314b7a26ca">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1KhalimskySpaceND.html">KhalimskySpaceND</a>&lt; dim, TInteger &gt; &amp;object)</td></tr>
<tr class="memitem:a55f2044bafa880126f92373e30027115"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TSurfelPredicate &gt; </td></tr>
<tr class="memitem:a55f2044bafa880126f92373e30027115"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a55f2044bafa880126f92373e30027115">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1LightExplicitDigitalSurface.html">LightExplicitDigitalSurface</a>&lt; TKSpace, TSurfelPredicate &gt; &amp;object)</td></tr>
<tr class="memitem:a5694066261d35cce4631775ccc2596e4"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TPointPredicate &gt; </td></tr>
<tr class="memitem:a5694066261d35cce4631775ccc2596e4"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a5694066261d35cce4631775ccc2596e4">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1LightImplicitDigitalSurface.html">LightImplicitDigitalSurface</a>&lt; TKSpace, TPointPredicate &gt; &amp;object)</td></tr>
<tr class="memitem:aa8e4002c881f8a192a8185c3a0a80d1e"><td class="memTemplParams" colspan="2">template&lt;typename TSpace , Dimension maxNorm1&gt; </td></tr>
<tr class="memitem:aa8e4002c881f8a192a8185c3a0a80d1e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aa8e4002c881f8a192a8185c3a0a80d1e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1MetricAdjacency.html">MetricAdjacency</a>&lt; TSpace, maxNorm1, TSpace::dimension &gt; &amp;object)</td></tr>
<tr class="memitem:ad3071ce24e8bfd8044515d2e8bf31b0a"><td class="memTemplParams" colspan="2">template&lt;typename TDigitalTopology , typename TDigitalSet &gt; </td></tr>
<tr class="memitem:ad3071ce24e8bfd8044515d2e8bf31b0a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ad3071ce24e8bfd8044515d2e8bf31b0a">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1Object.html">Object</a>&lt; TDigitalTopology, TDigitalSet &gt; &amp;object)</td></tr>
<tr class="memitem:a25bbd127be81b65901f94e0247fbd4b9"><td class="memTemplParams" colspan="2">template&lt;typename TKSpace , typename TSurfelSet &gt; </td></tr>
<tr class="memitem:a25bbd127be81b65901f94e0247fbd4b9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a25bbd127be81b65901f94e0247fbd4b9">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1SetOfSurfels.html">SetOfSurfels</a>&lt; TKSpace, TSurfelSet &gt; &amp;object)</td></tr>
<tr class="memitem:a1f268b8a695128c059e37512d115571f"><td class="memTemplParams" colspan="2">template&lt;Dimension dim&gt; </td></tr>
<tr class="memitem:a1f268b8a695128c059e37512d115571f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a1f268b8a695128c059e37512d115571f">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; dim &gt; &amp;object)</td></tr>
<tr class="memitem:acbfc586cb4ecd8bb0b1a787a84cb82d6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acbfc586cb4ecd8bb0b1a787a84cb82d6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#acbfc586cb4ecd8bb0b1a787a84cb82d6">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1SurfelNeighborhood.html">SurfelNeighborhood</a>&lt; T &gt; &amp;object)</td></tr>
<tr class="memitem:a581d2514f85e3cc8a8c5833991207fe4"><td class="memTemplParams" colspan="2">template&lt;typename TDigitalSurfaceTracker &gt; </td></tr>
<tr class="memitem:a581d2514f85e3cc8a8c5833991207fe4"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a581d2514f85e3cc8a8c5833991207fe4">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classDGtal_1_1UmbrellaComputer.html">UmbrellaComputer</a>&lt; TDigitalSurfaceTracker &gt; &amp;object)</td></tr>
<tr class="memitem:a9d0c060685d6e9a49445a562a99c5286"><td class="memTemplParams" colspan="2">template&lt;typename KSpace , typename PointPredicate &gt; </td></tr>
<tr class="memitem:a9d0c060685d6e9a49445a562a99c5286"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a9d0c060685d6e9a49445a562a99c5286">testImplicitDigitalSurface</a> (const KSpace &amp;K, const PointPredicate &amp;pp, const typename KSpace::Surfel &amp;bel)</td></tr>
<tr class="memitem:a08886ee117009e48c66e4349c7c47265"><td class="memTemplParams" colspan="2">template&lt;typename KSpace , typename PointPredicate &gt; </td></tr>
<tr class="memitem:a08886ee117009e48c66e4349c7c47265"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a08886ee117009e48c66e4349c7c47265">testLightImplicitDigitalSurface</a> (const KSpace &amp;K, const PointPredicate &amp;pp, const typename KSpace::Surfel &amp;bel)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7df3f0545c8e59b83394c60601c122e3"><td class="memItemLeft" align="right" valign="top">It also possible to remove the <br class="typebreak"/>
visualisation of the <br class="typebreak"/>
transparent clipping plane by <br class="typebreak"/>
adding boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a7df3f0545c8e59b83394c60601c122e3">option</a></td></tr>
<tr class="memitem:a3c1454fe50af31341c890919f93b76b6"><td class="memItemLeft" align="right" valign="top">It also possible to remove the <br class="typebreak"/>
visualisation of the <br class="typebreak"/>
transparent clipping plane by <br class="typebreak"/>
adding boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a3c1454fe50af31341c890919f93b76b6">false</a></td></tr>
<tr class="memitem:aad0fa31bef8d6552db900af1809d787d"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal.html#a40f198468aea6d0121b11cd49e599e92">BoolFunction0</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#aad0fa31bef8d6552db900af1809d787d">trueBF0</a> = <a class="el" href="structDGtal_1_1TrueBoolFct0.html">TrueBoolFct0</a>()</td></tr>
<tr class="memitem:a8c0dbf38da6779899ca99fc25ec8b0be"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal.html#a40f198468aea6d0121b11cd49e599e92">BoolFunction0</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a8c0dbf38da6779899ca99fc25ec8b0be">falseBF0</a> = <a class="el" href="structDGtal_1_1FalseBoolFct0.html">FalseBoolFct0</a>()</td></tr>
<tr class="memitem:a154eac21029f20806b646b025b6d59a0"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal.html#a9a92f37472d9010932be3fe6d28f94cb">BoolFunction1</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a154eac21029f20806b646b025b6d59a0">identityBF1</a> = <a class="el" href="structDGtal_1_1IdentityBoolFct1.html">IdentityBoolFct1</a>()</td></tr>
<tr class="memitem:a31614f15cda0ab53c57cf414e48c149f"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal.html#a9a92f37472d9010932be3fe6d28f94cb">BoolFunction1</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a31614f15cda0ab53c57cf414e48c149f">notBF1</a> = <a class="el" href="structDGtal_1_1NotBoolFct1.html">NotBoolFct1</a>()</td></tr>
<tr class="memitem:a70c28100eb4618dbb59a4080cbdf383b"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">BoolFunction2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a70c28100eb4618dbb59a4080cbdf383b">andBF2</a> = <a class="el" href="structDGtal_1_1AndBoolFct2.html">AndBoolFct2</a>()</td></tr>
<tr class="memitem:a14f119bf8a5eb80a58870ebbd33bfb07"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">BoolFunction2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a14f119bf8a5eb80a58870ebbd33bfb07">orBF2</a> = <a class="el" href="structDGtal_1_1OrBoolFct2.html">OrBoolFct2</a>()</td></tr>
<tr class="memitem:a29281e7462720aa5d454fa2355baa0f3"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">BoolFunction2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a29281e7462720aa5d454fa2355baa0f3">xorBF2</a> = <a class="el" href="structDGtal_1_1XorBoolFct2.html">XorBoolFct2</a>()</td></tr>
<tr class="memitem:af22fdd40c268d4270906236e3ce234cb"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">BoolFunction2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#af22fdd40c268d4270906236e3ce234cb">impliesBF2</a> = <a class="el" href="structDGtal_1_1ImpliesBoolFct2.html">ImpliesBoolFct2</a>()</td></tr>
<tr class="memitem:ae801de7ee4d22c47257dc7e00e0c5dd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1TraceWriterTerm.html">TraceWriterTerm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#ae801de7ee4d22c47257dc7e00e0c5dd7">traceWriterTerm</a> (std::cerr)</td></tr>
<tr class="memitem:a604c07ec391ad12a1f3fb6479993f112"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1Trace.html">Trace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a> (<a class="el" href="namespaceDGtal.html#ae801de7ee4d22c47257dc7e00e0c5dd7">traceWriterTerm</a>)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Aim: Defines the concept describing a bidirectional const range. </p>
<p><code><a class="el" href="namespaceDGtal.html" title="Aim: Defines the concept describing a bidirectional const range.">DGtal</a></code> is the top-level namespace which contains all <a class="el" href="namespaceDGtal.html" title="Aim: Defines the concept describing a bidirectional const range.">DGtal</a> functions and types.</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
<dl class="section author"><dt>Author:</dt><dd>Jacques-Olivier Lachaud (<code><a href="#" onclick="location.href='mai'+'lto:'+'jac'+'qu'+'es-'+'ol'+'ivi'+'er'+'.la'+'ch'+'aud'+'@u'+'niv'+'-s'+'avo'+'ie'+'.fr'; return false;">jacqu<span style="display: none;">.nosp@m.</span>es-o<span style="display: none;">.nosp@m.</span>livie<span style="display: none;">.nosp@m.</span>r.la<span style="display: none;">.nosp@m.</span>chaud<span style="display: none;">.nosp@m.</span>@uni<span style="display: none;">.nosp@m.</span>v-sav<span style="display: none;">.nosp@m.</span>oie.<span style="display: none;">.nosp@m.</span>fr</a></code> ) Laboratory of Mathematics (CNRS, UMR 5807), University of Savoie, France</dd></dl>
<dl class="section date"><dt>Date:</dt><dd>2011/09/19</dd></dl>
<p>Documentation file for feature Geometric</p>
<p>This file is part of the <a class="el" href="namespaceDGtal.html" title="Aim: Defines the concept describing a bidirectional const range.">DGtal</a> library.</p>
<p>DescriptionDescription of <b>concept</b> '<b><a class="el" href="structDGtal_1_1CConstBidirectionalRange.html">CConstBidirectionalRange</a>'</b> </p>
<h3>Refinement of</h3>
<p><a class="el" href="structDGtal_1_1CConstSinglePassRange.html" title="Aim: Defines the concept describing a const range.">CConstSinglePassRange</a></p>
<h3>Provided types :</h3>
<ul>
<li>ConstReverseIterator: the const reverse iterator type, a model of const iterator concept.</li>
</ul>
<table class="doxtable">
<tr>
<td class="CName"><b>Name</b>  </td><td class="CExpression"><b>Expression</b>  </td><td class="CRequirements"><b>Type</b> requirements  </td><td class="CReturnType"><b>Return</b> type  </td><td class="CPrecondition"><b>Precondition</b>  </td><td class="CSemantics"><b>Semantics</b>  </td><td class="CPostCondition"><b>Postcondition</b>  </td><td class="CComplexity"><b>Complexity</b>   </td></tr>
<tr>
<td class="CName">rbegin  </td><td class="CExpression">x.rbegin() const </td><td class="CRequirements"></td><td class="CReturnType">ConstReverseIterator </td><td class="CPrecondition"></td><td class="CSemantics"></td><td class="CPostCondition"></td><td class="CComplexity"></td></tr>
<tr>
<td class="CName">rend  </td><td class="CExpression">x.rend() const </td><td class="CRequirements"></td><td class="CReturnType">ConstReverseIterator </td><td class="CPrecondition"></td><td class="CSemantics"></td><td class="CPostCondition"></td><td class="CComplexity"></td></tr>
</table>
<h3>Invariants</h3>
<h3>Models</h3>
<h3>Notes</h3>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">T</td><td>the type that is checked. T should be a model of <a class="el" href="structDGtal_1_1CConstBidirectionalRange.html">CConstBidirectionalRange</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="namespaceDGtal.html" title="Aim: Defines the concept describing a bidirectional const range.">DGtal</a> Global variables </p>
</div><hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a40f198468aea6d0121b11cd49e599e92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function0&lt; bool &gt; <a class="el" href="namespaceDGtal.html#a40f198468aea6d0121b11cd49e599e92">DGtal::BoolFunction0</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>May hold bool functions taking no arguments. </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00053">53</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9a92f37472d9010932be3fe6d28f94cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function1&lt; bool, bool &gt; <a class="el" href="namespaceDGtal.html#a9a92f37472d9010932be3fe6d28f94cb">DGtal::BoolFunction1</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>May hold bool functions taking one bool argument. </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00058">58</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7d57d4419aa9656ae4be838f903b5dd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function2&lt; bool, bool, bool &gt; <a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">DGtal::BoolFunction2</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>May hold bool functions taking two bool arguments. </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00063">63</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1bbf050f10f3c666dc5e170e893d8e57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function3&lt; bool, bool, bool, bool &gt; <a class="el" href="namespaceDGtal.html#a1bbf050f10f3c666dc5e170e893d8e57">DGtal::BoolFunction3</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>May hold bool functions taking three bool arguments (Useful ?). </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00068">68</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8fbe8c8d47ca5c36ced14284ac62613d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespaceDGtal.html#a27c59126488e9c545120667959d2fc4e">DGtal::uint32_t</a> <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">DGtal::Dimension</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Global static type to represent the dimension in <a class="el" href="namespaceDGtal.html" title="Aim: Defines the concept describing a bidirectional const range.">DGtal</a> </p>

<p>Definition at line <a class="el" href="Common_8h_source.html#l00127">127</a> of file <a class="el" href="Common_8h_source.html">Common.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac62de8348789e05494b7515c6525baa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::int16_t <a class="el" href="namespaceDGtal.html#ac62de8348789e05494b7515c6525baa0">DGtal::int16_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>signed 16-bit integer. </p>

<p>Definition at line <a class="el" href="BasicTypes_8h_source.html#l00071">71</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac1e9ac6a329319ae13c51c0c9e92486a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::int32_t <a class="el" href="namespaceDGtal.html#ac1e9ac6a329319ae13c51c0c9e92486a">DGtal::int32_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>signed 32-bit integer. </p>

<p>Definition at line <a class="el" href="BasicTypes_8h_source.html#l00073">73</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1c09e3f63904ff371f1b99f45069fc63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::int64_t <a class="el" href="namespaceDGtal.html#a1c09e3f63904ff371f1b99f45069fc63">DGtal::int64_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>signed 94-bit integer. </p>

<p>Definition at line <a class="el" href="BasicTypes_8h_source.html#l00075">75</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac28d51e0b1672afa52b3c218a32a6a01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::int8_t <a class="el" href="namespaceDGtal.html#ac28d51e0b1672afa52b3c218a32a6a01">DGtal::int8_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>signed 8-bit integer. </p>

<p>Definition at line <a class="el" href="BasicTypes_8h_source.html#l00069">69</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a class="anchor" id="a30f912c6a9d587320495d627df2719ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::uint16_t <a class="el" href="namespaceDGtal.html#a30f912c6a9d587320495d627df2719ba">DGtal::uint16_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>unsigned 16-bit integer. </p>

<p>Definition at line <a class="el" href="BasicTypes_8h_source.html#l00062">62</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a class="anchor" id="a27c59126488e9c545120667959d2fc4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::uint32_t <a class="el" href="namespaceDGtal.html#a27c59126488e9c545120667959d2fc4e">DGtal::uint32_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>unsigned 32-bit integer. </p>

<p>Definition at line <a class="el" href="BasicTypes_8h_source.html#l00064">64</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab33c0c25b8cc3cd86de343bca34329f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::uint64_t <a class="el" href="namespaceDGtal.html#ab33c0c25b8cc3cd86de343bca34329f5">DGtal::uint64_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>unsigned 64-bit integer. </p>

<p>Definition at line <a class="el" href="BasicTypes_8h_source.html#l00066">66</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3f01c0f785c605d021be8e328180f502"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::uint8_t <a class="el" href="namespaceDGtal.html#a3f01c0f785c605d021be8e328180f502">DGtal::uint8_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>unsigned 8-bit integer. </p>

<p>Definition at line <a class="el" href="BasicTypes_8h_source.html#l00060">60</a> of file <a class="el" href="BasicTypes_8h_source.html">BasicTypes.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a65228f031a436d2f4edd698ae733ba31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31">DGtal::BoundEnum</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a65228f031a436d2f4edd698ae733ba31a4b4e195031215bcfc63b5bf65c1c1035"></a>BOUNDED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a65228f031a436d2f4edd698ae733ba31a1906bfa4ce33f3c129b1e974826f686d"></a>UNBOUNDED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a65228f031a436d2f4edd698ae733ba31aec51247a223f33a421840eb3cbd5598e"></a>BOUND_UNKNOWN</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="NumberTraits_8h_source.html#l00055">55</a> of file <a class="el" href="NumberTraits_8h_source.html">NumberTraits.h</a>.</p>
<div class="fragment"><pre class="fragment">{<a class="code" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31a4b4e195031215bcfc63b5bf65c1c1035">BOUNDED</a> = 0, <a class="code" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31a1906bfa4ce33f3c129b1e974826f686d">UNBOUNDED</a> = 1, <a class="code" href="namespaceDGtal.html#a65228f031a436d2f4edd698ae733ba31aec51247a223f33a421840eb3cbd5598e">BOUND_UNKNOWN</a> = 2};
</pre></div>
</div>
</div>
<a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2">DGtal::ColorGradientPreset</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2a97a652eb81107a63d65d0d091f48e320"></a>CMAP_CUSTOM</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2a03f20e9e057e38ce03220e2a43b1a366"></a>CMAP_GRAYSCALE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2ad222787b0de6a7d74f0e403da496266c"></a>CMAP_SPRING</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2aa5b0ef9d5b1e2e496ac149d9a42dd3e7"></a>CMAP_SUMMER</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2a3ff3c09197871bad3bb5921e30223533"></a>CMAP_AUTUMN</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2acd0da059abca1decd6b75ecc6d131be7"></a>CMAP_WINTER</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2a40d9e19d8fbedda0f45c0673c6c6dcbf"></a>CMAP_COOL</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2a2b8eab305f63590e49a6dab0b628ae33"></a>CMAP_COPPER</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2a075659185495ce61ea5b09ab439e2abe"></a>CMAP_HOT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa68309838cffd86a3c671c44ef129cb2ac677c31e4299bc29c4e591063b4fc9bb"></a>CMAP_JET</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="GradientColorMap_8h_source.html#l00060">60</a> of file <a class="el" href="GradientColorMap_8h_source.html">GradientColorMap.h</a>.</p>
<div class="fragment"><pre class="fragment">                           { <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a97a652eb81107a63d65d0d091f48e320">CMAP_CUSTOM</a> = 0,
           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a03f20e9e057e38ce03220e2a43b1a366">CMAP_GRAYSCALE</a>,
           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2ad222787b0de6a7d74f0e403da496266c">CMAP_SPRING</a>,
           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2aa5b0ef9d5b1e2e496ac149d9a42dd3e7">CMAP_SUMMER</a>,
           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a3ff3c09197871bad3bb5921e30223533">CMAP_AUTUMN</a>,
           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2acd0da059abca1decd6b75ecc6d131be7">CMAP_WINTER</a>,
           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a40d9e19d8fbedda0f45c0673c6c6dcbf">CMAP_COOL</a>,
           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a2b8eab305f63590e49a6dab0b628ae33">CMAP_COPPER</a>,
           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2a075659185495ce61ea5b09ab439e2abe">CMAP_HOT</a>,
           <a class="code" href="namespaceDGtal.html#aa68309838cffd86a3c671c44ef129cb2ac677c31e4299bc29c4e591063b4fc9bb">CMAP_JET</a> };
</pre></div>
</div>
</div>
<a class="anchor" id="a5df441c76f46779791d077a80f0b902e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a5df441c76f46779791d077a80f0b902e">DGtal::Connectedness</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Kinds of connectedness for an object or a graph. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a5df441c76f46779791d077a80f0b902ea3188ed38ab448384424887958f44beea"></a>DISCONNECTED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5df441c76f46779791d077a80f0b902ea71b8166fccee5ea03cd61a4a9b3ece1a"></a>CONNECTED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5df441c76f46779791d077a80f0b902ea01966050c6ac7ceb9818c946cd229fc4"></a>UNKNOWN</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="Topology_8h_source.html#l00050">50</a> of file <a class="el" href="Topology_8h_source.html">Topology.h</a>.</p>
<div class="fragment"><pre class="fragment">    {
      <a class="code" href="namespaceDGtal.html#a5df441c76f46779791d077a80f0b902ea3188ed38ab448384424887958f44beea">DISCONNECTED</a> = 0, <a class="code" href="namespaceDGtal.html#a5df441c76f46779791d077a80f0b902ea71b8166fccee5ea03cd61a4a9b3ece1a">CONNECTED</a> = 1, <a class="code" href="namespaceDGtal.html#a5df441c76f46779791d077a80f0b902ea01966050c6ac7ceb9818c946cd229fc4">UNKNOWN</a> = 2
    };
</pre></div>
</div>
</div>
<a class="anchor" id="a0f37e197740e9d7742426109610c513a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a0f37e197740e9d7742426109610c513a">DGtal::DigitalSetBelongTestability</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a0f37e197740e9d7742426109610c513aac54bafeace89b71100756e99a7ef368e"></a>LOW_BEL_DS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0f37e197740e9d7742426109610c513aadcca3a30244180b4238a80ae3a06e01d"></a>HIGH_BEL_DS</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="DigitalSetSelector_8h_source.html#l00060">60</a> of file <a class="el" href="DigitalSetSelector_8h_source.html">DigitalSetSelector.h</a>.</p>
<div class="fragment"><pre class="fragment">{ <a class="code" href="namespaceDGtal.html#a0f37e197740e9d7742426109610c513aac54bafeace89b71100756e99a7ef368e">LOW_BEL_DS</a> = 0, <a class="code" href="namespaceDGtal.html#a0f37e197740e9d7742426109610c513aadcca3a30244180b4238a80ae3a06e01d">HIGH_BEL_DS</a> = 16 };
</pre></div>
</div>
</div>
<a class="anchor" id="abae5017e6f3a3d5e0c4debd8142e8ccc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#abae5017e6f3a3d5e0c4debd8142e8ccc">DGtal::DigitalSetIterability</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="abae5017e6f3a3d5e0c4debd8142e8ccca73f1c02534747463a70f05e94ad50b3d"></a>LOW_ITER_DS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="abae5017e6f3a3d5e0c4debd8142e8ccca0f85b8033e1532f5c4a0ff3d59a187bc"></a>HIGH_ITER_DS</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="DigitalSetSelector_8h_source.html#l00059">59</a> of file <a class="el" href="DigitalSetSelector_8h_source.html">DigitalSetSelector.h</a>.</p>
<div class="fragment"><pre class="fragment">{ <a class="code" href="namespaceDGtal.html#abae5017e6f3a3d5e0c4debd8142e8ccca73f1c02534747463a70f05e94ad50b3d">LOW_ITER_DS</a> = 0, <a class="code" href="namespaceDGtal.html#abae5017e6f3a3d5e0c4debd8142e8ccca0f85b8033e1532f5c4a0ff3d59a187bc">HIGH_ITER_DS</a> = 8 };
</pre></div>
</div>
</div>
<a class="anchor" id="a07a2f5d6c861cd13dd680ea2e64e2dd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4">DGtal::DigitalSetSize</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a07a2f5d6c861cd13dd680ea2e64e2dd4acf48b00343e26a7f40a1fdbbc7af4d70"></a>SMALL_DS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a07a2f5d6c861cd13dd680ea2e64e2dd4a0df10d7a38d07b6795da39a66cbe97cc"></a>MEDIUM_DS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a07a2f5d6c861cd13dd680ea2e64e2dd4a37af4f429983b8069af58a2334f776a0"></a>BIG_DS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a07a2f5d6c861cd13dd680ea2e64e2dd4ac6f14eff3712732f6fa6d608f11e79fe"></a>WHOLE_DS</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="DigitalSetSelector_8h_source.html#l00057">57</a> of file <a class="el" href="DigitalSetSelector_8h_source.html">DigitalSetSelector.h</a>.</p>
<div class="fragment"><pre class="fragment">{ <a class="code" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4acf48b00343e26a7f40a1fdbbc7af4d70">SMALL_DS</a> = 0, <a class="code" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4a0df10d7a38d07b6795da39a66cbe97cc">MEDIUM_DS</a> = 1, <a class="code" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4a37af4f429983b8069af58a2334f776a0">BIG_DS</a> = 2, <a class="code" href="namespaceDGtal.html#a07a2f5d6c861cd13dd680ea2e64e2dd4ac6f14eff3712732f6fa6d608f11e79fe">WHOLE_DS</a> = 3 };
</pre></div>
</div>
</div>
<a class="anchor" id="ae37267b68e31ee8f7531488f7e88426a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#ae37267b68e31ee8f7531488f7e88426a">DGtal::DigitalSetVariability</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ae37267b68e31ee8f7531488f7e88426aa453acc6bba092ef2476618fad08d47f3"></a>LOW_VAR_DS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae37267b68e31ee8f7531488f7e88426aabef0d75c93891808eaa54c78aa08484a"></a>HIGH_VAR_DS</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="DigitalSetSelector_8h_source.html#l00058">58</a> of file <a class="el" href="DigitalSetSelector_8h_source.html">DigitalSetSelector.h</a>.</p>
<div class="fragment"><pre class="fragment">{ <a class="code" href="namespaceDGtal.html#ae37267b68e31ee8f7531488f7e88426aa453acc6bba092ef2476618fad08d47f3">LOW_VAR_DS</a> = 0, <a class="code" href="namespaceDGtal.html#ae37267b68e31ee8f7531488f7e88426aabef0d75c93891808eaa54c78aa08484a">HIGH_VAR_DS</a> = 4 };
</pre></div>
</div>
</div>
<a class="anchor" id="a9f57dcd68d3056024eec6b4205f7083d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083d">DGtal::DigitalTopologyProperties</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Possible properties of digital topologies. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a9f57dcd68d3056024eec6b4205f7083dabce62ac78855e24784c74bdd7d8e4e88"></a>UNKNOWN_DT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9f57dcd68d3056024eec6b4205f7083da76d2c48b4a35a0dcb5ca4e6cf2462ff0"></a>NOT_JORDAN_DT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9f57dcd68d3056024eec6b4205f7083da731ee8276af4e05e2fe322cf2a4fd179"></a>JORDAN_DT</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="DigitalTopology_8h_source.html#l00054">54</a> of file <a class="el" href="DigitalTopology_8h_source.html">DigitalTopology.h</a>.</p>
<div class="fragment"><pre class="fragment">                                 { <a class="code" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083dabce62ac78855e24784c74bdd7d8e4e88">UNKNOWN_DT</a> = 0, 
           <a class="code" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083da76d2c48b4a35a0dcb5ca4e6cf2462ff0">NOT_JORDAN_DT</a> = 1,
           <a class="code" href="namespaceDGtal.html#a9f57dcd68d3056024eec6b4205f7083da731ee8276af4e05e2fe322cf2a4fd179">JORDAN_DT</a> = 2 };
</pre></div>
</div>
</div>
<a class="anchor" id="a2526218ffac7b4842d393facbedd9ee3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a2526218ffac7b4842d393facbedd9ee3">DGtal::DomainDrawMode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specifies the drawing mode for domains. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a2526218ffac7b4842d393facbedd9ee3a6cfb206d9d6225066329a79e83db654e"></a>GRID</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a2526218ffac7b4842d393facbedd9ee3ad788351651a8e983ca1b5b30861ad8ba"></a>PAVING</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="Board2D_8h_source.html#l00057">57</a> of file <a class="el" href="Board2D_8h_source.html">Board2D.h</a>.</p>
<div class="fragment"><pre class="fragment">{ <a class="code" href="namespaceDGtal.html#a2526218ffac7b4842d393facbedd9ee3a6cfb206d9d6225066329a79e83db654e">GRID</a> = 0, <a class="code" href="namespaceDGtal.html#a2526218ffac7b4842d393facbedd9ee3ad788351651a8e983ca1b5b30861ad8ba">PAVING</a> = 1 };
</pre></div>
</div>
</div>
<a class="anchor" id="afbda75b83fdb9094d0e38931838c8d6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#afbda75b83fdb9094d0e38931838c8d6a">DGtal::ImageBelongTestability</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="afbda75b83fdb9094d0e38931838c8d6aa3417447f6aa436ccbf37e0c359adac12"></a>HIGH_BEL_I</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afbda75b83fdb9094d0e38931838c8d6aa5bb4ca524cc66ff98e8b4ad4b4138630"></a>LOW_BEL_I</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="ImageSelector_8h_source.html#l00055">55</a> of file <a class="el" href="ImageSelector_8h_source.html">ImageSelector.h</a>.</p>
<div class="fragment"><pre class="fragment">{  <a class="code" href="namespaceDGtal.html#afbda75b83fdb9094d0e38931838c8d6aa3417447f6aa436ccbf37e0c359adac12">HIGH_BEL_I</a> = 0, <a class="code" href="namespaceDGtal.html#afbda75b83fdb9094d0e38931838c8d6aa5bb4ca524cc66ff98e8b4ad4b4138630">LOW_BEL_I</a> = 2 };
</pre></div>
</div>
</div>
<a class="anchor" id="a7f3384cac6dea91b4d46cc1421854dda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a7f3384cac6dea91b4d46cc1421854dda">DGtal::ImageIterability</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a7f3384cac6dea91b4d46cc1421854ddaacf7975d858b926cba1cc047885d1765c"></a>HIGH_ITER_IMAGE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a7f3384cac6dea91b4d46cc1421854ddaa66f45381ecc834daac482ee3493a79f7"></a>LOW_ITER_I</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="ImageSelector_8h_source.html#l00054">54</a> of file <a class="el" href="ImageSelector_8h_source.html">ImageSelector.h</a>.</p>
<div class="fragment"><pre class="fragment">{  <a class="code" href="namespaceDGtal.html#a7f3384cac6dea91b4d46cc1421854ddaacf7975d858b926cba1cc047885d1765c">HIGH_ITER_IMAGE</a> = 0 , <a class="code" href="namespaceDGtal.html#a7f3384cac6dea91b4d46cc1421854ddaa66f45381ecc834daac482ee3493a79f7">LOW_ITER_I</a> = 1};
</pre></div>
</div>
</div>
<a class="anchor" id="a0a142484d2c7efc3d29f5bbde3b449b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a0a142484d2c7efc3d29f5bbde3b449b7">DGtal::ImageSpecificContainer</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a0a142484d2c7efc3d29f5bbde3b449b7a0a9f2a6126427332825d75e775f59388"></a>NORMAL_CONTAINER_I</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0a142484d2c7efc3d29f5bbde3b449b7ad4deed74c04fa5f801b7c2638d536c1d"></a>VTKIMAGEDATA_CONTAINER_I</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="ImageSelector_8h_source.html#l00056">56</a> of file <a class="el" href="ImageSelector_8h_source.html">ImageSelector.h</a>.</p>
<div class="fragment"><pre class="fragment">{ <a class="code" href="namespaceDGtal.html#a0a142484d2c7efc3d29f5bbde3b449b7a0a9f2a6126427332825d75e775f59388">NORMAL_CONTAINER_I</a> = 0, <a class="code" href="namespaceDGtal.html#a0a142484d2c7efc3d29f5bbde3b449b7ad4deed74c04fa5f801b7c2638d536c1d">VTKIMAGEDATA_CONTAINER_I</a> = 4 };
</pre></div>
</div>
</div>
<a class="anchor" id="a9f6cc75dc44e45506a66cd233e0deb41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41">DGtal::Orientation</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Global enum definition for orientation. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a9f6cc75dc44e45506a66cd233e0deb41a528af0eaf947edc94796219523aa9553"></a>INSIDE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9f6cc75dc44e45506a66cd233e0deb41a7671a5416d92f37137f9999ca23dd65e"></a>ON</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a9f6cc75dc44e45506a66cd233e0deb41a5f4bdeccc29812b7de1cc0c05b724734"></a>OUTSIDE</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="Common_8h_source.html#l00132">132</a> of file <a class="el" href="Common_8h_source.html">Common.h</a>.</p>
<div class="fragment"><pre class="fragment">{ <a class="code" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41a528af0eaf947edc94796219523aa9553">INSIDE</a> = 0, <a class="code" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41a7671a5416d92f37137f9999ca23dd65e">ON</a> = 1, <a class="code" href="namespaceDGtal.html#a9f6cc75dc44e45506a66cd233e0deb41a5f4bdeccc29812b7de1cc0c05b724734">OUTSIDE</a> = 2};
</pre></div>
</div>
</div>
<a class="anchor" id="a679e16b34aad98ff340decf89d1c86db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86db">DGtal::SignEnum</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a679e16b34aad98ff340decf89d1c86dbae3e0717ad611faed845dd64931b1f99c"></a>SIGNED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a679e16b34aad98ff340decf89d1c86dba4e5cd9a9d62617341034f3f1c0f79b32"></a>UNSIGNED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a679e16b34aad98ff340decf89d1c86dba23888a413fb400a53deeb0b0e17d3100"></a>SIGN_UNKNOWN</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="NumberTraits_8h_source.html#l00056">56</a> of file <a class="el" href="NumberTraits_8h_source.html">NumberTraits.h</a>.</p>
<div class="fragment"><pre class="fragment">{<a class="code" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86dbae3e0717ad611faed845dd64931b1f99c">SIGNED</a> = 0, <a class="code" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86dba4e5cd9a9d62617341034f3f1c0f79b32">UNSIGNED</a> = 1, <a class="code" href="namespaceDGtal.html#a679e16b34aad98ff340decf89d1c86dba23888a413fb400a53deeb0b0e17d3100">SIGN_UNKNOWN</a> = 2};
</pre></div>
</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a54cd4c3ec97c9ec323a52de71339f589"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="namespaceDGtal.html#a54cd4c3ec97c9ec323a52de71339f589">DGtal::abs</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the absolute value of an instance of type T.</p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">T</td><td>the type of elements to compare (model of boost::LessThanComparable). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the absolute value |a|. </dd></dl>

<p>Definition at line <a class="el" href="GlobalFunctions_8h_source.html#l00105">105</a> of file <a class="el" href="GlobalFunctions_8h_source.html">GlobalFunctions.h</a>.</p>

<p>Referenced by <a class="el" href="Display3D_8ih_source.html#l00559">DGtal::Display3D::addClippingPlane()</a>, <a class="el" href="IntegerComputer_8ih_source.html#l00410">DGtal::IntegerComputer&lt; TInteger &gt;::extendedEuclid()</a>, <a class="el" href="SeparableMetricHelper_8h_source.html#l00117">DGtal::SeparableMetricHelper&lt; Abscissa, IntegerLong, p &gt;::F()</a>, <a class="el" href="IntegerComputer_8ih_source.html#l00246">DGtal::IntegerComputer&lt; TInteger &gt;::gcd()</a>, <a class="el" href="IntegerComputer_8ih_source.html#l00265">DGtal::IntegerComputer&lt; TInteger &gt;::getGcd()</a>, <a class="el" href="CircleFrom3Points_8ih_source.html#l00121">DGtal::CircleFrom3Points&lt; TPoint &gt;::getParameters()</a>, <a class="el" href="FMM_8ih_source.html#l00177">DGtal::FMM&lt; TImage, TSet, TPointPredicate, TPointFunctor &gt;::initFromBelsRange()</a>, <a class="el" href="Viewer3D_8cpp_source.html#l00267">DGtal::Viewer3D::postSelection()</a>, <a class="el" href="SeparableMetricHelper_8h_source.html#l00303">DGtal::SeparableMetricHelper&lt; TAbscissa, TInternalValue, 1 &gt;::power()</a>, <a class="el" href="SeparableMetricHelper_8h_source.html#l00360">DGtal::SeparableMetricHelper&lt; TAbscissa, TInternalValue, 0 &gt;::power()</a>, <a class="el" href="SeparableMetricHelper_8h_source.html#l00133">DGtal::SeparableMetricHelper&lt; Abscissa, IntegerLong, p &gt;::reversedF()</a>, and <a class="el" href="SeparableMetricHelper_8h_source.html#l00274">DGtal::SeparableMetricHelper&lt; TAbscissa, TInternalValue, 1 &gt;::reversedF()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    BOOST_CONCEPT_ASSERT((boost::LessThanComparable&lt;T&gt;));
    <span class="keywordflow">if</span> (a&lt;0) 
      <span class="keywordflow">return</span> -a;
    <span class="keywordflow">else</span>
      <span class="keywordflow">return</span> a;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a7b632be90297f1d6a81a58c1a0a4bdc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="namespaceDGtal.html#a7b632be90297f1d6a81a58c1a0a4bdc3">DGtal::cross</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dst</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>srcA</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>srcB</em>[3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the cross product of two 3d vectors and return it. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>destination vector. </td></tr>
    <tr><td class="paramname">srcA</td><td>source vector A. </td></tr>
    <tr><td class="paramname">srcB</td><td>source vector B. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Display3D_8ih_source.html#l00058">58</a> of file <a class="el" href="Display3D_8ih_source.html">Display3D.ih</a>.</p>

<p>Referenced by <a class="el" href="Display3D_8ih_source.html#l00297">DGtal::Display3D::addKSSurfel()</a>.</p>
<div class="fragment"><pre class="fragment">{
  dst[0] = srcA[1]*srcB[2] - srcA[2]*srcB[1];
  dst[1] = srcA[2]*srcB[0] - srcA[0]*srcB[2];
  dst[2] = srcA[0]*srcB[1] - srcA[1]*srcB[0];
}
</pre></div>
</div>
</div>
<a class="anchor" id="afd55a2a73cd7b4552dbaf0b62980b323"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, int n, typename Ring , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;n, Ring, Alloc&gt; <a class="el" href="namespaceDGtal.html#afd55a2a73cd7b4552dbaf0b62980b323">DGtal::derivative</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; n, Ring, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the partial derivative of <em>p</em> with respect to the N-th indeterminate. We assume that 0 &lt;= N &lt; n.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>an arbitrary polynomial.</td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">N</td><td>the variable used for derivation.</td></tr>
    <tr><td class="paramname">n</td><td>the number of variables or indeterminates.</td></tr>
    <tr><td class="paramname">Ring</td><td>the type chosen for the polynomial, defines also the type of the coefficents (generally int, float or double).</td></tr>
    <tr><td class="paramname">Alloc</td><td>is an allocator for Ring, for example std::allocator&lt;Ring&gt;; this is also the default parameter. Usually this parameter does not needs to be changed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l01964">1964</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>

<p>References <a class="el" href="MPolynomial_8h_source.html#l01899">DGtal::MPolynomialDerivativeComputer&lt; N, n, Ring, Alloc &gt;::computeDerivative()</a>, and <a class="el" href="MPolynomial_8h_source.html#l01098">DGtal::MPolynomial&lt; n, TRing, TAlloc &gt;::getAllocator()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <a class="code" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial&lt;n, Ring, Alloc&gt;</a> res( p.<a class="code" href="classDGtal_1_1MPolynomial.html#a25d9f2c9ab7b9856b71ce6c8de45f663">getAllocator</a>() );
    <a class="code" href="classDGtal_1_1MPolynomialDerivativeComputer.html">MPolynomialDerivativeComputer&lt;N, n, Ring, Alloc&gt;::computeDerivative</a>(p, res);
    <span class="keywordflow">return</span> res;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a9aedf0fbd5b7c5814911d1299be81cb9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, int n, typename Ring &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;n, Ring, std::allocator&lt;Ring&gt; &gt; <a class="el" href="namespaceDGtal.html#afd55a2a73cd7b4552dbaf0b62980b323">DGtal::derivative</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; n, Ring, std::allocator&lt; Ring &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the partial derivative of <em>p</em> with respect to the N-th indeterminate. We assume that 0 &lt;= N &lt; n.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>an arbitrary polynomial.</td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">N</td><td>the variable used for derivation.</td></tr>
    <tr><td class="paramname">n</td><td>the number of variables or indeterminates.</td></tr>
    <tr><td class="paramname">Ring</td><td>the type chosen for the polynomial, defines also the type of the coefficents (generally int, float or double). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l01988">1988</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><pre class="fragment">   {
     <a class="code" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial&lt;n, Ring, std::allocator&lt;Ring&gt;</a> &gt; res( p.<a class="code" href="classDGtal_1_1MPolynomial.html#a25d9f2c9ab7b9856b71ce6c8de45f663">getAllocator</a>() );
     <a class="code" href="classDGtal_1_1MPolynomialDerivativeComputer.html">MPolynomialDerivativeComputer&lt;N, n, Ring, std::allocator&lt;Ring&gt;</a> &gt;
       ::computeDerivative( p, res );
     <span class="keywordflow">return</span> res;
   }
</pre></div>
</div>
</div>
<a class="anchor" id="a2bbdffe7efc4f8af031964cecfe477a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TRing , typename TAlloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a2bbdffe7efc4f8af031964cecfe477a7">DGtal::euclidDiv</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, TRing, TAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, TRing, TAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, TRing, TAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, TRing, TAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Forward declaration, to be able to declare this as a friend. </p>

<p>Referenced by <a class="el" href="MPolynomial_8h_source.html#l02045">gcd()</a>.</p>

</div>
</div>
<a class="anchor" id="afc4718ecc21bcecf1618414e982b951c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a2bbdffe7efc4f8af031964cecfe477a7">DGtal::euclidDiv</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes q and r such that f = q g + r and degree(r) &lt; degree(g). </p>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l02001">2001</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>

<p>References <a class="el" href="MPolynomial_8h_source.html#l01110">DGtal::MPolynomial&lt; n, TRing, TAlloc &gt;::degree()</a>, <a class="el" href="MPolynomial_8h_source.html#l01098">DGtal::MPolynomial&lt; n, TRing, TAlloc &gt;::getAllocator()</a>, <a class="el" href="MPolynomial_8h_source.html#l01120">DGtal::MPolynomial&lt; n, TRing, TAlloc &gt;::leading()</a>, and <a class="el" href="MPolynomial_8h_source.html#l01016">DGtal::MPolynomial&lt; n, TRing, TAlloc &gt;::normalize()</a>.</p>
<div class="fragment"><pre class="fragment">   {
     <span class="keywordflow">if</span> (f.<a class="code" href="classDGtal_1_1MPolynomial.html#a9d50df0e8794372052f3ca2941bfbf6e">degree</a>() &lt; g.<a class="code" href="classDGtal_1_1MPolynomial.html#a9d50df0e8794372052f3ca2941bfbf6e">degree</a>())
       {
         <span class="comment">// Ignore the trivial case</span>
         q = <a class="code" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial&lt;1, Ring, Alloc&gt;</a>(f.<a class="code" href="classDGtal_1_1MPolynomial.html#a25d9f2c9ab7b9856b71ce6c8de45f663">getAllocator</a>());
         r = f;
         <span class="keywordflow">return</span>;
       }
    q = <a class="code" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial&lt;1, Ring, Alloc&gt;</a>( <span class="keyword">true</span>, f.<a class="code" href="classDGtal_1_1MPolynomial.html#a9d50df0e8794372052f3ca2941bfbf6e">degree</a>() - g.<a class="code" href="classDGtal_1_1MPolynomial.html#a9d50df0e8794372052f3ca2941bfbf6e">degree</a>() + 1, 
                                     f.<a class="code" href="classDGtal_1_1MPolynomial.html#a25d9f2c9ab7b9856b71ce6c8de45f663">getAllocator</a>() );
    r = f;
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = q.<a class="code" href="classDGtal_1_1MPolynomial.html#a9d50df0e8794372052f3ca2941bfbf6e">degree</a>(); i &gt;= 0; --i)
      {
        q[i] = r[i + g.<a class="code" href="classDGtal_1_1MPolynomial.html#a9d50df0e8794372052f3ca2941bfbf6e">degree</a>()] / g.<a class="code" href="classDGtal_1_1MPolynomial.html#ab83ae2874ce1ac5df892dd4dd93e352d">leading</a>();
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = g.<a class="code" href="classDGtal_1_1MPolynomial.html#a9d50df0e8794372052f3ca2941bfbf6e">degree</a>(); j &gt;= 0; --j)
          r[i + j] -= q[i] * g[j];
      }
    r.<a class="code" href="classDGtal_1_1MPolynomial.html#af326b15174d16edb89e996f758168ffd">normalize</a>();
    <span class="comment">// Note that the degree of q is already correct.</span>
   }
</pre></div>
</div>
</div>
<a class="anchor" id="a57e756b9529892b5019066b6d4a4310c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a2bbdffe7efc4f8af031964cecfe477a7">DGtal::euclidDiv</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes q and r such that f = q g + r and degree(r) &lt; degree(g). </p>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l02031">2031</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><pre class="fragment">   {
     euclidDiv&lt;Ring, std::allocator&lt;Ring&gt; &gt;(f, g, q, r);
   }
</pre></div>
</div>
</div>
<a class="anchor" id="a3f73d6217f05eef8225781a523efc077"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceDGtal.html#a3f73d6217f05eef8225781a523efc077">DGtal::findAndGetValue</a> </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>aImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>aSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename I::Point &amp;&#160;</td>
          <td class="paramname"><em>aPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename I::Value &amp;&#160;</td>
          <td class="paramname"><em>aValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read the value contained in <em>aImg</em> at <em>aPoint</em> if <em>aPoint</em> belongs to <em>aSet</em>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aImg</td><td>an image </td></tr>
    <tr><td class="paramname">aSet</td><td>a digital set </td></tr>
    <tr><td class="paramname">aPoint</td><td>a point </td></tr>
    <tr><td class="paramname">aValue</td><td>(returned) value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>'true' if a new point is found and the value read but 'false' otherwise</dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">I</td><td>any model of <a class="el" href="structDGtal_1_1CImage.html">CImage</a> </td></tr>
    <tr><td class="paramname">S</td><td>any model of <a class="el" href="structDGtal_1_1CDigitalSet.html" title="Aim: Represents a set of points within the given domain. This set of points is modifiable by the user...">CDigitalSet</a></td></tr>
  </table>
  </dd>
</dl>
<p>The general behavior is like: </p>
<div class="fragment"><pre class="fragment"></pre></div><p>However, this code is specialized if I is an <a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a> and S is a <a class="el" href="classDGtal_1_1DigitalSetFromMap.html" title="Aim: An adapter for viewing an associative image container like ImageContainerBySTLMap as a simple di...">DigitalSetFromMap</a><em> as follows: </p>
<div class="fragment"><pre class="fragment"></pre></div><p></em></p>
<p><em></p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a> <a class="el" href="classDGtal_1_1DigitalSetFromMap.html" title="Aim: An adapter for viewing an associative image container like ImageContainerBySTLMap as a simple di...">DigitalSetFromMap</a> </dd>
<dd>
<a class="el" href="namespaceDGtal.html#a5f01a70f2cf84e9c08d1308e77911a08">insertAndSetValue</a> </dd></dl>
<p></em></p>

<p>Definition at line <a class="el" href="ImageHelper_8ih_source.html#l00343">343</a> of file <a class="el" href="ImageHelper_8ih_source.html">ImageHelper.ih</a>.</p>

<p>References <a class="el" href="ImageHelper_8ih_source.html#l00300">FindAndGetValue&lt; I, S, D, V &gt;::implementation()</a>.</p>

<p>Referenced by <a class="el" href="FMMPointFunctors_8ih_source.html#l00113">DGtal::L2FirstOrderLocalDistance&lt; TImage, TSet &gt;::operator()()</a>, <a class="el" href="FMMPointFunctors_8ih_source.html#l00297">DGtal::L2SecondOrderLocalDistance&lt; TImage, TSet &gt;::operator()()</a>, <a class="el" href="FMMPointFunctors_8ih_source.html#l00510">DGtal::LInfLocalDistance&lt; TImage, TSet &gt;::operator()()</a>, <a class="el" href="FMMPointFunctors_8ih_source.html#l00648">DGtal::L1LocalDistance&lt; TImage, TSet &gt;::operator()()</a>, and <a class="el" href="FMMPointFunctors_8ih_source.html#l00961">DGtal::SpeedExtrapolator&lt; TDistanceImage, TSet, TSpeedFunctor &gt;::operator()()</a>.</p>
<div class="fragment"><pre class="fragment">{
  
  BOOST_CONCEPT_ASSERT(( CImage&lt;I&gt; )); 
  BOOST_CONCEPT_ASSERT(( CDigitalSet&lt;S&gt; )); 
  BOOST_STATIC_ASSERT(( boost::is_same&lt; typename I::Point, typename S::Point &gt;::value ));

  <span class="keyword">typedef</span> <span class="keyword">typename</span> I::Domain D; 
  <span class="keyword">typedef</span> <span class="keyword">typename</span> I::Value V; 
  <span class="keywordflow">return</span> <a class="code" href="structFindAndGetValue.html#afea841f1bc58973ac734d8f1ba8b1917">FindAndGetValue&lt;I,S,D,V&gt;::implementation</a>(aImg, aSet, aPoint, aValue); 
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae6d3175b6c7d86845a0c259f566bd7ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#ae6d3175b6c7d86845a0c259f566bd7ea">DGtal::firstMaximalSegment</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the first maximal segment passing through i </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CForwardSegmentComputer.html" title="Aim: Defines the concept describing a forward segment computer, ie. a model of CSegment that can exte...">CForwardSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00403">403</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00352">longestSegment()</a>.</p>

<p>Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00458">firstMaximalSegment()</a>, <a class="el" href="SaturatedSegmentation_8ih_source.html#l00104">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::initFirstMaximalSegment()</a>, <a class="el" href="SaturatedSegmentation_8ih_source.html#l00122">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::initLastMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00510">mostCenteredMaximalSegment()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00759">nextMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{

  <span class="keyword">typedef</span> <span class="keyword">typename</span> SC::ConstIterator ConstIterator; 
  <span class="keyword">typedef</span> <span class="keyword">typename</span> SC::Reverse ReverseSegmentComputer; 
  <span class="keyword">typedef</span> <span class="keyword">typename</span> ReverseSegmentComputer::ConstIterator ConstReverseIterator; 

  <span class="keywordflow">if</span> ( isNotEmpty&lt;ConstIterator&gt;(i,end) ) {

    <span class="comment">//backward extension</span>
    ConstIterator it( i ); ++it; 
    ConstReverseIterator rit( it );
    ConstReverseIterator rend( begin );
    ReverseSegmentComputer r( s.getReverse() ); 
    <a class="code" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">longestSegment</a>(r, rit, rend);

    <span class="comment">//forward extension</span>
    ConstIterator it2( r.end().base() );
    <a class="code" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">longestSegment</a>(s, it2, end);

  }

}
</pre></div>
</div>
</div>
<a class="anchor" id="ae37d5f56ebcd83255b9c93038deff781"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#ae6d3175b6c7d86845a0c259f566bd7ea">DGtal::firstMaximalSegment</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the first maximal segment passing through i </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a bidirectional segment computer, ie. a model of CSegment that ca...">CBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00438">438</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00163">maximalExtension()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00197">oppositeEndMaximalExtension()</a>.</p>
<div class="fragment"><pre class="fragment">{
  s.init(i);

  <a class="code" href="namespaceDGtal.html#a462eaaf587bc04ebd2e6141bed3fc21e">oppositeEndMaximalExtension</a>(s, begin);
  <a class="code" href="namespaceDGtal.html#a4718031e09102bb8f73a874c47e10aaf">maximalExtension</a>(s, end);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8b81102d807d1ec5629d25c6e13ddae7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#ae6d3175b6c7d86845a0c259f566bd7ea">DGtal::firstMaximalSegment</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the first maximal segment passing through i </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicSegmentComputer.html" title="Aim: Defines the concept describing a dynamic segment computer, ie. a model of CSegment that can exte...">CDynamicSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">ForwardSegmentComputer</a> </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00458">458</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00403">firstMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="namespaceDGtal.html#ae6d3175b6c7d86845a0c259f566bd7ea">firstMaximalSegment</a>(s,i,begin,end,<a class="code" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="aae8ba2a7a4a42e59741df4afed37f449"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#ae6d3175b6c7d86845a0c259f566bd7ea">DGtal::firstMaximalSegment</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the first maximal segment passing through i </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie...">CDynamicBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">BidirectionalSegmentComputer</a> </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00475">475</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00403">firstMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="namespaceDGtal.html#ae6d3175b6c7d86845a0c259f566bd7ea">firstMaximalSegment</a>(s,i,begin,end,<a class="code" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a18c5282eb177f64a2957c29bf51b0e1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#ae6d3175b6c7d86845a0c259f566bd7ea">DGtal::firstMaximalSegment</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the first maximal segment passing through i </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00491">491</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  firstMaximalSegment&lt;SC&gt;(s, i, begin, end, 
<span class="keyword">typename</span> <a class="code" href="structDGtal_1_1SegmentComputerTraits.html#aec543e23f154c340dd52511204ed977f">DGtal::SegmentComputerTraits&lt;SC&gt;::Category</a>() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a38fc7e3a7ad4420d8b0b5950ae21c32e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;1, Ring, Alloc&gt; <a class="el" href="namespaceDGtal.html#a38fc7e3a7ad4420d8b0b5950ae21c32e">DGtal::gcd</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute the monic greatest common divisor of f and g using the Euclidean Algorithm. </p>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l02045">2045</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>

<p>References <a class="el" href="namespaceDGtal.html#a2bbdffe7efc4f8af031964cecfe477a7">euclidDiv()</a>, <a class="el" href="MPolynomial_8h_source.html#l01098">DGtal::MPolynomial&lt; n, TRing, TAlloc &gt;::getAllocator()</a>, <a class="el" href="MPolynomial_8h_source.html#l01128">DGtal::MPolynomial&lt; n, TRing, TAlloc &gt;::isZero()</a>, and <a class="el" href="MPolynomial_8h_source.html#l01120">DGtal::MPolynomial&lt; n, TRing, TAlloc &gt;::leading()</a>.</p>

<p>Referenced by <a class="el" href="IntegerComputer_8ih_source.html#l00356">DGtal::IntegerComputer&lt; TInteger &gt;::reduce()</a>.</p>
<div class="fragment"><pre class="fragment">   {
     <span class="keywordflow">if</span> (f.<a class="code" href="classDGtal_1_1MPolynomial.html#ac53389b0d7e6647f32b014ca4eaf78e5">isZero</a>())
       {
         <span class="keywordflow">if</span> (g.<a class="code" href="classDGtal_1_1MPolynomial.html#ac53389b0d7e6647f32b014ca4eaf78e5">isZero</a>()) <span class="keywordflow">return</span> f; <span class="comment">// both are zero</span>
         <span class="keywordflow">else</span>            <span class="keywordflow">return</span> g / g.<a class="code" href="classDGtal_1_1MPolynomial.html#ab83ae2874ce1ac5df892dd4dd93e352d">leading</a>(); <span class="comment">// make g monic</span>
       }
     <a class="code" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial&lt;1, Ring, Alloc&gt;</a> 
       d1(f / f.<a class="code" href="classDGtal_1_1MPolynomial.html#ab83ae2874ce1ac5df892dd4dd93e352d">leading</a>()), 
       d2(g / g.<a class="code" href="classDGtal_1_1MPolynomial.html#ab83ae2874ce1ac5df892dd4dd93e352d">leading</a>()), 
       q(f.<a class="code" href="classDGtal_1_1MPolynomial.html#a25d9f2c9ab7b9856b71ce6c8de45f663">getAllocator</a>()), 
       r(f.<a class="code" href="classDGtal_1_1MPolynomial.html#a25d9f2c9ab7b9856b71ce6c8de45f663">getAllocator</a>());
     <span class="keywordflow">while</span> (!d2.isZero())
       {
         <a class="code" href="namespaceDGtal.html#a2bbdffe7efc4f8af031964cecfe477a7">euclidDiv</a>(d1, d2, q, r);
         d1.swap(d2);
         d2 = r;
         d2 /= r.leading(); <span class="comment">// make r monic</span>
       }
     <span class="keywordflow">return</span> d1;
   }
</pre></div>
</div>
</div>
<a class="anchor" id="ab28649140d0b09a9b25515660a3e6f12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;1, Ring, std::allocator&lt;Ring&gt; &gt; <a class="el" href="namespaceDGtal.html#a38fc7e3a7ad4420d8b0b5950ae21c32e">DGtal::gcd</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt; 1, Ring, std::allocator&lt; Ring &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute the monic greatest common divisor of f and g using the Euclidean Algorithm. </p>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l02074">2074</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordflow">return</span> gcd&lt;Ring, std::allocator&lt;Ring&gt; &gt;(f, g);
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a8c4fb1b2976e5fc35dc1b4073149408e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IC <a class="el" href="namespaceDGtal.html#a8c4fb1b2976e5fc35dc1b4073149408e">DGtal::getMiddleIterator</a> </td>
          <td>(</td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessCategory&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specialization for random access category </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00087">87</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00150">getMiddleIterator()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00510">mostCenteredMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">//how to compute this with circulators ?</span>
<span class="comment">//return itb + ((ite-itb)/2);  </span>
<span class="comment">//does not work  </span>
  <span class="keywordflow">return</span> <a class="code" href="namespaceDGtal.html#a8c4fb1b2976e5fc35dc1b4073149408e">getMiddleIterator</a>(itb, ite, BidirectionalCategory() ); 
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9cf4e9405b276ba5b8b931f72d180d9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IC <a class="el" href="namespaceDGtal.html#a8c4fb1b2976e5fc35dc1b4073149408e">DGtal::getMiddleIterator</a> </td>
          <td>(</td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalCategory&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specialization for bidirectional category NB: in O(ite-itb) </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00100">100</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  IC b( itb ); 
  IC f( ite ); 
  <span class="keywordtype">bool</span> flag = <span class="keyword">true</span>; 
  <span class="keywordflow">while</span> (b != f) {
    <span class="keywordflow">if</span> (flag) {
      --f;
      flag = <span class="keyword">false</span>; 
    } <span class="keywordflow">else</span> {
      ++b; 
      flag = <span class="keyword">true</span>; 
    } 
  }
  <span class="keywordflow">return</span> b;   
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8f53c482fe83e31093accf95ec7190d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IC <a class="el" href="namespaceDGtal.html#a8c4fb1b2976e5fc35dc1b4073149408e">DGtal::getMiddleIterator</a> </td>
          <td>(</td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardCategory&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specialization for forward category NB: in O(ite-itb) </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00122">122</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  IC i( itb ); 

  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; 
  <span class="keywordflow">while</span> (i != ite) {
    ++i; 
    ++c;
  } 
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = c/2;

  c = 0; 
  i = itb; 
  <span class="keywordflow">while</span> (c != k) {
    ++i; 
    ++c;
  } 

  <span class="keywordflow">return</span> i;   
}
</pre></div>
</div>
</div>
<a class="anchor" id="a318f9e3e73cd0988af98b3a66a543334"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IC <a class="el" href="namespaceDGtal.html#a8c4fb1b2976e5fc35dc1b4073149408e">DGtal::getMiddleIterator</a> </td>
          <td>(</td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>ite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the middle iterator of a given range, i.e. itb + (ite-itb)/2) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">itb,ite,begin</td><td>and end iterators of a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the middle iterator of the range [itb,ite) </dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">any</td><td>iterator or circulator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00150">150</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00087">getMiddleIterator()</a>.</p>
<div class="fragment"><pre class="fragment">                                                   {
  <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorCirculatorTraits&lt;IC&gt;::Category Category; 
  <span class="keywordflow">return</span> <a class="code" href="namespaceDGtal.html#a8c4fb1b2976e5fc35dc1b4073149408e">getMiddleIterator</a>(itb, ite, Category() ); 
} 
</pre></div>
</div>
</div>
<a class="anchor" id="a46234d3693677caa52b0ffb6db059d5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a46234d3693677caa52b0ffb6db059d5d">DGtal::imageFromFunctor</a> </td>
          <td>(</td>
          <td class="paramtype">I &amp;&#160;</td>
          <td class="paramname"><em>aImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>aFun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>In a window corresponding to the domain of <em>aImg</em>, copy the values of <em>aFun</em> into <em>aImg</em> </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aImg</td><td>(returned) image </td></tr>
    <tr><td class="paramname">aFun</td><td>a unary functor</td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">I</td><td>any model of <a class="el" href="structDGtal_1_1CImage.html">CImage</a> </td></tr>
    <tr><td class="paramname">F</td><td>any model of <a class="el" href="structDGtal_1_1CPointFunctor.html" title="Aim: Defines a functor on points.">CPointFunctor</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ImageHelper_8ih_source.html#l00139">139</a> of file <a class="el" href="ImageHelper_8ih_source.html">ImageHelper.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  BOOST_CONCEPT_ASSERT(( CImage&lt;I&gt; )); 
  BOOST_CONCEPT_ASSERT(( CPointFunctor&lt;F&gt; ));

  <span class="keyword">typename</span> I::Domain d = aImg.domain();

  std::transform(d.begin(), d.end(), aImg.range().outputIterator(), aFun ); 
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6e6f5a9c305d047a2e9c6315ca17832c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a6e6f5a9c305d047a2e9c6315ca17832c">DGtal::imageFromImage</a> </td>
          <td>(</td>
          <td class="paramtype">I &amp;&#160;</td>
          <td class="paramname"><em>aImg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>aImg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy the values of <em>aImg2</em> into <em>aImg1</em> .</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aImg1</td><td>the image to fill </td></tr>
    <tr><td class="paramname">aImg2</td><td>the image to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">I</td><td>any model of <a class="el" href="structDGtal_1_1CImage.html">CImage</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ImageHelper_8ih_source.html#l00153">153</a> of file <a class="el" href="ImageHelper_8ih_source.html">ImageHelper.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  BOOST_CONCEPT_ASSERT(( CImage&lt;I&gt; )); 

  <span class="keyword">typename</span> I::ConstRange r = aImg2.constRange(); 
  std::copy( r.begin(), r.end(), aImg1.range().outputIterator() ); 
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac1511d84bd2b82df82bea3aefc3af2dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename It , typename Im &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#ac1511d84bd2b82df82bea3aefc3af2dd">DGtal::imageFromRangeAndValue</a> </td>
          <td>(</td>
          <td class="paramtype">const It &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const It &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Im &amp;&#160;</td>
          <td class="paramname"><em>aImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Im::Value &amp;&#160;</td>
          <td class="paramname"><em>aValue</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the values of <em>aImg</em> at <em>aValue</em> for each points of the range [ <em>itb</em> , <em>ite</em> )</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator on points </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator on points </td></tr>
    <tr><td class="paramname">aImg</td><td>(returned) image </td></tr>
    <tr><td class="paramname">aValue</td><td>any value (default: 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">It</td><td>any model of forward iterator </td></tr>
    <tr><td class="paramname">Im</td><td>any model of <a class="el" href="structDGtal_1_1CImage.html">CImage</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ImageHelper_8ih_source.html#l00108">108</a> of file <a class="el" href="ImageHelper_8ih_source.html">ImageHelper.ih</a>.</p>

<p>Referenced by <a class="el" href="ImageHelper_8ih_source.html#l00126">imageFromRangeAndValue()</a>.</p>
<div class="fragment"><pre class="fragment">{
  BOOST_CONCEPT_ASSERT(( boost::InputIterator&lt;It&gt; ));
  BOOST_CONCEPT_ASSERT(( CImage&lt;Im&gt; )); 

  <span class="keyword">typename</span> Im::Domain d = aImg.domain(); 
  <span class="keywordflow">for</span> (It it = itb; it != ite; ++it)
    {
      <span class="keywordflow">if</span> (d.isInside( *it )) 
        aImg.setValue( *it, aValue ); 
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aff03c6c44f0ec8ad182440aad1b4e86a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#ac1511d84bd2b82df82bea3aefc3af2dd">DGtal::imageFromRangeAndValue</a> </td>
          <td>(</td>
          <td class="paramtype">const R &amp;&#160;</td>
          <td class="paramname"><em>aRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I &amp;&#160;</td>
          <td class="paramname"><em>aImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename I::Value &amp;&#160;</td>
          <td class="paramname"><em>aValue</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the values of <em>aImg</em> at <em>aValue</em> for each points of the range <em>aRange</em> </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aRange</td><td>any range </td></tr>
    <tr><td class="paramname">aImg</td><td>(returned) image </td></tr>
    <tr><td class="paramname">aValue</td><td>any value (default: 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">R</td><td>any model of <a class="el" href="structDGtal_1_1CConstSinglePassRange.html" title="Aim: Defines the concept describing a const range.">CConstSinglePassRange</a> </td></tr>
    <tr><td class="paramname">I</td><td>any model of <a class="el" href="structDGtal_1_1CImage.html">CImage</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ImageHelper_8ih_source.html#l00126">126</a> of file <a class="el" href="ImageHelper_8ih_source.html">ImageHelper.ih</a>.</p>

<p>References <a class="el" href="ImageHelper_8ih_source.html#l00108">imageFromRangeAndValue()</a>.</p>
<div class="fragment"><pre class="fragment">{
  BOOST_CONCEPT_ASSERT(( CConstSinglePassRange&lt;R&gt; ));
  BOOST_CONCEPT_ASSERT(( CImage&lt;I&gt; )); 

  <a class="code" href="namespaceDGtal.html#ac1511d84bd2b82df82bea3aefc3af2dd">imageFromRangeAndValue</a>( aRange.begin(), aRange.end(), aImg, aValue); 
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac920bc98f866a2e17ee53faddc67ff80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceDGtal.html#ac920bc98f866a2e17ee53faddc67ff80">DGtal::insertAndAlwaysSetValue</a> </td>
          <td>(</td>
          <td class="paramtype">I &amp;&#160;</td>
          <td class="paramname"><em>aImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S &amp;&#160;</td>
          <td class="paramname"><em>aSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename I::Point &amp;&#160;</td>
          <td class="paramname"><em>aPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename I::Value &amp;&#160;</td>
          <td class="paramname"><em>aValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert <em>aPoint</em> in <em>aSet</em> and set <em>aValue</em> at <em>aPoint</em> in <em>aImg</em>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aImg</td><td>an image </td></tr>
    <tr><td class="paramname">aSet</td><td>a digital set </td></tr>
    <tr><td class="paramname">aPoint</td><td>a point </td></tr>
    <tr><td class="paramname">aValue</td><td>a value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>'true' if a new point was inserted in <em>aSet</em> but 'false' if the same point already exist in <em>aSet</em> </dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">I</td><td>any model of <a class="el" href="structDGtal_1_1CImage.html">CImage</a> </td></tr>
    <tr><td class="paramname">S</td><td>any model of <a class="el" href="structDGtal_1_1CDigitalSet.html" title="Aim: Represents a set of points within the given domain. This set of points is modifiable by the user...">CDigitalSet</a></td></tr>
  </table>
  </dd>
</dl>
<p>The general behavior is like: </p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">bool</span> found = <span class="keyword">false</span>; 
    <span class="keywordflow">if</span> ( aSet.find( aPoint ) != aSet.end() )
      found = <span class="keyword">true</span>;       
    <span class="comment">//always set value</span>
    aSet.insert( aPoint );
    aImg.setValue( aPoint, aValue ); 
    <span class="keywordflow">return</span> !found; 
</pre></div><p>However, this code is specialized if I is an <a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a> and S is a <a class="el" href="classDGtal_1_1DigitalSetFromMap.html" title="Aim: An adapter for viewing an associative image container like ImageContainerBySTLMap as a simple di...">DigitalSetFromMap</a><em> as follows: </p>
<div class="fragment"><pre class="fragment">   std::pair&lt;P, V&gt; 
   pair( aPoint, aValue );  
   std::pair&lt;Iterator, bool&gt; res 
   = aImg.insert( pair );
   <span class="keywordtype">bool</span> flag = res.second; 
   <span class="keywordflow">if</span> (flag == <span class="keyword">false</span>) <span class="comment">//set value even in this case</span>
   res.first-&gt;second = aValue;
   <span class="keywordflow">return</span> flag; 
</pre></div><p></em></p>
<p><em></p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a> <a class="el" href="classDGtal_1_1DigitalSetFromMap.html" title="Aim: An adapter for viewing an associative image container like ImageContainerBySTLMap as a simple di...">DigitalSetFromMap</a> </dd>
<dd>
<a class="el" href="namespaceDGtal.html#a5f01a70f2cf84e9c08d1308e77911a08">insertAndSetValue</a> </dd></dl>
<p></em></p>

<p>Definition at line <a class="el" href="ImageHelper_8ih_source.html#l00281">281</a> of file <a class="el" href="ImageHelper_8ih_source.html">ImageHelper.ih</a>.</p>

<p>References <a class="el" href="ImageHelper_8ih_source.html#l00230">InsertAndAlwaysSetValue&lt; I, S, D, V &gt;::implementation()</a>.</p>

<p>Referenced by <a class="el" href="FMM_8ih_source.html#l00152">DGtal::FMM&lt; TImage, TSet, TPointPredicate, TPointFunctor &gt;::initFromBelsRange()</a>, <a class="el" href="FMM_8ih_source.html#l00241">DGtal::FMM&lt; TImage, TSet, TPointPredicate, TPointFunctor &gt;::initFromIncidentPointsRange()</a>, and <a class="el" href="FMM_8ih_source.html#l00136">DGtal::FMM&lt; TImage, TSet, TPointPredicate, TPointFunctor &gt;::initFromPointsRange()</a>.</p>
<div class="fragment"><pre class="fragment">{
  
  BOOST_CONCEPT_ASSERT(( CImage&lt;I&gt; )); 
  BOOST_CONCEPT_ASSERT(( CDigitalSet&lt;S&gt; )); 
  BOOST_STATIC_ASSERT(( boost::is_same&lt; typename I::Point, typename S::Point &gt;::value ));

  <span class="keyword">typedef</span> <span class="keyword">typename</span> I::Domain D; 
  <span class="keyword">typedef</span> <span class="keyword">typename</span> I::Value V; 
  <span class="keywordflow">return</span> <a class="code" href="structInsertAndAlwaysSetValue.html#a963a53c702b8be32449f0e12bb0538f0">InsertAndAlwaysSetValue&lt;I,S,D,V&gt;::implementation</a>(aImg, aSet, aPoint, aValue); 
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5f01a70f2cf84e9c08d1308e77911a08"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceDGtal.html#a5f01a70f2cf84e9c08d1308e77911a08">DGtal::insertAndSetValue</a> </td>
          <td>(</td>
          <td class="paramtype">I &amp;&#160;</td>
          <td class="paramname"><em>aImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S &amp;&#160;</td>
          <td class="paramname"><em>aSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename I::Point &amp;&#160;</td>
          <td class="paramname"><em>aPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename I::Value &amp;&#160;</td>
          <td class="paramname"><em>aValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert <em>aPoint</em> in <em>aSet</em> and if (and only if) <em>aPoint</em> is a newly inserted point. Then set <em>aValue</em> at <em>aPoint</em> in <em>aImg</em>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aImg</td><td>an image </td></tr>
    <tr><td class="paramname">aSet</td><td>a digital set </td></tr>
    <tr><td class="paramname">aPoint</td><td>a point </td></tr>
    <tr><td class="paramname">aValue</td><td>a value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>'true' if a new point was inserted in <em>aSet</em> but 'false' if the same point already exist in <em>aSet</em> </dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">I</td><td>any model of <a class="el" href="structDGtal_1_1CImage.html">CImage</a> </td></tr>
    <tr><td class="paramname">S</td><td>any model of <a class="el" href="structDGtal_1_1CDigitalSet.html" title="Aim: Represents a set of points within the given domain. This set of points is modifiable by the user...">CDigitalSet</a></td></tr>
  </table>
  </dd>
</dl>
<p>The general behavior is like: </p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">bool</span> found = <span class="keyword">true</span>; 
    <span class="keywordflow">if</span> ( aSet.find( aPoint ) == aSet.end() )
      { <span class="comment">//if not found</span>
        found = <span class="keyword">false</span>; 
        aSet.insert( aPoint );
        aImg.setValue( aPoint, aValue ); 
      }      
    <span class="keywordflow">return</span> !found; 
</pre></div><p>However, this code is specialized if I is an <a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a> and S is a <a class="el" href="classDGtal_1_1DigitalSetFromMap.html" title="Aim: An adapter for viewing an associative image container like ImageContainerBySTLMap as a simple di...">DigitalSetFromMap</a><em> as follows: </p>
<div class="fragment"><pre class="fragment">   std::pair&lt;P, V&gt; 
   pair( aPoint, aValue );  
   std::pair&lt;Iterator, bool&gt; res 
   = aImg.insert( pair ); 
   <span class="keywordflow">return</span> res.second;  
</pre></div><p></em></p>
<p><em></p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a> <a class="el" href="classDGtal_1_1DigitalSetFromMap.html" title="Aim: An adapter for viewing an associative image container like ImageContainerBySTLMap as a simple di...">DigitalSetFromMap</a> </dd>
<dd>
<a class="el" href="namespaceDGtal.html#ac920bc98f866a2e17ee53faddc67ff80">insertAndAlwaysSetValue</a> </dd></dl>
<p></em></p>

<p>Definition at line <a class="el" href="ImageHelper_8ih_source.html#l00213">213</a> of file <a class="el" href="ImageHelper_8ih_source.html">ImageHelper.ih</a>.</p>

<p>References <a class="el" href="ImageHelper_8ih_source.html#l00165">InsertAndSetValue&lt; I, S, D, V &gt;::implementation()</a>.</p>

<p>Referenced by <a class="el" href="FMM_8ih_source.html#l00403">DGtal::FMM&lt; TImage, TSet, TPointPredicate, TPointFunctor &gt;::addNewAcceptedPoint()</a>.</p>
<div class="fragment"><pre class="fragment">{
  BOOST_CONCEPT_ASSERT(( CImage&lt;I&gt; )); 
  BOOST_CONCEPT_ASSERT(( CDigitalSet&lt;S&gt; )); 
  BOOST_STATIC_ASSERT(( boost::is_same&lt; typename I::Point, typename S::Point &gt;::value ));

  <span class="keyword">typedef</span> <span class="keyword">typename</span> I::Domain D; 
  <span class="keyword">typedef</span> <span class="keyword">typename</span> I::Value V; 
  <span class="keywordflow">return</span> <a class="code" href="structInsertAndSetValue.html#a5d6eba146a4533add7a14f19e8f3f9a2">InsertAndSetValue&lt;I,S,D,V&gt;::implementation</a>(aImg, aSet, aPoint, aValue); 
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6b49e997d09ccb163eb82529e8970996"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceDGtal.html#a6b49e997d09ccb163eb82529e8970996">DGtal::isEmpty</a> </td>
          <td>(</td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>ite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Circulator_8h_source.html#l00560">560</a> of file <a class="el" href="Circulator_8h_source.html">Circulator.h</a>.</p>

<p>Referenced by <a class="el" href="Preimage2D_8ih_source.html#l00285">DGtal::Preimage2D&lt; Shape &gt;::addBack()</a>, and <a class="el" href="Preimage2D_8ih_source.html#l00227">DGtal::Preimage2D&lt; Shape &gt;::addFront()</a>.</p>
<div class="fragment"><pre class="fragment">                                            {
  <span class="keywordflow">return</span> detail::isEmpty&lt;IC&gt;( itb, ite, <span class="keyword">typename</span> IteratorCirculatorTraits&lt;IC&gt;::Type() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6f1b22211474c60437654c3a0decb8ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceDGtal.html#a6f1b22211474c60437654c3a0decb8ef">DGtal::isNotEmpty</a> </td>
          <td>(</td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IC &amp;&#160;</td>
          <td class="paramname"><em>ite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Circulator_8h_source.html#l00566">566</a> of file <a class="el" href="Circulator_8h_source.html">Circulator.h</a>.</p>

<p>Referenced by <a class="el" href="L1LengthEstimator_8ih_source.html#l00083">DGtal::L1LengthEstimator&lt; TConstIterator &gt;::eval()</a>, <a class="el" href="SaturatedSegmentation_8ih_source.html#l00122">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::initLastMaximalSegment()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00566">mostCenteredMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">                                               {
  <span class="keywordflow">return</span> detail::isNotEmpty&lt;IC&gt;( itb, ite, <span class="keyword">typename</span> IteratorCirculatorTraits&lt;IC&gt;::Type() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a19f04b5f095862ee00e620f8246df2f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a19f04b5f095862ee00e620f8246df2f8">DGtal::lastMaximalSegment</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the last maximal segment passing through i </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CForwardSegmentComputer.html" title="Aim: Defines the concept describing a forward segment computer, ie. a model of CSegment that can exte...">CForwardSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00652">652</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00352">longestSegment()</a>.</p>

<p>Referenced by <a class="el" href="SaturatedSegmentation_8ih_source.html#l00104">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::initFirstMaximalSegment()</a>, <a class="el" href="SaturatedSegmentation_8ih_source.html#l00122">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::initLastMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00706">lastMaximalSegment()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00852">previousMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{

  <span class="keyword">typedef</span> <span class="keyword">typename</span> SC::ConstIterator ConstIterator; 
  <span class="keyword">typedef</span> <span class="keyword">typename</span> SC::Reverse ReverseSegmentComputer; 
  <span class="keyword">typedef</span> <span class="keyword">typename</span> ReverseSegmentComputer::ConstIterator ConstReverseIterator; 

  <span class="comment">//forward extension</span>
  ConstIterator j( i );
  <a class="code" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">longestSegment</a>(s, j, end);

  <span class="comment">//backward extension</span>
  ConstIterator it( s.end() );
  ConstReverseIterator rit( it );
  ConstReverseIterator rend( begin );
  ReverseSegmentComputer r( s.getReverse() ); 
  <a class="code" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">longestSegment</a>(r, rit, rend);

  <span class="comment">//forward extension</span>
  ConstIterator it2( r.end().base() );
  <a class="code" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">longestSegment</a>(s, it2, end);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8c5dc0554703f63c1ec705f764f2ba3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a19f04b5f095862ee00e620f8246df2f8">DGtal::lastMaximalSegment</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalSegmentComputer&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the last maximal segment passing through i </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a bidirectional segment computer, ie. a model of CSegment that ca...">CBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00686">686</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00163">maximalExtension()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00197">oppositeEndMaximalExtension()</a>.</p>
<div class="fragment"><pre class="fragment">{
  s.init(i);

  <a class="code" href="namespaceDGtal.html#a4718031e09102bb8f73a874c47e10aaf">maximalExtension</a>(s, end);
  <a class="code" href="namespaceDGtal.html#a462eaaf587bc04ebd2e6141bed3fc21e">oppositeEndMaximalExtension</a>(s, begin);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a652ebafea1d9e8891f40d9b0af8fcb02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a19f04b5f095862ee00e620f8246df2f8">DGtal::lastMaximalSegment</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the last maximal segment passing through i </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicSegmentComputer.html" title="Aim: Defines the concept describing a dynamic segment computer, ie. a model of CSegment that can exte...">CDynamicSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">ForwardSegmentComputer</a> </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00706">706</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00652">lastMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="namespaceDGtal.html#a19f04b5f095862ee00e620f8246df2f8">lastMaximalSegment</a>(s,i,begin,end,<a class="code" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a47282aa7c7fc28d49e7a52a3f8eeee3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a19f04b5f095862ee00e620f8246df2f8">DGtal::lastMaximalSegment</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the last maximal segment passing through i </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie...">CDynamicBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">BidirectionalSegmentComputer</a> </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00723">723</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00652">lastMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="namespaceDGtal.html#a19f04b5f095862ee00e620f8246df2f8">lastMaximalSegment</a>(s,i,begin,end,<a class="code" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="afa3e824f983193de48aaf18590edaa52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a19f04b5f095862ee00e620f8246df2f8">DGtal::lastMaximalSegment</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the last maximal segment passing through i </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00739">739</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><pre class="fragment">{
   lastMaximalSegment&lt;SC&gt;(s, i, begin, end, 
<span class="keyword">typename</span> <a class="code" href="structDGtal_1_1SegmentComputerTraits.html#aec543e23f154c340dd52511204ed977f">DGtal::SegmentComputerTraits&lt;SC&gt;::Category</a>() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2034305fadb5376a987519daba4c982a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">DGtal::longestSegment</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specialization for Iterator type </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00352">352</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00163">maximalExtension()</a>.</p>

<p>Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00403">firstMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00652">lastMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00384">longestSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00510">mostCenteredMaximalSegment()</a>, <a class="el" href="GreedyDecomposition_8ih_source.html#l00262">DGtal::deprecated::GreedyDecomposition&lt; TSegment &gt;::SegmentIterator::next()</a>, and <a class="el" href="GreedySegmentation_8ih_source.html#l00136">DGtal::GreedySegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::next()</a>.</p>
<div class="fragment"><pre class="fragment"> {
  <span class="keywordflow">if</span> (i != end) {
    s.init(i);
    <a class="code" href="namespaceDGtal.html#a4718031e09102bb8f73a874c47e10aaf">maximalExtension</a>(s, end, IteratorType() );
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a67994f04a54230cdb524e46dba46a127"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">DGtal::longestSegment</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CirculatorType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specialization for <a class="el" href="classDGtal_1_1Circulator.html" title="Aim: Provides an adapter for STL iterators that can iterate through the underlying data structure as ...">Circulator</a> type </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00367">367</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00163">maximalExtension()</a>.</p>
<div class="fragment"><pre class="fragment">{
  s.init(i);
  <a class="code" href="namespaceDGtal.html#a4718031e09102bb8f73a874c47e10aaf">maximalExtension</a>(s, end, CirculatorType() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a464c32dc87cc7ded90f601f4657664a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">DGtal::longestSegment</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the longest possible segment from [i] </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">i,a</td><td>given ConstIterator </td></tr>
    <tr><td class="paramname">end,any</td><td>end ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00384">384</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00352">longestSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorCirculatorTraits&lt;typename SC::ConstIterator&gt;::Type Type; 
  <a class="code" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">longestSegment</a>( s, i, end, Type() ); 
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5da3e5d223f3f741760a4e0fc3483c3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="namespaceDGtal.html#a5da3e5d223f3f741760a4e0fc3483c3a">DGtal::maxDGtal</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the max bewteen to instance of type T.</p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">T</td><td>the type of elements to compare (model of boost::LessThanComparable and EqualityComparable). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first value </td></tr>
    <tr><td class="paramname">b</td><td>second value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the maximum between a and b. </dd></dl>

<p>Definition at line <a class="el" href="GlobalFunctions_8h_source.html#l00085">85</a> of file <a class="el" href="GlobalFunctions_8h_source.html">GlobalFunctions.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    BOOST_CONCEPT_ASSERT((boost::EqualityComparable&lt;T&gt;));
    BOOST_CONCEPT_ASSERT((boost::LessThanComparable&lt;T&gt;));
    <span class="keywordflow">if</span> (a&gt;=b) 
      <span class="keywordflow">return</span> a;
    <span class="keywordflow">else</span>
      <span class="keywordflow">return</span> b;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a4718031e09102bb8f73a874c47e10aaf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a4718031e09102bb8f73a874c47e10aaf">DGtal::maximalExtension</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specialization for Iterator type </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00163">163</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00438">firstMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00686">lastMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00352">longestSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00187">maximalExtension()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00566">mostCenteredMaximalSegment()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00788">nextMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">                                                                                 {
  <span class="comment">//stop if s.end() == end</span>
  <span class="keywordflow">while</span> ( (s.end() != end)
       &amp;&amp; (s.extendForward()) ) {}
}
</pre></div>
</div>
</div>
<a class="anchor" id="a367841808f36fa49eceaa1671718f3ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a4718031e09102bb8f73a874c47e10aaf">DGtal::maximalExtension</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CirculatorType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specialization for <a class="el" href="classDGtal_1_1Circulator.html" title="Aim: Provides an adapter for STL iterators that can iterate through the underlying data structure as ...">Circulator</a> type </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00173">173</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//stop if the segment is the whole range</span>
  <span class="keyword">const</span> <span class="keyword">typename</span> SC::ConstIterator newEnd( s.begin() ); 
  <span class="keywordflow">while</span> ( (s.extendForward())
    &amp;&amp; (s.end() != newEnd) ) {}
}
</pre></div>
</div>
</div>
<a class="anchor" id="a21c7d5ea8b24456694c6fa5f6a25f4cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a4718031e09102bb8f73a874c47e10aaf">DGtal::maximalExtension</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calls s.extendForward() while possible </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">end</td><td>any ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00187">187</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00163">maximalExtension()</a>.</p>
<div class="fragment"><pre class="fragment">                                                                  {
  <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorCirculatorTraits&lt;typename SC::ConstIterator&gt;::Type Type; 
  <a class="code" href="namespaceDGtal.html#a4718031e09102bb8f73a874c47e10aaf">maximalExtension</a>( s, end, Type() ); 
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad4831d5ff3c1c70bd1c6a26403297a9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#ad4831d5ff3c1c70bd1c6a26403297a9a">DGtal::maximalRetraction</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calls s.retractForward() while s.isExtendableForward() returns false </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">end</td><td>any ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00316">316</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00788">nextMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> ( isNotEmpty&lt;typename SC::ConstIterator&gt;(s.end(),end) ) {
    <span class="keywordflow">while</span> ( (! s.isExtendableForward() ) 
          &amp;&amp;(s.retractForward() ) )  {}  
  } <span class="keywordflow">else</span> {
    <span class="keywordflow">while</span> ( s.retractForward() ) {} 
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad8d73948fddeeb1f2e0fa94c4c9b03a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceDGtal.html#ad8d73948fddeeb1f2e0fa94c4c9b03a9">DGtal::maximalSymmetricExtension</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specialization for Iterator type </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00233">233</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00298">maximalSymmetricExtension()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00566">mostCenteredMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">                 {

  <span class="keywordtype">bool</span> flagOk = <span class="keyword">true</span>; 
  <span class="keywordtype">bool</span> flagForward = <span class="keyword">true</span>; 
  <span class="comment">//while the extension is possible </span>
  <span class="comment">//at the front and (then) at the back</span>
  <span class="keywordflow">while</span> (flagOk)  {
    <span class="keywordflow">if</span> (flagForward) {
      flagForward = <span class="keyword">false</span>; 
      <span class="keywordflow">if</span> ( s.end() != end ) flagOk = s.extendForward();
      <span class="keywordflow">else</span> flagOk = <span class="keyword">false</span>; 
    } <span class="keywordflow">else</span> {
      flagForward = <span class="keyword">true</span>; 
      <span class="keywordflow">if</span> ( s.begin() != begin ) flagOk = s.extendBackward();
      <span class="keywordflow">else</span> flagOk = <span class="keyword">false</span>; 
    } 
  }
  <span class="comment">//extend one more time if s.begin() == begin</span>
  <span class="keywordflow">if</span> (s.begin() != begin ) {
    <span class="keywordflow">if</span> (s.extendBackward()) <span class="keywordflow">return</span> !s.extendForward(); 
    <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">false</span>; 
  } <span class="keywordflow">else</span> {
    <span class="keywordflow">return</span> !flagForward; 
  }

}
</pre></div>
</div>
</div>
<a class="anchor" id="a04bd5266c4907488dc943c3fd18b72a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceDGtal.html#ad8d73948fddeeb1f2e0fa94c4c9b03a9">DGtal::maximalSymmetricExtension</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CirculatorType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specialization for <a class="el" href="classDGtal_1_1Circulator.html" title="Aim: Provides an adapter for STL iterators that can iterate through the underlying data structure as ...">Circulator</a> type </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00267">267</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><pre class="fragment">                   {

  <span class="keywordtype">bool</span> flagOk = <span class="keyword">true</span>; 
  <span class="keywordtype">bool</span> flagForward = <span class="keyword">true</span>; 
  <span class="comment">//while the extensions are possible and</span>
  <span class="comment">//the segment does not correspond to the whole range</span>
  <span class="keywordflow">while</span> ( (flagOk) &amp;&amp; ( s.end() != s.begin() ) )  {
    <span class="keywordflow">if</span> (flagForward) {
      flagForward = <span class="keyword">false</span>; 
      flagOk = s.extendForward(); 
    } <span class="keywordflow">else</span> {
      flagForward = <span class="keyword">true</span>; 
      flagOk = s.extendBackward(); 
    } 
  }
  <span class="keywordflow">return</span> !flagForward; 
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad09a396e60a1ff248a246cc2f365fb31"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceDGtal.html#ad8d73948fddeeb1f2e0fa94c4c9b03a9">DGtal::maximalSymmetricExtension</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calls alternatively s.extendForward() and s.extendBackward() while it is possible </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of (bidirectional)segment computer </td></tr>
    <tr><td class="paramname">begin,end,begin</td><td>and end iterator of a range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>'true' if the extension at the front fails first and 'false' if the extension at the back fails first </dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a bidirectional segment computer, ie. a model of CSegment that ca...">CBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00298">298</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00233">maximalSymmetricExtension()</a>.</p>
<div class="fragment"><pre class="fragment">                                       {

  <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorCirculatorTraits&lt;typename SC::ConstIterator&gt;::Type Type; 
  <span class="keywordflow">return</span> <a class="code" href="namespaceDGtal.html#ad8d73948fddeeb1f2e0fa94c4c9b03a9">maximalSymmetricExtension</a>( s, begin, end, Type() ); 

}
</pre></div>
</div>
</div>
<a class="anchor" id="af78ce7935f43397801a6d65785f71df5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="namespaceDGtal.html#af78ce7935f43397801a6d65785f71df5">DGtal::minDGtal</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the min bewteen to instance of type T.</p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">T</td><td>the type of elements to compare (model of boost::LessThanComparable and EqualityComparable). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first value </td></tr>
    <tr><td class="paramname">b</td><td>second value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the minimum between a and b. </dd></dl>

<p>Definition at line <a class="el" href="GlobalFunctions_8h_source.html#l00064">64</a> of file <a class="el" href="GlobalFunctions_8h_source.html">GlobalFunctions.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    BOOST_CONCEPT_ASSERT((boost::EqualityComparable&lt;T&gt;));
    BOOST_CONCEPT_ASSERT((boost::LessThanComparable&lt;T&gt;));
    <span class="keywordflow">if</span> (a&lt;=b) 
      <span class="keywordflow">return</span> a;
    <span class="keywordflow">else</span>
      <span class="keywordflow">return</span> b;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a770659cf50cd49c0ce6c3d4ab08abb46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;1, Ring, Alloc&gt; <a class="el" href="namespaceDGtal.html#a770659cf50cd49c0ce6c3d4ab08abb46">DGtal::mmonomial</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a monomial in one indeterminate. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the exponent for X_0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the 1-variable polynomial X_0^e </dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
    <tr><td class="paramname">Alloc</td><td>the type of allocator. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l01684">1684</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <a class="code" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial&lt;1, Ring, Alloc&gt;</a> p;
    p[e] = 1;
    <span class="keywordflow">return</span> p;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="ad04b582eb75ae0cfc14dfc40d57c03f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;2, Ring, Alloc&gt; <a class="el" href="namespaceDGtal.html#a770659cf50cd49c0ce6c3d4ab08abb46">DGtal::mmonomial</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a monomial in two indeterminates. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the exponent for X_0 </td></tr>
    <tr><td class="paramname">f</td><td>the exponent for X_1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the 2-variables polynomial X_0^e X_1^f </dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
    <tr><td class="paramname">Alloc</td><td>the type of allocator. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l01702">1702</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <a class="code" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial&lt;2, Ring, Alloc&gt;</a> p;
    p[e][f] = 1;
    <span class="keywordflow">return</span> p;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a46b41f1ac0f88d213c7fb8bee8931799"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;3, Ring, Alloc&gt; <a class="el" href="namespaceDGtal.html#a770659cf50cd49c0ce6c3d4ab08abb46">DGtal::mmonomial</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a monomial in three indeterminates. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the exponent for X_0 </td></tr>
    <tr><td class="paramname">f</td><td>the exponent for X_1 </td></tr>
    <tr><td class="paramname">g</td><td>the exponent for X_2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the 3-variables polynomial X_0^e X_1^f X_2^g </dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
    <tr><td class="paramname">Alloc</td><td>the type of allocator. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l01720">1720</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <a class="code" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial&lt;3, Ring, Alloc&gt;</a> p;
    p[e][f][g] = 1;
    <span class="keywordflow">return</span> p;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="ae6ba6c1f73137c9da0365c16635c92e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;4, Ring, Alloc&gt; <a class="el" href="namespaceDGtal.html#a770659cf50cd49c0ce6c3d4ab08abb46">DGtal::mmonomial</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a monomial in four indeterminates. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the exponent for X_0 </td></tr>
    <tr><td class="paramname">f</td><td>the exponent for X_1 </td></tr>
    <tr><td class="paramname">g</td><td>the exponent for X_2 </td></tr>
    <tr><td class="paramname">h</td><td>the exponent for X_3 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the 3-variables polynomial X_0^e X_1^f X_2^g X_3^h </dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
    <tr><td class="paramname">Alloc</td><td>the type of allocator. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l01740">1740</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <a class="code" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial&lt;4, Ring, Alloc&gt;</a> p;
    p[e][f][g][h] = 1;
    <span class="keywordflow">return</span> p;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a9ef248272fbf9b379c272e0ec632289c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;1, Ring, std::allocator&lt;Ring&gt; &gt; <a class="el" href="namespaceDGtal.html#a770659cf50cd49c0ce6c3d4ab08abb46">DGtal::mmonomial</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a monomial in one indeterminate. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the exponent for X_0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the 1-variable polynomial X_0^e </dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l01756">1756</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <a class="code" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial&lt;1, Ring, std::allocator&lt;Ring&gt;</a> &gt; p;
    p[e] = 1;
    <span class="keywordflow">return</span> p;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a9ac70e986a68541f5a9e2b9a4035da2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;2, Ring, std::allocator&lt;Ring&gt; &gt; <a class="el" href="namespaceDGtal.html#a770659cf50cd49c0ce6c3d4ab08abb46">DGtal::mmonomial</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a monomial in two indeterminates. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the exponent for X_0 </td></tr>
    <tr><td class="paramname">f</td><td>the exponent for X_1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the 2-variables polynomial X_0^e X_1^f </dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l01773">1773</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <a class="code" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial&lt;2, Ring, std::allocator&lt;Ring&gt;</a> &gt; p;
    p[e][f] = 1;
    <span class="keywordflow">return</span> p;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a4f44e0a9fc1e30d29e52646daeca211d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;3, Ring, std::allocator&lt;Ring&gt; &gt; <a class="el" href="namespaceDGtal.html#a770659cf50cd49c0ce6c3d4ab08abb46">DGtal::mmonomial</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a monomial in three indeterminates. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the exponent for X_0 </td></tr>
    <tr><td class="paramname">f</td><td>the exponent for X_1 </td></tr>
    <tr><td class="paramname">g</td><td>the exponent for X_2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the 3-variables polynomial X_0^e X_1^f X_2^g </dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l01791">1791</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <a class="code" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial&lt;3, Ring, std::allocator&lt;Ring&gt;</a> &gt; p;
    p[e][f][g] = 1;
    <span class="keywordflow">return</span> p;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a4a679186eed201b0844c7bf6f83e76c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ring &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;4, Ring, std::allocator&lt;Ring&gt; &gt; <a class="el" href="namespaceDGtal.html#a770659cf50cd49c0ce6c3d4ab08abb46">DGtal::mmonomial</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a monomial in four indeterminates. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the exponent for X_0 </td></tr>
    <tr><td class="paramname">f</td><td>the exponent for X_1 </td></tr>
    <tr><td class="paramname">g</td><td>the exponent for X_2 </td></tr>
    <tr><td class="paramname">h</td><td>the exponent for X_3 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the 3-variables polynomial X_0^e X_1^f X_2^g X_3^h </dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l01811">1811</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <a class="code" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial&lt;4, Ring, std::allocator&lt;Ring&gt;</a> &gt; p;
    p[e][f][g][h] = 1;
    <span class="keywordflow">return</span> p;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a1b3f25b1f654c74c78819624604e4950"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a1b3f25b1f654c74c78819624604e4950">DGtal::mostCenteredMaximalSegment</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the most centered maximal segment passing through i </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CForwardSegmentComputer.html" title="Aim: Defines the concept describing a forward segment computer, ie. a model of CSegment that can exte...">CForwardSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00510">510</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00403">firstMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00087">getMiddleIterator()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00352">longestSegment()</a>.</p>

<p>Referenced by <a class="el" href="SaturatedSegmentation_8ih_source.html#l00104">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::initFirstMaximalSegment()</a>, <a class="el" href="SaturatedSegmentation_8ih_source.html#l00122">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::initLastMaximalSegment()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00600">mostCenteredMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{

  <span class="keyword">typedef</span> <span class="keyword">typename</span> SC::ConstIterator ConstIterator; 
  <span class="keyword">typedef</span> <span class="keyword">typename</span> SC::Reverse ReverseSegmentComputer; 
  <span class="keyword">typedef</span> <span class="keyword">typename</span> ReverseSegmentComputer::ConstIterator ConstReverseIterator; 

 <span class="comment">//get the first maximal segment passing through i</span>

  <a class="code" href="namespaceDGtal.html#ae6d3175b6c7d86845a0c259f566bd7ea">firstMaximalSegment</a>( s, i, begin, end, <a class="code" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>() );

 <span class="comment">//get the next maximal segment while i is not at the middle of </span>
 <span class="comment">//the current maximal segment. </span>

  ConstIterator k( s.begin() ); 
  <span class="keywordflow">while</span> ( k != i ) {

    <span class="keywordflow">if</span> ( isNotEmpty&lt;ConstIterator&gt;(s.end(),end) ) {

      <span class="comment">//backward extension</span>
      ConstIterator it( s.end() ); ++it; 
      ConstReverseIterator rit( it );
      ConstReverseIterator rend( s.begin() );
      ReverseSegmentComputer r( s.getReverse() ); 
      <a class="code" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">longestSegment</a>(r, rit, rend);
      ConstIterator newBegin = r.end().base(); 
      ASSERT( newBegin != s.begin() );

      <span class="keywordflow">while</span> ( ( k != <a class="code" href="namespaceDGtal.html#a8c4fb1b2976e5fc35dc1b4073149408e">getMiddleIterator</a>(newBegin, s.end() ) )
            &amp;&amp;( k != i ) ) {
        ++k; 
      }
      <span class="keywordflow">if</span> ( k != i ) {
   
        <span class="comment">//get the next maximal segment</span>
        <a class="code" href="namespaceDGtal.html#a2034305fadb5376a987519daba4c982a">longestSegment</a>(s, newBegin, end);  

      }

    } <span class="keywordflow">else</span> {
      k = i; 
    }
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad153558eaa4afb851f884b64680f4631"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a1b3f25b1f654c74c78819624604e4950">DGtal::mostCenteredMaximalSegment</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the most centered maximal segment passing through i </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a bidirectional segment computer, ie. a model of CSegment that ca...">CBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00566">566</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="Circulator_8h_source.html#l00566">isNotEmpty()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00163">maximalExtension()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00233">maximalSymmetricExtension()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00197">oppositeEndMaximalExtension()</a>.</p>
<div class="fragment"><pre class="fragment">{
  
  <span class="keywordflow">if</span> ( (<a class="code" href="namespaceDGtal_1_1detail.html#a58243ebf587bb6ca6eafd9184dae75c4">isNotEmpty</a>(i,end)) || (<a class="code" href="namespaceDGtal_1_1detail.html#a58243ebf587bb6ca6eafd9184dae75c4">isNotEmpty</a>(i,begin)) ) { 

    s.init(i);

    <span class="comment">//symmetric extension</span>
    <span class="keywordflow">if</span> ( (<a class="code" href="namespaceDGtal_1_1detail.html#a58243ebf587bb6ca6eafd9184dae75c4">isNotEmpty</a>(i,end)) &amp;&amp; (<a class="code" href="namespaceDGtal_1_1detail.html#a58243ebf587bb6ca6eafd9184dae75c4">isNotEmpty</a>(i,begin)) ) { 
      <a class="code" href="namespaceDGtal.html#ad8d73948fddeeb1f2e0fa94c4c9b03a9">maximalSymmetricExtension</a>(s, begin, end); 
    }

  <span class="comment">//forward extension</span>
  <a class="code" href="namespaceDGtal.html#a4718031e09102bb8f73a874c47e10aaf">maximalExtension</a>(s, end);
      
  <span class="comment">//backward extension</span>
  <a class="code" href="namespaceDGtal.html#a462eaaf587bc04ebd2e6141bed3fc21e">oppositeEndMaximalExtension</a>(s, begin);

  }

}
</pre></div>
</div>
</div>
<a class="anchor" id="a07a2cb535d2b0befce8f080d9d1a2414"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a1b3f25b1f654c74c78819624604e4950">DGtal::mostCenteredMaximalSegment</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the most centered maximal segment passing through i </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicSegmentComputer.html" title="Aim: Defines the concept describing a dynamic segment computer, ie. a model of CSegment that can exte...">CDynamicSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">ForwardSegmentComputer</a> </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00600">600</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00510">mostCenteredMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="namespaceDGtal.html#a1b3f25b1f654c74c78819624604e4950">mostCenteredMaximalSegment</a>(s,i,begin,end,<a class="code" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa43392e8f5aeba868858b9b2c1e52cf7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a1b3f25b1f654c74c78819624604e4950">DGtal::mostCenteredMaximalSegment</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the most centered maximal segment passing through i </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie...">CDynamicBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">BidirectionalSegmentComputer</a> </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00617">617</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00510">mostCenteredMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="namespaceDGtal.html#a1b3f25b1f654c74c78819624604e4950">mostCenteredMaximalSegment</a>(s,i,begin,end,<a class="code" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="adb7b7f5908ea811a44f41186c7a01e8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a1b3f25b1f654c74c78819624604e4950">DGtal::mostCenteredMaximalSegment</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the most centered maximal segment passing through i </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>any ConstIterator </td></tr>
    <tr><td class="paramname">begin,end,any</td><td>pair of ConstIterators bounding a range </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00633">633</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><pre class="fragment">{
   mostCenteredMaximalSegment&lt;SC&gt;(s, i, begin, end, 
<span class="keyword">typename</span> <a class="code" href="structDGtal_1_1SegmentComputerTraits.html#aec543e23f154c340dd52511204ed977f">DGtal::SegmentComputerTraits&lt;SC&gt;::Category</a>() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a91c1293187f38e931f5f353d1a38f71c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a91c1293187f38e931f5f353d1a38f71c">DGtal::nextMaximalSegment</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the next maximal segment of s (s is assumed to be maximal) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">end,any</td><td>end ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CForwardSegmentComputer.html" title="Aim: Defines the concept describing a forward segment computer, ie. a model of CSegment that can exte...">CForwardSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>fistMaximalSegment of s.end() </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00759">759</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00403">firstMaximalSegment()</a>.</p>

<p>Referenced by <a class="el" href="MaximalSegments_8ih_source.html#l00063">DGtal::deprecated::MaximalSegments&lt; TSegment &gt;::SegmentIterator::firstMaximalSegment()</a>, <a class="el" href="SaturatedSegmentation_8ih_source.html#l00168">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::nextMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00820">nextMaximalSegment()</a>, <a class="el" href="MaximalSegments_8ih_source.html#l00368">DGtal::deprecated::MaximalSegments&lt; TSegment &gt;::SegmentIterator::operator++()</a>, and <a class="el" href="SaturatedSegmentation_8ih_source.html#l00323">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::operator++()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="namespaceDGtal.html#ae6d3175b6c7d86845a0c259f566bd7ea">firstMaximalSegment</a>(s, s.end(), s.begin(), end, ForwardSegmentComputer() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0f4fc5b05689abd850faa6637a64505c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a91c1293187f38e931f5f353d1a38f71c">DGtal::nextMaximalSegment</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the next maximal segment of s (s is assumed to be maximal) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">end,end</td><td>ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a bidirectional segment computer, ie. a model of CSegment that ca...">CBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>fistMaximalSegment of s.end() </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00774">774</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00403">firstMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="namespaceDGtal.html#ae6d3175b6c7d86845a0c259f566bd7ea">firstMaximalSegment</a>(s, s.end(), s.begin(), end, <a class="code" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6ee548c7f570f6bdb18ce2cc592cb009"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a91c1293187f38e931f5f353d1a38f71c">DGtal::nextMaximalSegment</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the next maximal segment of s (s is assumed to be maximal) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">end,end</td><td>ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicSegmentComputer.html" title="Aim: Defines the concept describing a dynamic segment computer, ie. a model of CSegment that can exte...">CDynamicSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00788">788</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00163">maximalExtension()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00316">maximalRetraction()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">typedef</span> <span class="keyword">typename</span> SC::ConstIterator ConstIterator; 

  <span class="comment">//rectract</span>
  <a class="code" href="namespaceDGtal.html#ad4831d5ff3c1c70bd1c6a26403297a9a">maximalRetraction</a>(s, end); 

  <span class="comment">//intersection test</span>
  ConstIterator i( s.begin() ); ++i; 
  <span class="comment">//if the intersection between the two </span>
  <span class="comment">// consecutive maximal segments is empty </span>
  <span class="keywordflow">if</span> ( i == s.end() ) {
    <span class="keywordflow">if</span> ( isNotEmpty&lt;ConstIterator&gt;(i, end) ) {
      ++i; 
      s.init(i);  
    }
  }

  <span class="comment">//extend</span>
  <a class="code" href="namespaceDGtal.html#a4718031e09102bb8f73a874c47e10aaf">maximalExtension</a>(s, end);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae9e6d98ecc15fc5062f30060d4452706"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a91c1293187f38e931f5f353d1a38f71c">DGtal::nextMaximalSegment</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the next maximal segment of s (s is assumed to be maximal) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">end,end</td><td>ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie...">CDynamicBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DynamicSegmentComputer</a> </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00820">820</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00759">nextMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{ 
  <a class="code" href="namespaceDGtal.html#a91c1293187f38e931f5f353d1a38f71c">nextMaximalSegment</a>(s, end, <a class="code" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>() ); 
}
</pre></div>
</div>
</div>
<a class="anchor" id="a325d2a962cd3410424a45f83c1b32b7a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a91c1293187f38e931f5f353d1a38f71c">DGtal::nextMaximalSegment</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the next maximal segment of s (s is assumed to be maximal) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">end,any</td><td>end ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00834">834</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><pre class="fragment">{
   nextMaximalSegment&lt;SC&gt;(s, end, 
<span class="keyword">typename</span> <a class="code" href="structDGtal_1_1SegmentComputerTraits.html#aec543e23f154c340dd52511204ed977f">DGtal::SegmentComputerTraits&lt;SC&gt;::Category</a>() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5953d43d65a342438b932b5fac6a0334"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="namespaceDGtal.html#a5953d43d65a342438b932b5fac6a0334">DGtal::normalize</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vec</em>[3]</td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Normalize the input 3d vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>source &amp; destination vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Display3D_8ih_source.html#l00071">71</a> of file <a class="el" href="Display3D_8ih_source.html">Display3D.ih</a>.</p>

<p>Referenced by <a class="el" href="Display3D_8ih_source.html#l00297">DGtal::Display3D::addKSSurfel()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keywordtype">double</span> squaredLen = vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2];
  <span class="keyword">const</span> <span class="keywordtype">double</span> invLen = 1.0 /  sqrt (squaredLen);

  vec[0] *= invLen;
  vec[1] *= invLen;
  vec[2] *= invLen;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a411c7581c1016c57eae331f090729c37"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TFunctor , typename TReturnType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1IteratorAdapter.html">IteratorAdapter</a>&lt;TIterator,TFunctor,TReturnType&gt; DGtal::operator+ </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structDGtal_1_1IteratorCirculatorTraits.html">IteratorCirculatorTraits</a>&lt; TIterator &gt;::Difference&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1IteratorAdapter.html">IteratorAdapter</a>&lt; TIterator, TFunctor, TReturnType &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="IteratorAdapter_8h_source.html#l00333">333</a> of file <a class="el" href="IteratorAdapter_8h_source.html">IteratorAdapter.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <a class="code" href="classDGtal_1_1IteratorAdapter.html" title="This class adapts any iterator (at least forward) so that operator* returns a member on the element p...">IteratorAdapter&lt;TIterator,TFunctor,TReturnType&gt;</a> tmp = object;
    <span class="keywordflow">return</span> tmp += d;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a700746047887dc625f6d85e5c4923ae1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TFunctor , typename TReturnType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1ConstIteratorAdapter.html">ConstIteratorAdapter</a>&lt;TIterator,TFunctor,TReturnType&gt; DGtal::operator+ </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structDGtal_1_1IteratorCirculatorTraits.html">IteratorCirculatorTraits</a>&lt; TIterator &gt;::Difference&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1ConstIteratorAdapter.html">ConstIteratorAdapter</a>&lt; TIterator, TFunctor, TReturnType &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ConstIteratorAdapter_8h_source.html#l00335">335</a> of file <a class="el" href="ConstIteratorAdapter_8h_source.html">ConstIteratorAdapter.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <a class="code" href="classDGtal_1_1ConstIteratorAdapter.html" title="This class adapts any iterator (at least forward) so that operator* returns another element than the ...">ConstIteratorAdapter&lt;TIterator,TFunctor,TReturnType&gt;</a> tmp = object;
    <span class="keywordflow">return</span> tmp += d;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a2e60731c3d380a3d904efbf5c088cf07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1BLUELocalLengthEstimator.html">BLUELocalLengthEstimator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1BLUELocalLengthEstimator.html" title="Aim: Best Linear Unbiased Two step length estimator.">BLUELocalLengthEstimator</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1BLUELocalLengthEstimator.html" title="Aim: Best Linear Unbiased Two step length estimator.">BLUELocalLengthEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b1f11e76731f6b53d58741593de1718"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1RosenProffittLocalLengthEstimator.html">RosenProffittLocalLengthEstimator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1RosenProffittLocalLengthEstimator.html" title="Aim: Rosen-Proffitt Length Estimator.">RosenProffittLocalLengthEstimator</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1RosenProffittLocalLengthEstimator.html" title="Aim: Rosen-Proffitt Length Estimator.">RosenProffittLocalLengthEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1a0c72f3ea963c433d33b86d1fba535"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TraceWriter &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1TraceWriter.html" title="Virtual Class to implement trace writers.">TraceWriter</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1TraceWriter.html" title="Virtual Class to implement trace writers.">TraceWriter</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a3e210a0da2db0fe767f88859a7ec00ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContourHelper &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ContourHelper.html" title="Aim: a helper class to process sequences of points.">ContourHelper</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ContourHelper.html" title="Aim: a helper class to process sequences of points.">ContourHelper</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ContourHelper_8ih_source.html#l00070">70</a> of file <a class="el" href="ContourHelper_8ih_source.html">ContourHelper.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">object</span>.selfDisplay ( out );
    <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="abb0ae3e476260be1ddbbe6c881738e81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TraceWriterFile &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1TraceWriterFile.html">TraceWriterFile</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1TraceWriterFile.html">TraceWriterFile</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b43a30839ecc0499b0b5d2d71952233"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CowPtr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1CowPtr.html" title="Aim: Copy on write shared pointer.">CowPtr</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1CowPtr.html" title="Aim: Copy on write shared pointer.">CowPtr</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="CowPtr_8ih_source.html#l00077">77</a> of file <a class="el" href="CowPtr_8ih_source.html">CowPtr.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa5ad29732984e904acf8a15b5f36f391"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CountedPtr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1CountedPtr.html" title="Aim: Smart pointer based on reference counts.">CountedPtr</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1CountedPtr.html" title="Aim: Smart pointer based on reference counts.">CountedPtr</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="CountedPtr_8ih_source.html#l00077">77</a> of file <a class="el" href="CountedPtr_8ih_source.html">CountedPtr.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1c198285c212e189cc6b3775282d971b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1CanonicEmbedder.html">CanonicEmbedder</a>&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="structDGtal_1_1CanonicEmbedder.html" title="Aim: A trivial embedder for digital points, which corresponds to the canonic injection of Zn into Rn...">CanonicEmbedder</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="structDGtal_1_1CanonicEmbedder.html" title="Aim: A trivial embedder for digital points, which corresponds to the canonic injection of Zn into Rn...">CanonicEmbedder</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="CanonicEmbedder_8ih_source.html#l00115">115</a> of file <a class="el" href="CanonicEmbedder_8ih_source.html">CanonicEmbedder.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">object</span>.selfDisplay ( out );
    <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a105d0f6359b68e48600e22cf765f4aaa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim, typename TInteger &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1KhalimskyCell.html">KhalimskyCell</a>&lt; dim, TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="KhalimskySpaceND_8ih_source.html#l00127">127</a> of file <a class="el" href="KhalimskySpaceND_8ih_source.html">KhalimskySpaceND.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  out &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; <span class="keywordtype">object</span>.myCoordinates[ 0 ];
  <span class="keywordflow">for</span> ( <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> i = 1; i &lt; dim; ++i )
    out &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; <span class="keywordtype">object</span>.myCoordinates[ i ];
  out &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af0a7679f68647399382399dc1608a6dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TImage &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BoundaryPredicate&lt; TKSpace, TImage &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1BoundaryPredicate.html" title="Aim: The predicate on surfels that represents the frontier between a region and its complementary in ...">BoundaryPredicate</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1BoundaryPredicate.html" title="Aim: The predicate on surfels that represents the frontier between a region and its complementary in ...">BoundaryPredicate</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="BoundaryPredicate_8ih_source.html#l00128">128</a> of file <a class="el" href="BoundaryPredicate_8ih_source.html">BoundaryPredicate.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">object</span>.selfDisplay ( out );
    <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1f268b8a695128c059e37512d115571f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SurfelAdjacency&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1SurfelAdjacency.html" title="Aim: Represent adjacencies between surfel elements, telling if it follows an interior to exterior ord...">SurfelAdjacency</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1SurfelAdjacency.html" title="Aim: Represent adjacencies between surfel elements, telling if it follows an interior to exterior ord...">SurfelAdjacency</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="SurfelAdjacency_8ih_source.html#l00131">131</a> of file <a class="el" href="SurfelAdjacency_8ih_source.html">SurfelAdjacency.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">object</span>.selfDisplay ( out );
    <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac60851b0fad3cc7d11289811fd942728"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TImage &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FrontierPredicate&lt; TKSpace, TImage &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1FrontierPredicate.html" title="Aim: The predicate on surfels that represents the frontier between two regions in an image...">FrontierPredicate</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1FrontierPredicate.html" title="Aim: The predicate on surfels that represents the frontier between two regions in an image...">FrontierPredicate</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="FrontierPredicate_8ih_source.html#l00127">127</a> of file <a class="el" href="FrontierPredicate_8ih_source.html">FrontierPredicate.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">object</span>.selfDisplay ( out );
    <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8b8a89999c5ec643ec73f257abe6c488"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const L1LengthEstimator&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1L1LengthEstimator.html" title="Aim: a simple model of CGlobalCurveEstimator that compute the length of a curve using the l_1 metric ...">L1LengthEstimator</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1L1LengthEstimator.html" title="Aim: a simple model of CGlobalCurveEstimator that compute the length of a curve using the l_1 metric ...">L1LengthEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="L1LengthEstimator_8ih_source.html#l00145">145</a> of file <a class="el" href="L1LengthEstimator_8ih_source.html">L1LengthEstimator.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a61e5d3bce501d46ca6cb4baee8590389"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1CanonicCellEmbedder.html">CanonicCellEmbedder</a>&lt; TKSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="structDGtal_1_1CanonicCellEmbedder.html" title="Aim: A trivial embedder for unsigned cell, which corresponds to the canonic injection of cell centroi...">CanonicCellEmbedder</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="structDGtal_1_1CanonicCellEmbedder.html" title="Aim: A trivial embedder for unsigned cell, which corresponds to the canonic injection of cell centroi...">CanonicCellEmbedder</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="CanonicCellEmbedder_8ih_source.html#l00130">130</a> of file <a class="el" href="CanonicCellEmbedder_8ih_source.html">CanonicCellEmbedder.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">object</span>.selfDisplay ( out );
    <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="afc39fa68fdb704b43c5f89b871030b30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1CanonicSCellEmbedder.html">CanonicSCellEmbedder</a>&lt; TKSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="structDGtal_1_1CanonicSCellEmbedder.html" title="Aim: A trivial embedder for signed cell, which corresponds to the canonic injection of cell centroids...">CanonicSCellEmbedder</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="structDGtal_1_1CanonicSCellEmbedder.html" title="Aim: A trivial embedder for signed cell, which corresponds to the canonic injection of cell centroids...">CanonicSCellEmbedder</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="CanonicSCellEmbedder_8ih_source.html#l00130">130</a> of file <a class="el" href="CanonicSCellEmbedder_8ih_source.html">CanonicSCellEmbedder.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">object</span>.selfDisplay ( out );
    <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="abbf878eedd1e61f021f337b903ac1a5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDigitalSurface &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1CanonicDigitalSurfaceEmbedder.html">CanonicDigitalSurfaceEmbedder</a>&lt; TDigitalSurface &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="structDGtal_1_1CanonicDigitalSurfaceEmbedder.html" title="Aim: A trivial embedder for digital surfaces, which corresponds to the canonic injection of cell cent...">CanonicDigitalSurfaceEmbedder</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="structDGtal_1_1CanonicDigitalSurfaceEmbedder.html" title="Aim: A trivial embedder for digital surfaces, which corresponds to the canonic injection of cell cent...">CanonicDigitalSurfaceEmbedder</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="CanonicDigitalSurfaceEmbedder_8ih_source.html#l00130">130</a> of file <a class="el" href="CanonicDigitalSurfaceEmbedder_8ih_source.html">CanonicDigitalSurfaceEmbedder.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">object</span>.selfDisplay ( out );
    <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9611bc4af426ac90cd62f4f0d147d686"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FPLengthEstimator&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1FPLengthEstimator.html" title="Aim: a model of CGlobalCurveEstimator that computes the length of a digital curve using its FP (faith...">FPLengthEstimator</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1FPLengthEstimator.html" title="Aim: a model of CGlobalCurveEstimator that computes the length of a digital curve using its FP (faith...">FPLengthEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="FPLengthEstimator_8ih_source.html#l00154">154</a> of file <a class="el" href="FPLengthEstimator_8ih_source.html">FPLengthEstimator.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5b8eb9b80ef38f0b355c23ce44caec57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MLPLengthEstimator&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1MLPLengthEstimator.html" title="Aim: a model of CGlobalCurveEstimator that computes the length of a digital curve using its MLP (give...">MLPLengthEstimator</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1MLPLengthEstimator.html" title="Aim: a model of CGlobalCurveEstimator that computes the length of a digital curve using its MLP (give...">MLPLengthEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="MLPLengthEstimator_8ih_source.html#l00153">153</a> of file <a class="el" href="MLPLengthEstimator_8ih_source.html">MLPLengthEstimator.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a71ebae2f928719f51222d9830f580ab6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Measure.html">Measure</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Measure.html" title="Aim: Implements a simple measure computation (in the Lesbegue sens) of a set. In dimension 2...">Measure</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Measure.html" title="Aim: Implements a simple measure computation (in the Lesbegue sens) of a set. In dimension 2...">Measure</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a855e675db4e5e115051b87a6c79c6f36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDigitalSurface , typename TNormalVectorEstimator , typename TEmbedder &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1NormalVectorEstimatorLinearCellEmbedder.html">NormalVectorEstimatorLinearCellEmbedder</a>&lt; TDigitalSurface, TNormalVectorEstimator, TEmbedder &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1NormalVectorEstimatorLinearCellEmbedder.html" title="Aim: model of cellular embedder for normal vector estimators on digital surface, (default constructib...">NormalVectorEstimatorLinearCellEmbedder</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1NormalVectorEstimatorLinearCellEmbedder.html" title="Aim: model of cellular embedder for normal vector estimators on digital surface, (default constructib...">NormalVectorEstimatorLinearCellEmbedder</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ebfff66f1d6cdbd2b15f83c2ee8c55b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TwoStepLocalLengthEstimator&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1TwoStepLocalLengthEstimator.html" title="Aim: a simple model of CGlobalCurveEstimator that compute the length of a curve using the l_1 metric ...">TwoStepLocalLengthEstimator</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1TwoStepLocalLengthEstimator.html" title="Aim: a simple model of CGlobalCurveEstimator that compute the length of a curve using the l_1 metric ...">TwoStepLocalLengthEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="TwoStepLocalLengthEstimator_8ih_source.html#l00154">154</a> of file <a class="el" href="TwoStepLocalLengthEstimator_8ih_source.html">TwoStepLocalLengthEstimator.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac4d5198d8a044649b47cf6ccecf43549"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Clock.html">Clock</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Clock.html">Clock</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Clock.html">Clock</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Clock_8h_source.html#l00177">177</a> of file <a class="el" href="Clock_8h_source.html">Clock.h</a>.</p>
<div class="fragment"><pre class="fragment">    {
      <span class="keywordtype">object</span>.selfDisplay( out );
      <span class="keywordflow">return</span> out;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ac81440dbce679bb785c1679dc6b226af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DSSLengthEstimator&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DSSLengthEstimator.html" title="Aim: a model of CGlobalCurveEstimator that segments the digital curve into DSS and computes the lengt...">DSSLengthEstimator</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DSSLengthEstimator.html" title="Aim: a model of CGlobalCurveEstimator that segments the digital curve into DSS and computes the lengt...">DSSLengthEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DSSLengthEstimator_8ih_source.html#l00159">159</a> of file <a class="el" href="DSSLengthEstimator_8ih_source.html">DSSLengthEstimator.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a31c3aec34372e12bb2a4b530ebefb1b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ImplicitPolynomial3Shape.html">ImplicitPolynomial3Shape</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImplicitPolynomial3Shape.html" title="Aim: model of CEuclideanOrientedShape concepts to create a shape from a polynomial.">ImplicitPolynomial3Shape</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImplicitPolynomial3Shape.html" title="Aim: model of CEuclideanOrientedShape concepts to create a shape from a polynomial.">ImplicitPolynomial3Shape</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="aa60540f21dc15c6580824e2e370a7600"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TraceWriterTerm &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1TraceWriterTerm.html" title="Implements trace prefix for color terminals.">TraceWriterTerm</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1TraceWriterTerm.html" title="Implements trace prefix for color terminals.">TraceWriterTerm</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="abd178d36151704c1413d4ad614e7f774"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ImplicitBall&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImplicitBall.html" title="Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create a ball in nD...">ImplicitBall</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImplicitBall.html" title="Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create a ball in nD...">ImplicitBall</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ImplicitBall_8ih_source.html#l00085">85</a> of file <a class="el" href="ImplicitBall_8ih_source.html">ImplicitBall.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0862dd8a38f8e16ed9bc34ad6ba2bc55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomColorMap &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1RandomColorMap.html" title="Aim: access to random color from a gradientColorMap.">RandomColorMap</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1RandomColorMap.html" title="Aim: access to random color from a gradientColorMap.">RandomColorMap</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="RandomColorMap_8ih_source.html#l00157">157</a> of file <a class="el" href="RandomColorMap_8ih_source.html">RandomColorMap.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">object</span>.selfDisplay ( out );
    <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac3c6d87ade0e0da551f72c4e645771e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Board2D.html">Board2D</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Board2D.html" title="Aim: This class specializes a &#39;Board&#39; class so as to display DGtal objects more naturally (with &lt;&lt;)...">Board2D</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Board2D.html" title="Aim: This class specializes a &#39;Board&#39; class so as to display DGtal objects more naturally (with &lt;&lt;)...">Board2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Board2D_8ih_source.html#l00149">149</a> of file <a class="el" href="Board2D_8ih_source.html">Board2D.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">object</span>.selfDisplay ( out );
    <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa22cc58968d7134d4ec338d8b6d49f47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1RegularPointEmbedder.html">RegularPointEmbedder</a>&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1RegularPointEmbedder.html" title="Aim: A simple point embedder where grid steps are given for each axis. Note that the real point (0...">RegularPointEmbedder</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1RegularPointEmbedder.html" title="Aim: A simple point embedder where grid steps are given for each axis. Note that the real point (0...">RegularPointEmbedder</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="RegularPointEmbedder_8ih_source.html#l00189">189</a> of file <a class="el" href="RegularPointEmbedder_8ih_source.html">RegularPointEmbedder.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aeebf10a683d3e958f2b53c11af2e8548"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TImplicitFunction , typename TEmbedder &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ImplicitFunctionLinearCellEmbedder&lt; TKSpace, TImplicitFunction, TEmbedder &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImplicitFunctionLinearCellEmbedder.html" title="Aim: a cellular embedder for implicit functions, (default constructible, copy constructible, assignable). Model of CCellEmbedder.">ImplicitFunctionLinearCellEmbedder</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImplicitFunctionLinearCellEmbedder.html" title="Aim: a cellular embedder for implicit functions, (default constructible, copy constructible, assignable). Model of CCellEmbedder.">ImplicitFunctionLinearCellEmbedder</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ImplicitFunctionLinearCellEmbedder_8ih_source.html#l00195">195</a> of file <a class="el" href="ImplicitFunctionLinearCellEmbedder_8ih_source.html">ImplicitFunctionLinearCellEmbedder.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="adbf9270f5f724d5e51d1356f3372783c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IVViewer &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1IVViewer.html" title="Aim: A facade to represent an inventor window for 3D objects. May be a SoXt or a SoQt examiner viewer...">IVViewer</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1IVViewer.html" title="Aim: A facade to represent an inventor window for 3D objects. May be a SoXt or a SoQt examiner viewer...">IVViewer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="IVViewer_8ih_source.html#l00054">54</a> of file <a class="el" href="IVViewer_8ih_source.html">IVViewer.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">object</span>.selfDisplay ( out );
    <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae4f0a1e7a73fe21a13f6809e3a47ff0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ModuloComputer.html">ModuloComputer</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Displays <code>object</code> on the output stream <code>out</code>.</p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">T</td><td>the type of integer for the modulo computer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream </td></tr>
    <tr><td class="paramname">object</td><td>the object to display. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ModuloComputer_8h_source.html#l00208">208</a> of file <a class="el" href="ModuloComputer_8h_source.html">ModuloComputer.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordtype">object</span>.selfDisplay( out );
    <span class="keywordflow">return</span> out;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a7272fa4a71b37b89de44110188769338"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TImage , typename TEmbedder &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ImageLinearCellEmbedder&lt; TKSpace, TImage, TEmbedder &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImageLinearCellEmbedder.html" title="Aim: a cellular embedder for images. (default constructible, copy constructible, assignable). Model of CCellEmbedder.">ImageLinearCellEmbedder</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImageLinearCellEmbedder.html" title="Aim: a cellular embedder for images. (default constructible, copy constructible, assignable). Model of CCellEmbedder.">ImageLinearCellEmbedder</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ImageLinearCellEmbedder_8ih_source.html#l00206">206</a> of file <a class="el" href="ImageLinearCellEmbedder_8ih_source.html">ImageLinearCellEmbedder.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a670552923873f4f08a0c8d2ecf75cbe9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ImplicitNorm1Ball&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImplicitNorm1Ball.html" title="Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create a ball for the L_...">ImplicitNorm1Ball</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImplicitNorm1Ball.html" title="Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create a ball for the L_...">ImplicitNorm1Ball</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ImplicitNorm1Ball_8ih_source.html#l00085">85</a> of file <a class="el" href="ImplicitNorm1Ball_8ih_source.html">ImplicitNorm1Ball.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9c9db375c56d37d5a38a7599c7e02e07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1StraightLineFrom2Points.html">StraightLineFrom2Points</a>&lt; TPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1StraightLineFrom2Points.html" title="Aim: Represents a straight line uniquely defined by two 2D points and that is able to return for any ...">StraightLineFrom2Points</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1StraightLineFrom2Points.html" title="Aim: Represents a straight line uniquely defined by two 2D points and that is able to return for any ...">StraightLineFrom2Points</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="StraightLineFrom2Points_8h_source.html#l00210">210</a> of file <a class="el" href="StraightLineFrom2Points_8h_source.html">StraightLineFrom2Points.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordtype">object</span>.selfDisplay( out );
    <span class="keywordflow">return</span> out;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a8a88c744566a4a1adce2dd7d55256bbd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ImplicitHyperCube&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImplicitHyperCube.html" title="Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create an hypercube in n...">ImplicitHyperCube</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImplicitHyperCube.html" title="Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create an hypercube in n...">ImplicitHyperCube</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ImplicitHyperCube_8ih_source.html#l00085">85</a> of file <a class="el" href="ImplicitHyperCube_8ih_source.html">ImplicitHyperCube.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a64c1c0996bfe10bd42952cad2d72ecdb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DigitalSetDomain.html">DigitalSetDomain</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalSetDomain.html" title="Aim: Constructs a domain limited to the given digital set.">DigitalSetDomain</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalSetDomain.html" title="Aim: Constructs a domain limited to the given digital set.">DigitalSetDomain</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a485151b618f71a80d057c3c7d35e84ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1GrayscaleColorMap.html">GrayscaleColorMap</a>&lt; PValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1GrayscaleColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into gray l...">GrayscaleColorMap</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1GrayscaleColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into gray l...">GrayscaleColorMap</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="ae5cfe3192eb33036ed5a6afdce4fa90c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Trace &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Trace.html" title="implementation of basic methods to trace out messages with indentation levels.">Trace</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Trace.html" title="implementation of basic methods to trace out messages with indentation levels.">Trace</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Trace_8ih_source.html#l00260">260</a> of file <a class="el" href="Trace_8ih_source.html">Trace.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1d0842bcae55bdd9b262e906c5b3a79d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ball2D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Ball2D.html" title="Aim: Model of the concept StarShaped represents any circle in the plane.">Ball2D</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Ball2D.html" title="Aim: Model of the concept StarShaped represents any circle in the plane.">Ball2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Ball2D_8ih_source.html#l00191">191</a> of file <a class="el" href="Ball2D_8ih_source.html">Ball2D.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a094a29952a05e86998aaf467bb013d1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ImplicitRoundedHyperCube&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImplicitRoundedHyperCube.html" title="Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create a rounded hypercu...">ImplicitRoundedHyperCube</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImplicitRoundedHyperCube.html" title="Aim: model of CEuclideanOrientedShape and CEuclideanBoundedShape concepts to create a rounded hypercu...">ImplicitRoundedHyperCube</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ImplicitRoundedHyperCube_8ih_source.html#l00085">85</a> of file <a class="el" href="ImplicitRoundedHyperCube_8ih_source.html">ImplicitRoundedHyperCube.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7b3757780615da753f109e91c107bbd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSequence , typename TRank &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIteratorWithRankOnSequence&lt; TSequence, TRank &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1InputIteratorWithRankOnSequence.html" title="Aim: Useful to create an iterator that returns a pair (value,rank) when visiting a sequence...">InputIteratorWithRankOnSequence</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1InputIteratorWithRankOnSequence.html" title="Aim: Useful to create an iterator that returns a pair (value,rank) when visiting a sequence...">InputIteratorWithRankOnSequence</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="InputIteratorWithRankOnSequence_8ih_source.html#l00204">204</a> of file <a class="el" href="InputIteratorWithRankOnSequence_8ih_source.html">InputIteratorWithRankOnSequence.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a585a463f4055c1df3774c34bc4d1c5fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CircleFrom2Points.html">CircleFrom2Points</a>&lt; TPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1CircleFrom2Points.html" title="Aim: Represents a circle that passes through a given point and that is thus uniquely defined by two o...">CircleFrom2Points</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1CircleFrom2Points.html" title="Aim: Represents a circle that passes through a given point and that is thus uniquely defined by two o...">CircleFrom2Points</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="CircleFrom2Points_8h_source.html#l00231">231</a> of file <a class="el" href="CircleFrom2Points_8h_source.html">CircleFrom2Points.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordtype">object</span>.selfDisplay( out );
    <span class="keywordflow">return</span> out;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="aa8be5db54eccfba7fd8916763cbf00da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TForegroundAdjacency , typename TBackgroundAdjacency &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DigitalTopology&lt; TForegroundAdjacency, TBackgroundAdjacency &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalTopology.html" title="Aim: Represents a digital topology as a couple of adjacency relations.">DigitalTopology</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalTopology.html" title="Aim: Represents a digital topology as a couple of adjacency relations.">DigitalTopology</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DigitalTopology_8ih_source.html#l00181">181</a> of file <a class="el" href="DigitalTopology_8ih_source.html">DigitalTopology.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5ee88b42fe08c64c833f2b785139063c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPoint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CircleFrom3Points.html">CircleFrom3Points</a>&lt; TPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1CircleFrom3Points.html" title="Aim: Represents a circle uniquely defined by three 2D points and that is able to return for any given...">CircleFrom3Points</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1CircleFrom3Points.html" title="Aim: Represents a circle uniquely defined by three 2D points and that is able to return for any given...">CircleFrom3Points</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="CircleFrom3Points_8h_source.html#l00236">236</a> of file <a class="el" href="CircleFrom3Points_8h_source.html">CircleFrom3Points.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordtype">object</span>.selfDisplay( out );
    <span class="keywordflow">return</span> out;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="aa32e43bdffbdc24f45de94ad9102978a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Board3DTo2D.html">Board3DTo2D</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Board3DTo2D.html" title="Class for PDF, PNG, PS, EPS, SVG export drawings with Cairo with 3D-&gt;2D projection.">Board3DTo2D</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Board3DTo2D.html" title="Class for PDF, PNG, PS, EPS, SVG export drawings with Cairo with 3D-&gt;2D projection.">Board3DTo2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a0cadab732dfb13c3b84f49566f5b9c11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PValue , int PDefaultColor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ColorBrightnessColorMap&lt; PValue, PDefaultColor &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ColorBrightnessColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into a colo...">ColorBrightnessColorMap</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ColorBrightnessColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into a colo...">ColorBrightnessColorMap</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ColorBrightnessColorMap_8ih_source.html#l00163">163</a> of file <a class="el" href="ColorBrightnessColorMap_8ih_source.html">ColorBrightnessColorMap.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a075acfb401c86aea97863e49764f7e74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim, typename TInteger &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDGtal_1_1SignedKhalimskyCell.html">SignedKhalimskyCell</a>&lt; dim, TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="KhalimskySpaceND_8ih_source.html#l00222">222</a> of file <a class="el" href="KhalimskySpaceND_8ih_source.html">KhalimskySpaceND.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  out &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; <span class="keywordtype">object</span>.myCoordinates[ 0 ];
  <span class="keywordflow">for</span> ( <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> i = 1; i &lt; dim; ++i )
    out &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; <span class="keywordtype">object</span>.myCoordinates[ i ];
  out &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; ( <span class="keywordtype">object</span>.myPositive ? <span class="charliteral">&#39;+&#39;</span> : <span class="charliteral">&#39;-&#39;</span> );
  out &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a69f3490f30f770c8fc9fc6dd445cd93c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PValue , int DefaultCycles&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1HueShadeColorMap.html">HueShadeColorMap</a>&lt; PValue, DefaultCycles &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1HueShadeColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into a colo...">HueShadeColorMap</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1HueShadeColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into a colo...">HueShadeColorMap</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a33aab58c74f85bff95f973d4ba9afde4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TFunctor , typename TValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ConstImageAdapter.html">ConstImageAdapter</a>&lt; TImage, TFunctor, TValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a model of CConstImage that adapts an underlying image.">ConstImageAdapter</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ConstImageAdapter.html" title="Aim: implements a model of CConstImage that adapts an underlying image.">ConstImageAdapter</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e209bc654b6b3088e3d880d4eb24a96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ellipse2D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Ellipse2D.html" title="Aim: Model of the concept StarShaped represents any ellipse in the plane.">Ellipse2D</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Ellipse2D.html" title="Aim: Model of the concept StarShaped represents any ellipse in the plane.">Ellipse2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Ellipse2D_8ih_source.html#l00236">236</a> of file <a class="el" href="Ellipse2D_8ih_source.html">Ellipse2D.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae1caecda191f889867656183eabae2f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NGon2D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1NGon2D.html" title="Aim: Model of the concept StarShaped represents any regular k-gon in the plane.">NGon2D</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1NGon2D.html" title="Aim: Model of the concept StarShaped represents any regular k-gon in the plane.">NGon2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="NGon2D_8ih_source.html#l00242">242</a> of file <a class="el" href="NGon2D_8ih_source.html">NGon2D.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a30df8b8fe139c899b9f825d7e5f6398d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDomain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Shapes&lt; TDomain &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Shapes.html" title="Aim: A utility class for constructing different shapes (balls, diamonds, and others).">Shapes</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Shapes.html" title="Aim: A utility class for constructing different shapes (balls, diamonds, and others).">Shapes</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DGtal_2shapes_2Shapes_8ih_source.html#l00281">281</a> of file <a class="el" href="DGtal_2shapes_2Shapes_8ih_source.html">DGtal/shapes/Shapes.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a44bf615980e20b3cd46b582b7141a6a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDomain , typename TValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const experimental::ImageContainerByITKImage&lt; TDomain, TValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ImageContainerByITKImage_8ih_source.html#l00252">252</a> of file <a class="el" href="ImageContainerByITKImage_8ih_source.html">ImageContainerByITKImage.ih</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordtype">object</span>.selfDisplay( out );
    <span class="keywordflow">return</span> out;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="aa8e4002c881f8a192a8185c3a0a80d1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace , Dimension maxNorm1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1MetricAdjacency.html">MetricAdjacency</a>&lt; TSpace, maxNorm1, TSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1MetricAdjacency.html" title="Aim: Describes digital adjacencies in digital spaces that are defined with the 1-norm and the infinit...">MetricAdjacency</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1MetricAdjacency.html" title="Aim: Describes digital adjacencies in digital spaces that are defined with the 1-norm and the infinit...">MetricAdjacency</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="MetricAdjacency_8ih_source.html#l00268">268</a> of file <a class="el" href="MetricAdjacency_8ih_source.html">MetricAdjacency.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a008281343ea4fc3971b69a6543b9b842"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DGtalInventor&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DGtalInventor.html" title="Aim: A stream object based on Open Inventor for exporting or displaying DGtal objects.">DGtalInventor</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DGtalInventor.html" title="Aim: A stream object based on Open Inventor for exporting or displaying DGtal objects.">DGtalInventor</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DGtalInventor_8ih_source.html#l00389">389</a> of file <a class="el" href="DGtalInventor_8ih_source.html">DGtalInventor.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2d3fcda6867c1a6cae9a2011a8c1b30c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Lattice&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Lattice.html" title="Aim: Represents an n-dimensional integer lattice in an m-dimensional real vector space.">Lattice</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Lattice.html" title="Aim: Represents an n-dimensional integer lattice in an m-dimensional real vector space.">Lattice</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Lattice_8ih_source.html#l00362">362</a> of file <a class="el" href="Lattice_8ih_source.html">Lattice.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a30d8ad5b6fd2dc5b1a3cff0afc4e3a5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDomain , typename TValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ImageContainerBySTLMap.html">ImageContainerBySTLMap</a>&lt; TDomain, TValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ImageContainerBySTLMap_8h_source.html#l00262">262</a> of file <a class="el" href="ImageContainerBySTLMap_8h_source.html">ImageContainerBySTLMap.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordtype">object</span>.selfDisplay ( out );
    <span class="keywordflow">return</span> out;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="abb59a7087b1ca526c94078e5cc499672"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Color &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Color.html" title="Structure representing an RGB triple.">Color</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Color.html" title="Structure representing an RGB triple.">Color</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Color_8ih_source.html#l00054">54</a> of file <a class="el" href="Color_8ih_source.html">Color.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">object</span>.selfDisplay ( out );
    <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a311a8c89ec31846a61238a44a48c51c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDigitalSurfaceEmbedder , typename TNormalVectorEstimator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DigitalSurfaceEmbedderWithNormalVectorEstimator&lt; TDigitalSurfaceEmbedder, TNormalVectorEstimator &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalSurfaceEmbedderWithNormalVectorEstimator.html" title="Aim: Combines a digital surface embedder with a normal vector estimator to get a model of CDigitalSur...">DigitalSurfaceEmbedderWithNormalVectorEstimator</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalSurfaceEmbedderWithNormalVectorEstimator.html" title="Aim: Combines a digital surface embedder with a normal vector estimator to get a model of CDigitalSur...">DigitalSurfaceEmbedderWithNormalVectorEstimator</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DigitalSurfaceEmbedderWithNormalVectorEstimator_8ih_source.html#l00230">230</a> of file <a class="el" href="DigitalSurfaceEmbedderWithNormalVectorEstimator_8ih_source.html">DigitalSurfaceEmbedderWithNormalVectorEstimator.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a87b130f95ae2c59b8ce9a2d9b3eb00eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Flower2D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Flower2D.html" title="Aim: Model of the concept StarShaped represents any flower with k-petals in the plane.">Flower2D</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Flower2D.html" title="Aim: Model of the concept StarShaped represents any flower with k-petals in the plane.">Flower2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Flower2D_8ih_source.html#l00212">212</a> of file <a class="el" href="Flower2D_8ih_source.html">Flower2D.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9d6116d3f522841ef300a0a3d0a22dd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AccFlower2D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1AccFlower2D.html" title="Aim: Model of the concept StarShaped represents any accelerated flower in the plane.">AccFlower2D</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1AccFlower2D.html" title="Aim: Model of the concept StarShaped represents any accelerated flower in the plane.">AccFlower2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="AccFlower2D_8ih_source.html#l00238">238</a> of file <a class="el" href="AccFlower2D_8ih_source.html">AccFlower2D.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1cfec935d23b12fc18c32eece2a8ab1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PValue , int PDefaultPreset, int PDefaultFirstColor, int PDefaultLastColor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GradientColorMap&lt; PValue, PDefaultPreset, PDefaultFirstColor, PDefaultLastColor &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1GradientColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into a colo...">GradientColorMap</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1GradientColorMap.html" title="Aim: This class template may be used to (linearly) convert scalar values in a given range into a colo...">GradientColorMap</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="GradientColorMap_8ih_source.html#l00294">294</a> of file <a class="el" href="GradientColorMap_8ih_source.html">GradientColorMap.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5f14f15bee0a8b951c870363e278a94e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFraction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Pattern&lt; TFraction &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Pattern.html" title="Aim: This class represents a pattern, i.e. the path between two consecutive upper leaning points on a...">Pattern</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Pattern.html" title="Aim: This class represents a pattern, i.e. the path between two consecutive upper leaning points on a...">Pattern</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Pattern_8ih_source.html#l00501">501</a> of file <a class="el" href="Pattern_8ih_source.html">Pattern.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0da05652e14a44efd06ab37c830fb00c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StarShaped2D&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1StarShaped2D.html">StarShaped2D</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1StarShaped2D.html">StarShaped2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="StarShaped2D_8ih_source.html#l00243">243</a> of file <a class="el" href="StarShaped2D_8ih_source.html">StarShaped2D.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aebacbf3c61709a7e0d1fc250f1f0204f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace , typename TEuclideanShape &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1GaussDigitizer.html">GaussDigitizer</a>&lt; TSpace, TEuclideanShape &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1GaussDigitizer.html" title="Aim: A class for computing the Gauss digitization of some Euclidean shape, i.e. its intersection with...">GaussDigitizer</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1GaussDigitizer.html" title="Aim: A class for computing the Gauss digitization of some Euclidean shape, i.e. its intersection with...">GaussDigitizer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="GaussDigitizer_8ih_source.html#l00243">243</a> of file <a class="el" href="GaussDigitizer_8ih_source.html">GaussDigitizer.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aaabd5b098d8beabcd7e4bc7d4316586a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TInteger , int connectivity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1ArithmeticalDSS3d.html">ArithmeticalDSS3d</a>&lt; TIterator, TInteger, connectivity &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ArithmeticalDSS3d.html" title="Aim: Dynamic recognition of a 3d-digital straight segment (DSS)">ArithmeticalDSS3d</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ArithmeticalDSS3d.html" title="Aim: Dynamic recognition of a 3d-digital straight segment (DSS)">ArithmeticalDSS3d</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ArithmeticalDSS3d_8h_source.html#l00281">281</a> of file <a class="el" href="ArithmeticalDSS3d_8h_source.html">ArithmeticalDSS3d.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordtype">object</span>.selfDisplay( out);
    <span class="keywordflow">return</span> out;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="ac9e45359f1676fa161c263f50cbee30d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDomain , typename TAdjacency &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DomainAdjacency&lt; TDomain, TAdjacency &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DomainAdjacency.html" title="Aim: Given a domain and an adjacency, limits the given adjacency to the specified domain for all adja...">DomainAdjacency</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DomainAdjacency.html" title="Aim: Given a domain and an adjacency, limits the given adjacency to the specified domain for all adja...">DomainAdjacency</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DomainAdjacency_8ih_source.html#l00179">179</a> of file <a class="el" href="DomainAdjacency_8ih_source.html">DomainAdjacency.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3611cd19b341d3f70a23a0023e6aff2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Image&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Image_8ih_source.html#l00065">65</a> of file <a class="el" href="Image_8ih_source.html">Image.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8b6273f070d1edcf9c510601044863d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSurface , bool isUpward, bool isClosed&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point2ShapePredicate&lt; TSurface, isUpward, isClosed &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Point2ShapePredicate.html" title="Aim: Predicate returning &#39;true&#39; iff a given point is in the &#39;interior&#39; of a given shape...">Point2ShapePredicate</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Point2ShapePredicate.html" title="Aim: Predicate returning &#39;true&#39; iff a given point is in the &#39;interior&#39; of a given shape...">Point2ShapePredicate</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Point2ShapePredicate_8ih_source.html#l00111">111</a> of file <a class="el" href="Point2ShapePredicate_8ih_source.html">Point2ShapePredicate.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0c685b28cb1a025847d30274b28d0edd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeasureOfStraightLines &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1MeasureOfStraightLines.html" title="The aim of this class is to compute the measure in the Lebesgues sense of the set of straight lines a...">MeasureOfStraightLines</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1MeasureOfStraightLines.html" title="The aim of this class is to compute the measure in the Lebesgues sense of the set of straight lines a...">MeasureOfStraightLines</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="MeasureOfStraightLines_8ih_source.html#l00392">392</a> of file <a class="el" href="MeasureOfStraightLines_8ih_source.html">MeasureOfStraightLines.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2129e2cee3ca511648fd20bcf90635f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealNumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>thatStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Statistic&lt; RealNumberType &gt; &amp;&#160;</td>
          <td class="paramname"><em>that_object_to_display</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Statistic.html" title="Aim: This class processes a set of sample values for one variable and can then compute different stat...">Statistic</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thatStream</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">that_object_to_display</td><td>the object of class '<a class="el" href="classDGtal_1_1Statistic.html" title="Aim: This class processes a set of sample values for one variable and can then compute different stat...">Statistic</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Statistic_8ih_source.html#l00421">421</a> of file <a class="el" href="Statistic_8ih_source.html">Statistic.ih</a>.</p>

<p>References <a class="el" href="Statistic_8ih_source.html#l00384">DGtal::Statistic&lt; RealNumberType &gt;::selfDisplay()</a>.</p>
<div class="fragment"><pre class="fragment">{
  that_object_to_display.selfDisplay( thatStream );
  <span class="keywordflow">return</span> thatStream;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a432b6b35fc11ee6b9c11fb54d193b366"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDigitalSurfaceTracker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DigitalSurface2DSlice&lt; TDigitalSurfaceTracker &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalSurface2DSlice.html" title="Aim: Represents a 2-dimensional slice in a DigitalSurface. In a sense, it is a 4-connected contour...">DigitalSurface2DSlice</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalSurface2DSlice.html" title="Aim: Represents a 2-dimensional slice in a DigitalSurface. In a sense, it is a 4-connected contour...">DigitalSurface2DSlice</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DigitalSurface2DSlice_8ih_source.html#l00254">254</a> of file <a class="el" href="DigitalSurface2DSlice_8ih_source.html">DigitalSurface2DSlice.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="accdbde97ed9607a15ec962171d6d933e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TImplicitFunctionDiff1 , typename TEmbedder &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ImplicitFunctionDiff1LinearCellEmbedder&lt; TKSpace, TImplicitFunctionDiff1, TEmbedder &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImplicitFunctionDiff1LinearCellEmbedder.html" title="Aim: a cellular embedder for implicit functions, (default constructible, copy constructible, assignable). Model of CCellEmbedder and CWithGradientMap.">ImplicitFunctionDiff1LinearCellEmbedder</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImplicitFunctionDiff1LinearCellEmbedder.html" title="Aim: a cellular embedder for implicit functions, (default constructible, copy constructible, assignable). Model of CCellEmbedder and CWithGradientMap.">ImplicitFunctionDiff1LinearCellEmbedder</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ImplicitFunctionDiff1LinearCellEmbedder_8ih_source.html#l00235">235</a> of file <a class="el" href="ImplicitFunctionDiff1LinearCellEmbedder_8ih_source.html">ImplicitFunctionDiff1LinearCellEmbedder.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a581d2514f85e3cc8a8c5833991207fe4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDigitalSurfaceTracker &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UmbrellaComputer&lt; TDigitalSurfaceTracker &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1UmbrellaComputer.html" title="Aim: Useful for computing umbrellas on &#39;DigitalSurface&#39;s, ie set of n-1 cells around a n-3 cell...">UmbrellaComputer</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1UmbrellaComputer.html" title="Aim: Useful for computing umbrellas on &#39;DigitalSurface&#39;s, ie set of n-1 cells around a n-3 cell...">UmbrellaComputer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="UmbrellaComputer_8ih_source.html#l00359">359</a> of file <a class="el" href="UmbrellaComputer_8ih_source.html">UmbrellaComputer.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8600426252610144c749a003e93274f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TDigitalSet &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DigitalSetBoundary.html">DigitalSetBoundary</a>&lt; TKSpace, TDigitalSet &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalSetBoundary.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of a given...">DigitalSetBoundary</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalSetBoundary.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of a given...">DigitalSetBoundary</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing.</dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">TKSpace</td><td>a model of <a class="el" href="structDGtal_1_1CCellularGridSpaceND.html" title="Aim: This concept describes a cellular grid space in nD. In these spaces obtained by cartesian produc...">CCellularGridSpaceND</a>: the type chosen for the cellular grid space.</td></tr>
    <tr><td class="paramname">TDigitalSet</td><td>a model of <a class="el" href="structDGtal_1_1CDigitalSet.html" title="Aim: Represents a set of points within the given domain. This set of points is modifiable by the user...">CDigitalSet</a>: the type chosen for the set of digital points. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="DigitalSetBoundary_8ih_source.html#l00310">310</a> of file <a class="el" href="DigitalSetBoundary_8ih_source.html">DigitalSetBoundary.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad5f4caac3598001543faa58512905fa1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1experimental_1_1ImageContainerByITKImage.html">experimental::ImageContainerByITKImage</a>&lt; T, TV &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class 'ImageContainerByITKImage'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class 'ImageContainerByITKImage' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="aa92bbcb0c90cddb06c7f84134c1e4a5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Expander.html">Expander</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Expander.html" title="Aim: This class is useful to visit an object by adjacencies, layer by layer.">Expander</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Expander.html" title="Aim: This class is useful to visit an object by adjacencies, layer by layer.">Expander</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a25bbd127be81b65901f94e0247fbd4b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TSurfelSet &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SetOfSurfels.html">SetOfSurfels</a>&lt; TKSpace, TSurfelSet &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1SetOfSurfels.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">SetOfSurfels</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1SetOfSurfels.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">SetOfSurfels</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing.</dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">TKSpace</td><td>a model of <a class="el" href="structDGtal_1_1CCellularGridSpaceND.html" title="Aim: This concept describes a cellular grid space in nD. In these spaces obtained by cartesian produc...">CCellularGridSpaceND</a>: the type chosen for the cellular grid space.</td></tr>
    <tr><td class="paramname">TSurfelSet</td><td>a model of <a class="el" href="structDGtal_1_1CDigitalSet.html" title="Aim: Represents a set of points within the given domain. This set of points is modifiable by the user...">CDigitalSet</a>: the type chosen for the set of digital points. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SetOfSurfels_8ih_source.html#l00296">296</a> of file <a class="el" href="SetOfSurfels_8ih_source.html">SetOfSurfels.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac2a53895055b003622553da7cb636570"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Viewer3D.html">Viewer3D</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Viewer3D.html" title="Aim: Display 3D primitive (like PointVector, DigitalSetBySTLSet, Object ...). This class uses the lib...">Viewer3D</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Viewer3D.html" title="Aim: Display 3D primitive (like PointVector, DigitalSetBySTLSet, Object ...). This class uses the lib...">Viewer3D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Viewer3D_8ih_source.html#l00119">119</a> of file <a class="el" href="Viewer3D_8ih_source.html">Viewer3D.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">object</span>.selfDisplay ( out );
    <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa8c04085996bfcb483774f35e6a6ffda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TPointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ImplicitDigitalSurface.html">ImplicitDigitalSurface</a>&lt; TKSpace, TPointPredicate &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">ImplicitDigitalSurface</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">ImplicitDigitalSurface</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing.</dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">TKSpace</td><td>a model of <a class="el" href="structDGtal_1_1CCellularGridSpaceND.html" title="Aim: This concept describes a cellular grid space in nD. In these spaces obtained by cartesian produc...">CCellularGridSpaceND</a>: the type chosen for the cellular grid space.</td></tr>
    <tr><td class="paramname">TPointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CDigitalSet.html" title="Aim: Represents a set of points within the given domain. This set of points is modifiable by the user...">CDigitalSet</a>: the type chosen for the set of digital points. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ImplicitDigitalSurface_8ih_source.html#l00321">321</a> of file <a class="el" href="ImplicitDigitalSurface_8ih_source.html">ImplicitDigitalSurface.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a294f23451c7c99ae08e19bd5eea76469"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Domain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DigitalSetBySTLSet&lt; Domain &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html" title="Aim: A container class for storing sets of digital points within some given domain.">DigitalSetBySTLSet</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalSetBySTLSet.html" title="Aim: A container class for storing sets of digital points within some given domain.">DigitalSetBySTLSet</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DigitalSetBySTLSet_8ih_source.html#l00459">459</a> of file <a class="el" href="DigitalSetBySTLSet_8ih_source.html">DigitalSetBySTLSet.ih</a>.</p>

<p>References <a class="el" href="DigitalSetBySTLSet_8ih_source.html#l00417">DGtal::DigitalSetBySTLSet&lt; TDomain &gt;::selfDisplay()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac2a3ce65944bf6a16aeb2ebce2c9cd00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TSurfelPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html">ExplicitDigitalSurface</a>&lt; TKSpace, TSurfelPredicate &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">ExplicitDigitalSurface</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">ExplicitDigitalSurface</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing.</dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">TKSpace</td><td>a model of <a class="el" href="structDGtal_1_1CCellularGridSpaceND.html" title="Aim: This concept describes a cellular grid space in nD. In these spaces obtained by cartesian produc...">CCellularGridSpaceND</a>: the type chosen for the cellular grid space.</td></tr>
    <tr><td class="paramname">TSurfelPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CDigitalSet.html" title="Aim: Represents a set of points within the given domain. This set of points is modifiable by the user...">CDigitalSet</a>: the type chosen for the set of digital points. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ExplicitDigitalSurface_8ih_source.html#l00309">309</a> of file <a class="el" href="ExplicitDigitalSurface_8ih_source.html">ExplicitDigitalSurface.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a133f736b6505cf0359ccc7e8be803c46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Domain &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DigitalSetBySTLVector&lt; Domain &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalSetBySTLVector.html" title="Aim: Realizes the concept CDigitalSet by using the STL container std::vector.">DigitalSetBySTLVector</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalSetBySTLVector.html" title="Aim: Realizes the concept CDigitalSet by using the STL container std::vector.">DigitalSetBySTLVector</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DigitalSetBySTLVector_8ih_source.html#l00514">514</a> of file <a class="el" href="DigitalSetBySTLVector_8ih_source.html">DigitalSetBySTLVector.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="acbfc586cb4ecd8bb0b1a787a84cb82d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelNeighborhood.html">SurfelNeighborhood</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1SurfelNeighborhood.html" title="Aim: This helper class is useful to compute the neighboring surfels of a given surfel, especially over a digital surface or over an object boundary. Two signed surfels are incident if they share a common n-2 cell. This class uses a SurfelAdjacency so as to determine adjacent surfels (either looking for them from interior to exterior or inversely).">SurfelNeighborhood</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1SurfelNeighborhood.html" title="Aim: This helper class is useful to compute the neighboring surfels of a given surfel, especially over a digital surface or over an object boundary. Two signed surfels are incident if they share a common n-2 cell. This class uses a SurfelAdjacency so as to determine adjacent surfels (either looking for them from interior to exterior or inversely).">SurfelNeighborhood</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a62707785131f3a712ab96fdc6525f956"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TConstIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GeometricalDCA&lt; TConstIterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1GeometricalDCA.html" title="Aim: On-line recognition of a digital circular arcs (DCA) defined as a sequence of connected grid edg...">GeometricalDCA</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1GeometricalDCA.html" title="Aim: On-line recognition of a digital circular arcs (DCA) defined as a sequence of connected grid edg...">GeometricalDCA</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="GeometricalDCA_8ih_source.html#l00635">635</a> of file <a class="el" href="GeometricalDCA_8ih_source.html">GeometricalDCA.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6f97c9e9c01d4864725d8d606a5535a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TMapImage &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DigitalSetFromMap&lt; TMapImage &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalSetFromMap.html" title="Aim: An adapter for viewing an associative image container like ImageContainerBySTLMap as a simple di...">DigitalSetFromMap</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalSetFromMap.html" title="Aim: An adapter for viewing an associative image container like ImageContainerBySTLMap as a simple di...">DigitalSetFromMap</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DigitalSetFromMap_8ih_source.html#l00360">360</a> of file <a class="el" href="DigitalSetFromMap_8ih_source.html">DigitalSetFromMap.ih</a>.</p>

<p>References <a class="el" href="DigitalSetFromMap_8ih_source.html#l00330">DGtal::DigitalSetFromMap&lt; TMapImage &gt;::selfDisplay()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7bf8ccb5fec38dffae46efd2c0d5c2c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Signal&lt; TValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Signal.html" title="Aim: Represents a discrete signal, periodic or not. The signal can be passed by value since it is onl...">Signal</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Signal.html" title="Aim: Represents a discrete signal, periodic or not. The signal can be passed by value since it is onl...">Signal</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Signal_8ih_source.html#l00607">607</a> of file <a class="el" href="Signal_8ih_source.html">Signal.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a352f8e878ed0810de6b9166501d8f33a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TConstIteratorOnPoints , typename TValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BinomialConvolver&lt; TConstIteratorOnPoints, TValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1BinomialConvolver.html" title="Aim: This class represents a 2D contour convolved by some binomial. It computes first and second orde...">BinomialConvolver</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1BinomialConvolver.html" title="Aim: This class represents a 2D contour convolved by some binomial. It computes first and second orde...">BinomialConvolver</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="BinomialConvolver_8ih_source.html#l00335">335</a> of file <a class="el" href="BinomialConvolver_8ih_source.html">BinomialConvolver.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af36416f9fdefcffddd2b2953f551257b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TConstIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GeometricalDSS&lt; TConstIterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1GeometricalDSS.html" title="Aim: On-line recognition of a digital straight segment (DSS) defined as a sequence of connected grid ...">GeometricalDSS</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1GeometricalDSS.html" title="Aim: On-line recognition of a digital straight segment (DSS) defined as a sequence of connected grid ...">GeometricalDSS</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="GeometricalDSS_8ih_source.html#l00528">528</a> of file <a class="el" href="GeometricalDSS_8ih_source.html">GeometricalDSS.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0213a561c03e9d90b12581abcf2ea54d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OrderedAlphabet &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1OrderedAlphabet.html" title="Aim: Describes an alphabet over an interval of (ascii) letters, where the lexicographic order can be ...">OrderedAlphabet</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1OrderedAlphabet.html" title="Aim: Describes an alphabet over an interval of (ascii) letters, where the lexicographic order can be ...">OrderedAlphabet</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="OrderedAlphabet_8ih_source.html#l00148">148</a> of file <a class="el" href="OrderedAlphabet_8ih_source.html">OrderedAlphabet.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">object</span>.selfDisplay ( out );
    <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5694066261d35cce4631775ccc2596e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TPointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1LightImplicitDigitalSurface.html">LightImplicitDigitalSurface</a>&lt; TKSpace, TPointPredicate &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1LightImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">LightImplicitDigitalSurface</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1LightImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">LightImplicitDigitalSurface</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing.</dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">TKSpace</td><td>a model of <a class="el" href="structDGtal_1_1CCellularGridSpaceND.html" title="Aim: This concept describes a cellular grid space in nD. In these spaces obtained by cartesian produc...">CCellularGridSpaceND</a>: the type chosen for the cellular grid space.</td></tr>
    <tr><td class="paramname">TPointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CDigitalSet.html" title="Aim: Represents a set of points within the given domain. This set of points is modifiable by the user...">CDigitalSet</a>: the type chosen for the set of digital points. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="LightImplicitDigitalSurface_8ih_source.html#l00380">380</a> of file <a class="el" href="LightImplicitDigitalSurface_8ih_source.html">LightImplicitDigitalSurface.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a55f2044bafa880126f92373e30027115"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace , typename TSurfelPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1LightExplicitDigitalSurface.html">LightExplicitDigitalSurface</a>&lt; TKSpace, TSurfelPredicate &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1LightExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">LightExplicitDigitalSurface</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1LightExplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as connected surfels...">LightExplicitDigitalSurface</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing.</dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">TKSpace</td><td>a model of <a class="el" href="structDGtal_1_1CCellularGridSpaceND.html" title="Aim: This concept describes a cellular grid space in nD. In these spaces obtained by cartesian produc...">CCellularGridSpaceND</a>: the type chosen for the cellular grid space.</td></tr>
    <tr><td class="paramname">TSurfelPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CDigitalSet.html" title="Aim: Represents a set of points within the given domain. This set of points is modifiable by the user...">CDigitalSet</a>: the type chosen for the set of digital points. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="LightExplicitDigitalSurface_8ih_source.html#l00389">389</a> of file <a class="el" href="LightExplicitDigitalSurface_8ih_source.html">LightExplicitDigitalSurface.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa0e2794580b8d7d35c4b4761f264d08e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFraction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StandardDSLQ0&lt; TFraction &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1StandardDSLQ0.html" title="Aim: Represents a digital straight line with slope in the first quadrant (Q0: x &gt;= 0...">StandardDSLQ0</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1StandardDSLQ0.html" title="Aim: Represents a digital straight line with slope in the first quadrant (Q0: x &gt;= 0...">StandardDSLQ0</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="StandardDSLQ0_8ih_source.html#l00644">644</a> of file <a class="el" href="StandardDSLQ0_8ih_source.html">StandardDSLQ0.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6f39f856a5dc3683cd3fdb8e22afa143"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridCurve&lt; TKSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1GridCurve.html" title="Aim: describes an alternative sequence of signed 0-cell (pointels) and 1-cell (linels) in any dimensi...">GridCurve</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1GridCurve.html" title="Aim: describes an alternative sequence of signed 0-cell (pointels) and 1-cell (linels) in any dimensi...">GridCurve</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="GridCurve_8ih_source.html#l00320">320</a> of file <a class="el" href="GridCurve_8ih_source.html">GridCurve.ih</a>.</p>

<p>References <a class="el" href="GridCurve_8ih_source.html#l00260">DGtal::GridCurve&lt; TKSpace &gt;::selfDisplay()</a>.</p>
<div class="fragment"><pre class="fragment">{
  aObject.selfDisplay ( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af1add10c7a26535a4feb8d370bd6fb4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Shape &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Preimage2D&lt; Shape &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Preimage2D.html" title="Aim: Computes the preimage of the 2D Euclidean shapes crossing a sequence of n straigth segments in O...">Preimage2D</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Preimage2D.html" title="Aim: Computes the preimage of the 2D Euclidean shapes crossing a sequence of n straigth segments in O...">Preimage2D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Preimage2D_8ih_source.html#l00514">514</a> of file <a class="el" href="Preimage2D_8ih_source.html">Preimage2D.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6ba93e4cd388ebab2cb5ec533a303962"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TInteger , int connectivity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FP&lt; TIterator, TInteger, connectivity &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1FP.html" title="Aim: Computes the faithful polygon (FP) of a range of 4/8-connected 2D Points.">FP</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="FP_8ih_source.html#l00496">496</a> of file <a class="el" href="FP_8ih_source.html">FP.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a60cb8329ec7e317f1beb03c8b322cf13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TGraph , typename TMarkSet &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BreadthFirstVisitor&lt; TGraph, TMarkSet &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1BreadthFirstVisitor.html" title="Aim: This class is useful to perform a breadth-first exploration of a graph given a starting point or...">BreadthFirstVisitor</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1BreadthFirstVisitor.html" title="Aim: This class is useful to perform a breadth-first exploration of a graph given a starting point or...">BreadthFirstVisitor</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="BreadthFirstVisitor_8ih_source.html#l00250">250</a> of file <a class="el" href="BreadthFirstVisitor_8ih_source.html">BreadthFirstVisitor.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad3071ce24e8bfd8044515d2e8bf31b0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDigitalTopology , typename TDigitalSet &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Object.html">Object</a>&lt; TDigitalTopology, TDigitalSet &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Object.html" title="Aim: An object (or digital object) represents a set in some digital space associated with a digital t...">Object</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Object_8ih_source.html#l00819">819</a> of file <a class="el" href="Object_8ih_source.html">Object.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a52995248ae36d8cd61977cf8e37c63bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SegmentComputer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1GreedySegmentation.html">GreedySegmentation</a>&lt; SegmentComputer &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1GreedySegmentation.html" title="Aim: Computes the greedy segmentation of a range given by a pair of ConstIterators. The last element of a given segment is the first one one of the next segment.">GreedySegmentation</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1GreedySegmentation.html" title="Aim: Computes the greedy segmentation of a range given by a pair of ConstIterators. The last element of a given segment is the first one one of the next segment.">GreedySegmentation</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="ad3c376126e05e1f797bb688366dd30f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TSet , typename TPointPredicate , typename TPointFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1FMM.html">FMM</a>&lt; TImage, TSet, TPointPredicate, TPointFunctor &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1FMM.html" title="Aim: Fast Marching Method (FMM) for nd distance transforms.">FMM</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1FMM.html" title="Aim: Fast Marching Method (FMM) for nd distance transforms.">FMM</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="FMM_8ih_source.html#l00501">501</a> of file <a class="el" href="FMM_8ih_source.html">FMM.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a196a8c122d6e58d73ecd46c249b8b849"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInteger &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntegerComputer&lt; TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1IntegerComputer.html" title="Aim: This class gathers several types and methods to make computation with integers.">IntegerComputer</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1IntegerComputer.html" title="Aim: This class gathers several types and methods to make computation with integers.">IntegerComputer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="IntegerComputer_8ih_source.html#l00568">568</a> of file <a class="el" href="IntegerComputer_8ih_source.html">IntegerComputer.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a86a932423c11c531c9ecfe4631704aab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SegmentComputer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SaturatedSegmentation.html">SaturatedSegmentation</a>&lt; SegmentComputer &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1SaturatedSegmentation.html" title="Aim: Computes the saturated segmentation, that is the whole set of maximal segments within a range gi...">SaturatedSegmentation</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1SaturatedSegmentation.html" title="Aim: Computes the saturated segmentation, that is the whole set of maximal segments within a range gi...">SaturatedSegmentation</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="afec460eda081b4dc6922174819cae6cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Domain , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1ImageContainerBySTLVector.html">ImageContainerBySTLVector</a>&lt; Domain, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Image.html" title="Aim: implements association bewteen points lying in a digital domain and values.">Image</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ImageContainerBySTLVector_8h_source.html#l00536">536</a> of file <a class="el" href="ImageContainerBySTLVector_8h_source.html">ImageContainerBySTLVector.h</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">object</span>.selfDisplay ( out );
    <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5684b6b55398b599ed5aaa9a70f3a0cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AngleLinearMinimizer &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1AngleLinearMinimizer.html" title="Aim: Used to minimize the angle variation between different angles while taking into accounts min and...">AngleLinearMinimizer</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1AngleLinearMinimizer.html" title="Aim: Used to minimize the angle variation between different angles while taking into accounts min and...">AngleLinearMinimizer</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="AngleLinearMinimizer_8ih_source.html#l00213">213</a> of file <a class="el" href="AngleLinearMinimizer_8ih_source.html">AngleLinearMinimizer.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">object</span>.selfDisplay ( out );
    <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a65fe5e7517f127b50ab8d9daa779a55e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1HyperRectDomain.html">HyperRectDomain</a>&lt; TSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;.">HyperRectDomain</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;.">HyperRectDomain</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="HyperRectDomain_8ih_source.html#l00178">178</a> of file <a class="el" href="HyperRectDomain_8ih_source.html">HyperRectDomain.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay ( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1f3fe65ff2eec5a590b6a2c550725e7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDigitalSurfaceContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1DigitalSurface.html">DigitalSurface</a>&lt; TDigitalSurfaceContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1DigitalSurface.html" title="Aim: Represents a set of n-1-cells in a nD space, together with adjacency relation between these cell...">DigitalSurface</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="DigitalSurface_8ih_source.html#l00910">910</a> of file <a class="el" href="DigitalSurface_8ih_source.html">DigitalSurface.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab58d2ea12ddf3ceb1b0d9fef20ae6875"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Display3D.html">Display3D</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like PointVector...">Display3D</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Display3D.html" title="Aim: This semi abstract class defines the stream mechanism to display 3d primitive (like PointVector...">Display3D</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Display3D_8ih_source.html#l00675">675</a> of file <a class="el" href="Display3D_8ih_source.html">Display3D.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay ( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1b2bc070ca54bd515c2948faae24b179"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a>&lt; TKSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1Surfaces.html" title="Aim: A utility class for constructing surfaces (i.e. set of (n-1)-cells).">Surfaces</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1Surfaces.html" title="Aim: A utility class for constructing surfaces (i.e. set of (n-1)-cells).">Surfaces</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00901">901</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a36a2459f7913ffe2255193bdfc4536d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TInteger , int connectivity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1ArithmeticalDSS.html">ArithmeticalDSS</a>&lt; TIterator, TInteger, connectivity &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: Dynamic recognition of a digital straight segment (DSS) defined as the sequence of simply connec...">ArithmeticalDSS</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ArithmeticalDSS.html" title="Aim: Dynamic recognition of a digital straight segment (DSS) defined as the sequence of simply connec...">ArithmeticalDSS</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ArithmeticalDSS_8h_source.html#l00773">773</a> of file <a class="el" href="ArithmeticalDSS_8h_source.html">ArithmeticalDSS.h</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out);
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a484bbc565292ed3fd276d70c3e71afac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim, typename Component &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1PointVector.html">PointVector</a>&lt; dim, Component &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Operator &lt;&lt;. </p>

</div>
</div>
<a class="anchor" id="adcd8d9d47caf12b58c0270ee77c7ec5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TDomain , typename TValue , typename THashKey &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1ImageContainerByHashTree.html">ImageContainerByHashTree</a>&lt; TDomain, TValue, THashKey &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1ImageContainerByHashTree.html" title="Model of CImageContainer implementing the association key&lt;-&gt;Value using a hash tree. This class provides a built-in iterator.">ImageContainerByHashTree</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1ImageContainerByHashTree.html" title="Model of CImageContainer implementing the association key&lt;-&gt;Value using a hash tree. This class provides a built-in iterator.">ImageContainerByHashTree</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="ImageContainerByHashTree_8h_source.html#l00798">798</a> of file <a class="el" href="ImageContainerByHashTree_8h_source.html">ImageContainerByHashTree.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordtype">object</span>.selfDisplay( out);
    <span class="keywordflow">return</span> out;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="ab3a7c82e86886176e1633ffa720003cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1CombinatorialDSS.html">CombinatorialDSS</a>&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1CombinatorialDSS.html" title="Aim:">CombinatorialDSS</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1CombinatorialDSS.html" title="Aim:">CombinatorialDSS</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

</div>
</div>
<a class="anchor" id="a85c3c4d290e6b5c6de7e46b431d4c4fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInteger &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FreemanChain&lt; TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>aObject</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1FreemanChain.html">FreemanChain</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1FreemanChain.html">FreemanChain</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="FreemanChain_8ih_source.html#l01338">1338</a> of file <a class="el" href="FreemanChain_8ih_source.html">FreemanChain.ih</a>.</p>

<p>References <a class="el" href="FreemanChain_8ih_source.html#l00613">DGtal::FreemanChain&lt; TInteger &gt;::selfDisplay()</a>.</p>
<div class="fragment"><pre class="fragment">{
  aObject.selfDisplay ( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac9d84c5b0391cb2973795d314b7a26ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim, typename TInteger &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1KhalimskySpaceND.html">KhalimskySpaceND</a>&lt; dim, TInteger &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex...">KhalimskySpaceND</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex...">KhalimskySpaceND</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="KhalimskySpaceND_8ih_source.html#l01707">1707</a> of file <a class="el" href="KhalimskySpaceND_8ih_source.html">KhalimskySpaceND.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aade413b000d41b595aa32414aaa564a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename TRing , class TAlloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; DGtal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPolynomial&lt; N, TRing, TAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloads 'operator&lt;&lt;' for displaying objects of class '<a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial</a>'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
    <tr><td class="paramname">object</td><td>the object of class '<a class="el" href="classDGtal_1_1MPolynomial.html" title="Aim: Represents a multivariate polynomial, i.e. an element of , where K is some ring or field...">MPolynomial</a>' to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the output stream after the writing. </dd></dl>

<p>Definition at line <a class="el" href="MPolynomial_8ih_source.html#l00074">74</a> of file <a class="el" href="MPolynomial_8ih_source.html">MPolynomial.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">object</span>.selfDisplay( out );
  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a462eaaf587bc04ebd2e6141bed3fc21e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a462eaaf587bc04ebd2e6141bed3fc21e">DGtal::oppositeEndMaximalExtension</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specialization for Iterator type </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00197">197</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00438">firstMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00686">lastMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00566">mostCenteredMaximalSegment()</a>, <a class="el" href="SegmentComputerUtils_8h_source.html#l00222">oppositeEndMaximalExtension()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00883">previousMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">                                                                                              {
  <span class="comment">//extend one more time if s.begin() == begin</span>
  <span class="keywordflow">while</span> ( (s.begin() != begin)
       &amp;&amp; (s.extendBackward()) ) {}
  <span class="keywordflow">if</span> (s.begin() == begin) s.extendBackward();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9f50b26bc3256332ab287e1bb2a3e7cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a462eaaf587bc04ebd2e6141bed3fc21e">DGtal::oppositeEndMaximalExtension</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CirculatorType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specialization for <a class="el" href="classDGtal_1_1Circulator.html" title="Aim: Provides an adapter for STL iterators that can iterate through the underlying data structure as ...">Circulator</a> type </p>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00208">208</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                                                                {
  <span class="comment">//stop if the segment is the whole range</span>
  <span class="keyword">const</span> <span class="keyword">typename</span> SC::ConstIterator newBegin( s.end() ); 
  <span class="keywordflow">while</span> ( (s.extendBackward())
       &amp;&amp; (s.begin() != newBegin) ) {}
}
</pre></div>
</div>
</div>
<a class="anchor" id="a567c997ae858c829256cc8a13c04d230"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a462eaaf587bc04ebd2e6141bed3fc21e">DGtal::oppositeEndMaximalExtension</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calls s.extendBackward() while possible </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of (bidirectional) segment computer </td></tr>
    <tr><td class="paramname">begin</td><td>any ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a bidirectional segment computer, ie. a model of CSegment that ca...">CBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00222">222</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00197">oppositeEndMaximalExtension()</a>.</p>
<div class="fragment"><pre class="fragment">                                                                               {
  <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorCirculatorTraits&lt;typename SC::ConstIterator&gt;::Type Type; 
  <a class="code" href="namespaceDGtal.html#a462eaaf587bc04ebd2e6141bed3fc21e">oppositeEndMaximalExtension</a>( s, begin, Type() ); 
}
</pre></div>
</div>
</div>
<a class="anchor" id="a137f26d321873e90065142afff6fa928"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a137f26d321873e90065142afff6fa928">DGtal::oppositeEndMaximalRetraction</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calls s.retractBackward() while s.isExtendableBackward() returns false </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>any instance of segment computer </td></tr>
    <tr><td class="paramname">begin</td><td>any ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00334">334</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>Referenced by <a class="el" href="SegmentComputerUtils_8h_source.html#l00883">previousMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> ( isNotEmpty&lt;typename SC::ConstIterator&gt;(s.begin(),begin) ) {
    <span class="keywordflow">while</span> ( (! s.isExtendableBackward() ) 
          &amp;&amp;(s.retractBackward() ) ) {}  
  } <span class="keywordflow">else</span> {
    <span class="keywordflow">while</span> ( s.retractBackward() ) {} 
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="adabb9ea04f81cba914f3ac178439ffd4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#adabb9ea04f81cba914f3ac178439ffd4">DGtal::previousMaximalSegment</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the previous maximal segment of s (s is assumed to be maximal) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">begin,any</td><td>begin ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CForwardSegmentComputer.html" title="Aim: Defines the concept describing a forward segment computer, ie. a model of CSegment that can exte...">CForwardSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>lastMaximalSegment of --s.begin() </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00852">852</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00652">lastMaximalSegment()</a>.</p>

<p>Referenced by <a class="el" href="SaturatedSegmentation_8ih_source.html#l00122">DGtal::SaturatedSegmentation&lt; TSegmentComputer &gt;::SegmentComputerIterator::initLastMaximalSegment()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00917">previousMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> ( isNotEmpty&lt;typename SC::ConstIterator&gt;(s.begin(),begin) )
    <a class="code" href="namespaceDGtal.html#a19f04b5f095862ee00e620f8246df2f8">lastMaximalSegment</a>(s, --s.begin(), begin, s.end(), <a class="code" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::ForwardSegmentComputer</a>() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8e35d35160afaea835678e7bf4a3458c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#adabb9ea04f81cba914f3ac178439ffd4">DGtal::previousMaximalSegment</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the previous maximal segment of s (s is assumed to be maximal) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">begin,any</td><td>begin ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a bidirectional segment computer, ie. a model of CSegment that ca...">CBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>lastMaximalSegment of --s.begin() </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00868">868</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00652">lastMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> ( isNotEmpty&lt;typename SC::ConstIterator&gt;(s.begin(),begin) )
    <a class="code" href="namespaceDGtal.html#a19f04b5f095862ee00e620f8246df2f8">lastMaximalSegment</a>(s, --s.begin(), begin, s.end(), <a class="code" href="structDGtal_1_1BidirectionalSegmentComputer.html">DGtal::BidirectionalSegmentComputer</a>() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="afa1f75e59b72ea5e69760c965e20b3ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#adabb9ea04f81cba914f3ac178439ffd4">DGtal::previousMaximalSegment</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the previous maximal segment of s (s is assumed to be maximal) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">begin,any</td><td>begin ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicSegmentComputer.html" title="Aim: Defines the concept describing a dynamic segment computer, ie. a model of CSegment that can exte...">CDynamicSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00883">883</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00197">oppositeEndMaximalExtension()</a>, and <a class="el" href="SegmentComputerUtils_8h_source.html#l00334">oppositeEndMaximalRetraction()</a>.</p>
<div class="fragment"><pre class="fragment">{

  <span class="keyword">typedef</span> <span class="keyword">typename</span> SC::ConstIterator ConstIterator; 

  <span class="comment">//rectract</span>
  <a class="code" href="namespaceDGtal.html#a137f26d321873e90065142afff6fa928">oppositeEndMaximalRetraction</a>(s, begin); 

  <span class="comment">//intersection test</span>
  ConstIterator i( s.end() ); --i; 
  <span class="comment">//if the intersection between the two </span>
  <span class="comment">// consecutive maximal segments is empty </span>
  <span class="keywordflow">if</span> ( i == s.begin() ) {
    <span class="keywordflow">if</span> ( isNotEmpty&lt;ConstIterator&gt;(i, begin) ) {
      --i; 
      s.init(i);  
    }
  }

  <span class="comment">//extend</span>
  <a class="code" href="namespaceDGtal.html#a462eaaf587bc04ebd2e6141bed3fc21e">oppositeEndMaximalExtension</a>(s, begin);

}
</pre></div>
</div>
</div>
<a class="anchor" id="ad14e74091568436294698404dc08c9c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#adabb9ea04f81cba914f3ac178439ffd4">DGtal::previousMaximalSegment</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDGtal_1_1DynamicBidirectionalSegmentComputer.html">DGtal::DynamicBidirectionalSegmentComputer</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the previous maximal segment of s (s is assumed to be maximal) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">end,end</td><td>ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of <a class="el" href="structDGtal_1_1CDynamicBidirectionalSegmentComputer.html" title="Aim: Defines the concept describing a dynamic and bidirectional segment computer, ie...">CDynamicBidirectionalSegmentComputer</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note:</dt><dd>calls the function dedicated to <a class="el" href="structDGtal_1_1DynamicSegmentComputer.html">DynamicSegmentComputer</a> </dd></dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00917">917</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00852">previousMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{ 
  <a class="code" href="namespaceDGtal.html#adabb9ea04f81cba914f3ac178439ffd4">previousMaximalSegment</a>(s, end, <a class="code" href="structDGtal_1_1DynamicSegmentComputer.html">DGtal::DynamicSegmentComputer</a>() ); 
}
</pre></div>
</div>
</div>
<a class="anchor" id="af03fbf680fc202a21ef0801ee9240934"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#adabb9ea04f81cba914f3ac178439ffd4">DGtal::previousMaximalSegment</a> </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename SC::ConstIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the previous maximal segment of s (s is assumed to be maximal) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">begin,any</td><td>begin ConstIterator </td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SC</td><td>any model of segment computer </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="SegmentComputerUtils_8h_source.html#l00931">931</a> of file <a class="el" href="SegmentComputerUtils_8h_source.html">SegmentComputerUtils.h</a>.</p>

<p>References <a class="el" href="SegmentComputerUtils_8h_source.html#l00852">previousMaximalSegment()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="namespaceDGtal.html#adabb9ea04f81cba914f3ac178439ffd4">previousMaximalSegment</a>(s, begin, 
<span class="keyword">typename</span> <a class="code" href="structDGtal_1_1ForwardSegmentComputer.html">DGtal::SegmentComputerTraits&lt;SC&gt;::Category</a>() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a44d1dd3f9097cf9d2b7f280c95e34b1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim, typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::bitset&lt; dim &gt; <a class="el" href="namespaceDGtal.html#a44d1dd3f9097cf9d2b7f280c95e34b1e">DGtal::setDimensionsIn</a> </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>dimensions</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a bitset having true for each dimension presents in dimensions. </dd></dl>

<p>Definition at line <a class="el" href="PointVector_8ih_source.html#l00042">42</a> of file <a class="el" href="PointVector_8ih_source.html">PointVector.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  std::bitset&lt;dim&gt; t1; 
  <span class="keywordflow">for</span> ( <span class="keyword">typename</span> Container::const_iterator it=dimensions.begin(); 
  it!=dimensions.end(); ++it )
    {
      ASSERT( *it&lt;dim );
      t1.set(*it);
    }
  <span class="keywordflow">return</span> t1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae405036e4e10cc9ecee7918e5fb10dd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Dimension dim, typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::bitset&lt; dim &gt; <a class="el" href="namespaceDGtal.html#ae405036e4e10cc9ecee7918e5fb10dd9">DGtal::setDimensionsNotIn</a> </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>dimensions</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="section return"><dt>Returns:</dt><dd>a bitset having true for each dimension not presents in dimensions. </dd></dl>

<p>Definition at line <a class="el" href="PointVector_8ih_source.html#l00056">56</a> of file <a class="el" href="PointVector_8ih_source.html">PointVector.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  std::bitset&lt;dim&gt; t1; t1.set();
  <span class="keywordflow">for</span> ( <span class="keyword">typename</span> Container::const_iterator it=dimensions.begin(); 
  it!=dimensions.end(); ++it )
    {
      ASSERT( *it&lt;dim );
      t1.reset(*it);
    }
  <span class="keywordflow">return</span> t1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a202be24e94b5bdfba2d8563d0947f373"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a202be24e94b5bdfba2d8563d0947f373">DGtal::setFromImage</a> </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>aImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const O &amp;&#160;</td>
          <td class="paramname"><em>ito</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename I::Value &amp;&#160;</td>
          <td class="paramname"><em>aThreshold</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill a set through the inserter <em>ito</em> with the points lying within the domain of the image <em>aImg</em> whose value (in the image) is less than or equal to <em>aThreshold</em> </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aImg</td><td>any image </td></tr>
    <tr><td class="paramname">ito</td><td>set inserter </td></tr>
    <tr><td class="paramname">aThreshold</td><td>any value (default: 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">I</td><td>any model of <a class="el" href="structDGtal_1_1CConstImage.html">CConstImage</a> </td></tr>
    <tr><td class="paramname">O</td><td>any model of output iterator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ImageHelper_8ih_source.html#l00071">71</a> of file <a class="el" href="ImageHelper_8ih_source.html">ImageHelper.ih</a>.</p>

<p>References <a class="el" href="ImageHelper_8ih_source.html#l00054">setFromPointsRangeAndFunctor()</a>.</p>
<div class="fragment"><pre class="fragment">{
  BOOST_CONCEPT_ASSERT(( CConstImage&lt;I&gt; )); 

  <span class="keyword">typename</span> I::Domain d = aImg.domain(); 
  <a class="code" href="namespaceDGtal.html#ad57d4465e40fe4c1982ec2e01985be73">setFromPointsRangeAndFunctor</a>(d.begin(), d.end(), ito, aImg, aThreshold); 
}
</pre></div>
</div>
</div>
<a class="anchor" id="aecddf53312d4b765f34a022b049627c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#a202be24e94b5bdfba2d8563d0947f373">DGtal::setFromImage</a> </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>aImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const O &amp;&#160;</td>
          <td class="paramname"><em>ito</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename I::Value &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename I::Value &amp;&#160;</td>
          <td class="paramname"><em>up</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill a set through the inserter <em>ito</em> with the points lying within the domain of the image <em>aImg</em> whose value (in the image) lies between <em>low</em> and <em>up</em> (both included)</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aImg</td><td>any image </td></tr>
    <tr><td class="paramname">ito</td><td>set inserter </td></tr>
    <tr><td class="paramname">low</td><td>lower value </td></tr>
    <tr><td class="paramname">up</td><td>upper value</td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">I</td><td>any model of <a class="el" href="structDGtal_1_1CConstImage.html">CConstImage</a> </td></tr>
    <tr><td class="paramname">O</td><td>any model of output iterator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ImageHelper_8ih_source.html#l00083">83</a> of file <a class="el" href="ImageHelper_8ih_source.html">ImageHelper.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  BOOST_CONCEPT_ASSERT(( CConstImage&lt;I&gt; )); 
  ASSERT( low &lt; up ); 

  <span class="comment">//domain</span>
  <span class="keyword">typename</span> I::Domain d = aImg.domain(); 
  <span class="comment">//predicate from two thresholders and an image</span>
  <span class="keyword">typedef</span> <a class="code" href="classThresholder.html" title="Aim: A small functor with an operator () that compares one value to a threshold value according to tw...">Thresholder&lt;typename I::Value,true,false&gt;</a> T1; 
  T1 t1( low ); 
  <span class="keyword">typedef</span> <a class="code" href="classThresholder.html" title="Aim: A small functor with an operator () that compares one value to a threshold value according to tw...">Thresholder&lt;typename I::Value,false,false&gt;</a> T2; 
  T2 t2( up ); 
  <span class="keyword">typedef</span> <a class="code" href="structPredicateCombiner.html" title="Aim: The predicate returns true when the given binary functor returns true for the two Predicates giv...">PredicateCombiner&lt;T1,T2,OrBoolFct2 &gt;</a> P; 
  P p( t1, t2, OrBoolFct2() ); 
  <a class="code" href="classComposer.html" title="Aim: Define a new Functor from the composition of two other functors.">Composer&lt;I, P, bool&gt;</a> aPred(aImg, p); 
  <span class="comment">//call</span>
  std::remove_copy_if(d.begin(), d.end(), ito, aPred); 
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad57d4465e40fe4c1982ec2e01985be73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#ad57d4465e40fe4c1982ec2e01985be73">DGtal::setFromPointsRangeAndFunctor</a> </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const O &amp;&#160;</td>
          <td class="paramname"><em>ito</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>aFunctor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename F::Value &amp;&#160;</td>
          <td class="paramname"><em>aThreshold</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill a set through the inserter <em>ito</em> with the points of the range [<em>itb</em> , <em>ite</em> ) such that their associated value (returned by <em>aFunctor</em> ) is less than or equal to <em>aThreshold</em> </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator on points </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator on points </td></tr>
    <tr><td class="paramname">ito</td><td>output iterator on points </td></tr>
    <tr><td class="paramname">aFunctor</td><td>any functor on points </td></tr>
    <tr><td class="paramname">aThreshold</td><td>any value (default: 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">I</td><td>any model of input iterator </td></tr>
    <tr><td class="paramname">O</td><td>any model of output iterator </td></tr>
    <tr><td class="paramname">F</td><td>any model of <a class="el" href="structDGtal_1_1CPointFunctor.html" title="Aim: Defines a functor on points.">CPointFunctor</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ImageHelper_8ih_source.html#l00054">54</a> of file <a class="el" href="ImageHelper_8ih_source.html">ImageHelper.ih</a>.</p>

<p>Referenced by <a class="el" href="ImageHelper_8ih_source.html#l00071">setFromImage()</a>.</p>
<div class="fragment"><pre class="fragment">{
  BOOST_CONCEPT_ASSERT(( CPointFunctor&lt;F&gt; )); 
  BOOST_CONCEPT_ASSERT(( boost::InputIterator&lt;I&gt; ));
  BOOST_CONCEPT_ASSERT(( boost::OutputIterator&lt;O,typename F::Point&gt; ));

  <span class="keyword">typedef</span> <a class="code" href="classThresholder.html" title="Aim: A small functor with an operator () that compares one value to a threshold value according to tw...">Thresholder&lt;typename F::Value,false,false&gt;</a> T; 
  T t( aThreshold ); 
  <a class="code" href="classComposer.html" title="Aim: Define a new Functor from the composition of two other functors.">Composer&lt;F, T, bool&gt;</a> aPred(aFunctor, t); 
  std::remove_copy_if(itb, ite, ito, aPred); 
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad67647d42db11b7b3d3533e1cba6c2ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename O , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceDGtal.html#ad67647d42db11b7b3d3533e1cba6c2ba">DGtal::setFromPointsRangeAndPredicate</a> </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>itb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>ite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const O &amp;&#160;</td>
          <td class="paramname"><em>ito</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>aPred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>useful functions </p>
<p>Fill a set through the inserter <em>ito</em> with the points of the range [<em>itb</em> , <em>ite</em> ) such that <em>aPred</em> is true</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">itb</td><td>begin iterator on points </td></tr>
    <tr><td class="paramname">ite</td><td>end iterator on points </td></tr>
    <tr><td class="paramname">ito</td><td>output iterator on points </td></tr>
    <tr><td class="paramname">aPred</td><td>any predicate</td></tr>
  </table>
  </dd>
</dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">I</td><td>any model of input iterator </td></tr>
    <tr><td class="paramname">O</td><td>any model of output iterator </td></tr>
    <tr><td class="paramname">P</td><td>any model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ImageHelper_8ih_source.html#l00040">40</a> of file <a class="el" href="ImageHelper_8ih_source.html">ImageHelper.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  BOOST_CONCEPT_ASSERT(( CPointPredicate&lt;P&gt; )); 
  BOOST_CONCEPT_ASSERT(( boost::InputIterator&lt;I&gt; ));
  BOOST_CONCEPT_ASSERT(( boost::OutputIterator&lt;O,typename P::Point&gt; ));

  NotPointPredicate&lt;P&gt; nPred( aPred ); 
  std::remove_copy_if(itb, ite, ito, nPred); 
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9d0c060685d6e9a49445a562a99c5286"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KSpace , typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceDGtal.html#a9d0c060685d6e9a49445a562a99c5286">DGtal::testImplicitDigitalSurface</a> </td>
          <td>(</td>
          <td class="paramtype">const KSpace &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename KSpace::Surfel &amp;&#160;</td>
          <td class="paramname"><em>bel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="testImplicitDigitalSurface-benchmark_8cpp_source.html#l00049">49</a> of file <a class="el" href="testImplicitDigitalSurface-benchmark_8cpp_source.html">testImplicitDigitalSurface-benchmark.cpp</a>.</p>

<p>References <a class="el" href="Trace_8ih_source.html#l00120">DGtal::Trace::beginBlock()</a>, <a class="el" href="Trace_8ih_source.html#l00145">DGtal::Trace::endBlock()</a>, <a class="el" href="Trace_8ih_source.html#l00213">DGtal::Trace::info()</a>, and <a class="el" href="Common_8h_source.html#l00140">trace</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keyword">typedef</span> <span class="keyword">typename</span> KSpace::Point <a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Point</a>;
    <span class="keyword">typedef</span> <span class="keyword">typename</span> KSpace::Surfel Surfel;
    <span class="keyword">typedef</span> <a class="code" href="classDGtal_1_1ImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">ImplicitDigitalSurface&lt;KSpace,PointPredicate&gt;</a> Boundary;
    <span class="keyword">typedef</span> <span class="keyword">typename</span> Boundary::SurfelConstIterator ConstIterator;
    <span class="keyword">typedef</span> <span class="keyword">typename</span> Boundary::Tracker Tracker;
    
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbok = 0;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb = 0;
    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a> ( <span class="stringliteral">&quot;Testing block ... ImplicitDigitalSurface&quot;</span> );
    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a> ( <span class="stringliteral">&quot;ImplicitDigitalSurface instanciation&quot;</span> );
    Boundary boundary( K, pp,
                       <a class="code" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency&lt;KSpace::dimension&gt;</a>( <span class="keyword">true</span> ), bel,
                       <span class="keyword">true</span> );
    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a6c28382776be9139655b4851fabe4dda">endBlock</a>();
    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a> ( <span class="stringliteral">&quot;Counting the number of surfels (breadth first traversal)&quot;</span> );
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbsurfels = 0;
    <span class="keywordflow">for</span> ( ConstIterator it = boundary.begin(), it_end = boundary.end();
          it != it_end; ++it )
      {
        ++nbsurfels;
      }
    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a33ae7cd58d47594cee54640946c6b859">info</a>() &lt;&lt; nbsurfels &lt;&lt; <span class="stringliteral">&quot; surfels found.&quot;</span> &lt;&lt; std::endl;
    nb++, nbok += nbsurfels == 354382 ? 1 : 0;
    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a33ae7cd58d47594cee54640946c6b859">info</a>() &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; nbok &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; nb &lt;&lt; <span class="stringliteral">&quot;) &quot;</span>
                   &lt;&lt; <span class="stringliteral">&quot;nbsurfels == 354382&quot;</span> &lt;&lt; std::endl;
    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a6c28382776be9139655b4851fabe4dda">endBlock</a>();
    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a6c28382776be9139655b4851fabe4dda">endBlock</a>();
    <span class="keywordflow">return</span> nbok == nb;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a08886ee117009e48c66e4349c7c47265"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KSpace , typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceDGtal.html#a08886ee117009e48c66e4349c7c47265">DGtal::testLightImplicitDigitalSurface</a> </td>
          <td>(</td>
          <td class="paramtype">const KSpace &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename KSpace::Surfel &amp;&#160;</td>
          <td class="paramname"><em>bel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="testLightImplicitDigitalSurface-benchmark_8cpp_source.html#l00049">49</a> of file <a class="el" href="testLightImplicitDigitalSurface-benchmark_8cpp_source.html">testLightImplicitDigitalSurface-benchmark.cpp</a>.</p>

<p>References <a class="el" href="Trace_8ih_source.html#l00120">DGtal::Trace::beginBlock()</a>, <a class="el" href="Trace_8ih_source.html#l00145">DGtal::Trace::endBlock()</a>, <a class="el" href="Trace_8ih_source.html#l00213">DGtal::Trace::info()</a>, and <a class="el" href="Common_8h_source.html#l00140">trace</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keyword">typedef</span> <span class="keyword">typename</span> KSpace::Point <a class="code" href="namespaceDGtal_1_1Z2i.html#ac0a04516c81db6f4a583eddda0f64875">Point</a>;
    <span class="keyword">typedef</span> <span class="keyword">typename</span> KSpace::Surfel Surfel;
    <span class="keyword">typedef</span> <a class="code" href="classDGtal_1_1LightImplicitDigitalSurface.html" title="Aim: A model of CDigitalSurfaceContainer which defines the digital surface as the boundary of an impl...">LightImplicitDigitalSurface&lt;KSpace,PointPredicate&gt;</a> Boundary;
    <span class="keyword">typedef</span> <span class="keyword">typename</span> Boundary::SurfelConstIterator ConstIterator;
    <span class="keyword">typedef</span> <span class="keyword">typename</span> Boundary::Tracker Tracker;
    
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbok = 0;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb = 0;
    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a> ( <span class="stringliteral">&quot;Testing block ... LightImplicitDigitalSurface&quot;</span> );
    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a> ( <span class="stringliteral">&quot;LightImplicitDigitalSurface instanciation&quot;</span> );
    Boundary boundary( K, pp,
                       <a class="code" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency&lt;KSpace::dimension&gt;</a>( <span class="keyword">true</span> ), bel );
    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a6c28382776be9139655b4851fabe4dda">endBlock</a>();
    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a352b7160bf722e2f0bcbee5d0bad6ef3">beginBlock</a> ( <span class="stringliteral">&quot;Counting the number of surfels (breadth first traversal)&quot;</span> );
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbsurfels = 0;
    <span class="keywordflow">for</span> ( ConstIterator it = boundary.begin(), it_end = boundary.end();
          it != it_end; ++it )
      {
        ++nbsurfels;
      }
    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a33ae7cd58d47594cee54640946c6b859">info</a>() &lt;&lt; nbsurfels &lt;&lt; <span class="stringliteral">&quot; surfels found.&quot;</span> &lt;&lt; std::endl;
    nb++, nbok += nbsurfels == 354382 ? 1 : 0;
    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a33ae7cd58d47594cee54640946c6b859">info</a>() &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; nbok &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; nb &lt;&lt; <span class="stringliteral">&quot;) &quot;</span>
                   &lt;&lt; <span class="stringliteral">&quot;nbsurfels == 354382&quot;</span> &lt;&lt; std::endl;
    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a6c28382776be9139655b4851fabe4dda">endBlock</a>();
    <a class="code" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">trace</a>.<a class="code" href="classDGtal_1_1Trace.html#a6c28382776be9139655b4851fabe4dda">endBlock</a>();
    <span class="keywordflow">return</span> nbok == nb;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a948cc02e8fe7e8ab1051bce164421fa8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, typename Ring , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;n, Ring, Alloc&gt; <a class="el" href="namespaceDGtal.html#a948cc02e8fe7e8ab1051bce164421fa8">DGtal::Xe_k</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a monomial X_k^e </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the index of the variable (X_k) </td></tr>
    <tr><td class="paramname">e</td><td>the exponent for X_k </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the 1-variable polynomial X_0^e </dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">n</td><td>the number of indetermionates. </td></tr>
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
    <tr><td class="paramname">Alloc</td><td>the type of allocator. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l01652">1652</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordflow">return</span> <a class="code" href="classDGtal_1_1Xe__kComputer.html">Xe_kComputer&lt;n, Ring, Alloc&gt;</a>().<span class="keyword">get</span>( k, e );
  }
</pre></div>
</div>
</div>
<a class="anchor" id="ad099005ab7d493b2ea19026e2fb96a32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, typename Ring &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1MPolynomial.html">MPolynomial</a>&lt;n, Ring, std::allocator&lt;Ring&gt; &gt; <a class="el" href="namespaceDGtal.html#a948cc02e8fe7e8ab1051bce164421fa8">DGtal::Xe_k</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a monomial X_k^e </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the index of the variable (X_k) </td></tr>
    <tr><td class="paramname">e</td><td>the exponent for X_k </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the 1-variable polynomial X_0^e </dd></dl>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">n</td><td>the number of indetermionates. </td></tr>
    <tr><td class="paramname">Ring</td><td>the type for the coefficent ring of the polynomial. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="MPolynomial_8h_source.html#l01668">1668</a> of file <a class="el" href="MPolynomial_8h_source.html">MPolynomial.h</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordflow">return</span> <a class="code" href="classDGtal_1_1Xe__kComputer.html">Xe_kComputer&lt;n, Ring, std::allocator&lt;Ring&gt;</a> &gt;().<span class="keyword">get</span>( k, e );
  }
</pre></div>
</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a70c28100eb4618dbb59a4080cbdf383b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">BoolFunction2</a> <a class="el" href="namespaceDGtal.html#a70c28100eb4618dbb59a4080cbdf383b">DGtal::andBF2</a> = <a class="el" href="structDGtal_1_1AndBoolFct2.html">AndBoolFct2</a>()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The object function and (2 bool args). </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00149">149</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

<p>Referenced by <a class="el" href="Expander_8ih_source.html#l00175">DGtal::Expander&lt; TObject &gt;::computeNextLayer()</a>.</p>

</div>
</div>
<a class="anchor" id="a3c1454fe50af31341c890919f93b76b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">It also possible to remove the visualisation of the transparent clipping plane by adding boolean <a class="el" href="namespaceDGtal.html#a3c1454fe50af31341c890919f93b76b6">DGtal::false</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="3dvisu_8dox_source.html#l00353">353</a> of file <a class="el" href="3dvisu_8dox_source.html">3dvisu.dox</a>.</p>

<p>Referenced by <a class="el" href="Board2D_8cpp_source.html#l00055">DGtal::Board2D::Board2D()</a>, <a class="el" href="DigitalSurface_8ih_source.html#l00446">DGtal::DigitalSurface&lt; TDigitalSurfaceContainer &gt;::computeFace()</a>, <a class="el" href="Expander_8ih_source.html#l00060">DGtal::Expander&lt; TObject &gt;::Expander()</a>, <a class="el" href="GeometricalDCA_8ih_source.html#l00043">DGtal::GeometricalDCA&lt; TConstIterator &gt;::GeometricalDCA()</a>, <a class="el" href="GeometricalDSS_8ih_source.html#l00043">DGtal::GeometricalDSS&lt; TConstIterator &gt;::GeometricalDSS()</a>, <a class="el" href="MostCenteredMaximalSegmentEstimator_8ih_source.html#l00054">DGtal::MostCenteredMaximalSegmentEstimator&lt; SegmentComputer, Functor &gt;::MostCenteredMaximalSegmentEstimator()</a>, <a class="el" href="GreedyDecomposition_8ih_source.html#l00055">DGtal::deprecated::GreedyDecomposition&lt; TSegment &gt;::SegmentIterator::SegmentIterator()</a>, <a class="el" href="Statistic_8ih_source.html#l00052">DGtal::Statistic&lt; RealNumberType &gt;::Statistic()</a>, and <a class="el" href="Surfaces_8ih_source.html#l00796">DGtal::Surfaces&lt; TKSpace &gt;::sWriteBoundary()</a>.</p>

</div>
</div>
<a class="anchor" id="a8c0dbf38da6779899ca99fc25ec8b0be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal.html#a40f198468aea6d0121b11cd49e599e92">BoolFunction0</a> <a class="el" href="namespaceDGtal.html#a8c0dbf38da6779899ca99fc25ec8b0be">DGtal::falseBF0</a> = <a class="el" href="structDGtal_1_1FalseBoolFct0.html">FalseBoolFct0</a>()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The object function (0 bool args) returning false. </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00092">92</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a154eac21029f20806b646b025b6d59a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal.html#a9a92f37472d9010932be3fe6d28f94cb">BoolFunction1</a> <a class="el" href="namespaceDGtal.html#a154eac21029f20806b646b025b6d59a0">DGtal::identityBF1</a> = <a class="el" href="structDGtal_1_1IdentityBoolFct1.html">IdentityBoolFct1</a>()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The object function identity (1 bool args). </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00111">111</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="af22fdd40c268d4270906236e3ce234cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">BoolFunction2</a> <a class="el" href="namespaceDGtal.html#af22fdd40c268d4270906236e3ce234cb">DGtal::impliesBF2</a> = <a class="el" href="structDGtal_1_1ImpliesBoolFct2.html">ImpliesBoolFct2</a>()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The object function implies (2 bool args). </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00164">164</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a31614f15cda0ab53c57cf414e48c149f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal.html#a9a92f37472d9010932be3fe6d28f94cb">BoolFunction1</a> <a class="el" href="namespaceDGtal.html#a31614f15cda0ab53c57cf414e48c149f">DGtal::notBF1</a> = <a class="el" href="structDGtal_1_1NotBoolFct1.html">NotBoolFct1</a>()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The object function NOT (1 bool args). </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00116">116</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7df3f0545c8e59b83394c60601c122e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">It also possible to remove the visualisation of the transparent clipping plane by adding boolean <a class="el" href="namespaceDGtal.html#a7df3f0545c8e59b83394c60601c122e3">DGtal::option</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="3dvisu_8dox_source.html#l00353">353</a> of file <a class="el" href="3dvisu_8dox_source.html">3dvisu.dox</a>.</p>

</div>
</div>
<a class="anchor" id="a14f119bf8a5eb80a58870ebbd33bfb07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">BoolFunction2</a> <a class="el" href="namespaceDGtal.html#a14f119bf8a5eb80a58870ebbd33bfb07">DGtal::orBF2</a> = <a class="el" href="structDGtal_1_1OrBoolFct2.html">OrBoolFct2</a>()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The object function or (2 bool args). </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00154">154</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a604c07ec391ad12a1f3fb6479993f112"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Trace.html">Trace</a> <a class="el" href="namespaceDGtal.html#a604c07ec391ad12a1f3fb6479993f112">DGtal::trace</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Common_8h_source.html#l00140">140</a> of file <a class="el" href="Common_8h_source.html">Common.h</a>.</p>

<p>Referenced by <a class="el" href="ImageContainerByHashTree_8ih_source.html#l00836">DGtal::ImageContainerByHashTree&lt; TDomain, TValue, THashKey &gt;::checkIntegrity()</a>, <a class="el" href="DistanceTransformation_8ih_source.html#l00066">DGtal::DistanceTransformation&lt; Image, p, IntegerLong &gt;::checkTypesValidity()</a>, <a class="el" href="DistanceTransformation_8ih_source.html#l00093">DGtal::DistanceTransformation&lt; Image, p, IntegerLong &gt;::compute()</a>, <a class="el" href="DistanceTransformation_8ih_source.html#l00161">DGtal::DistanceTransformation&lt; Image, p, IntegerLong &gt;::computeFirstStep()</a>, <a class="el" href="DistanceTransformation_8ih_source.html#l00194">DGtal::DistanceTransformation&lt; Image, p, IntegerLong &gt;::computeOtherSteps()</a>, <a class="el" href="ReverseDistanceTransformation_8ih_source.html#l00190">DGtal::ReverseDistanceTransformation&lt; Image, p, IntegerShort &gt;::computeSteps()</a>, <a class="el" href="ImageContainerByHashTree_8ih_source.html#l00757">DGtal::ImageContainerByHashTree&lt; TDomain, TValue, THashKey &gt;::getAverageCollisions()</a>, <a class="el" href="ImageContainerByHashTree_8ih_source.html#l00063">DGtal::ImageContainerByHashTree&lt; TDomain, TValue, THashKey &gt;::ImageContainerByHashTree()</a>, <a class="el" href="LongvolReader_8ih_source.html#l00040">DGtal::LongvolReader&lt; TImageContainer &gt;::importLongvol()</a>, <a class="el" href="PNMReader_8ih_source.html#l00052">DGtal::PNMReader&lt; TImageContainer &gt;::importPGM()</a>, <a class="el" href="PNMReader_8ih_source.html#l00171">DGtal::PNMReader&lt; TImageContainer &gt;::importPGM3D()</a>, <a class="el" href="RawReader_8ih_source.html#l00040">DGtal::RawReader&lt; TImageContainer &gt;::importRaw8()</a>, <a class="el" href="VolReader_8ih_source.html#l00044">DGtal::VolReader&lt; TImageContainer &gt;::importVol()</a>, <a class="el" href="Viewer3D_8cpp_source.html#l00543">DGtal::Viewer3D::keyPressEvent()</a>, <a class="el" href="Board2D_8ih_source.html#l00067">DGtal::Board2D::operator&lt;&lt;()</a>, <a class="el" href="Viewer3D_8cpp_source.html#l00267">DGtal::Viewer3D::postSelection()</a>, <a class="el" href="Board3DTo2D_8cpp_source.html#l00232">DGtal::Board3DTo2D::saveCairo()</a>, <a class="el" href="Viewer3D_8cpp_source.html#l00248">DGtal::Viewer3D::sortSurfelFromCamera()</a>, <a class="el" href="testImplicitDigitalSurface-benchmark_8cpp_source.html#l00049">testImplicitDigitalSurface()</a>, and <a class="el" href="testLightImplicitDigitalSurface-benchmark_8cpp_source.html#l00049">testLightImplicitDigitalSurface()</a>.</p>

</div>
</div>
<a class="anchor" id="ae801de7ee4d22c47257dc7e00e0c5dd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1TraceWriterTerm.html">TraceWriterTerm</a> <a class="el" href="namespaceDGtal.html#ae801de7ee4d22c47257dc7e00e0c5dd7">DGtal::traceWriterTerm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="namespaceDGtal.html" title="Aim: Defines the concept describing a bidirectional const range.">DGtal</a> Global variables </p>

<p>Definition at line <a class="el" href="Common_8h_source.html#l00139">139</a> of file <a class="el" href="Common_8h_source.html">Common.h</a>.</p>

</div>
</div>
<a class="anchor" id="aad0fa31bef8d6552db900af1809d787d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal.html#a40f198468aea6d0121b11cd49e599e92">BoolFunction0</a> <a class="el" href="namespaceDGtal.html#aad0fa31bef8d6552db900af1809d787d">DGtal::trueBF0</a> = <a class="el" href="structDGtal_1_1TrueBoolFct0.html">TrueBoolFct0</a>()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The object function (0 bool args) returning true. </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00087">87</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a29281e7462720aa5d454fa2355baa0f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceDGtal.html#a7d57d4419aa9656ae4be838f903b5dd2">BoolFunction2</a> <a class="el" href="namespaceDGtal.html#a29281e7462720aa5d454fa2355baa0f3">DGtal::xorBF2</a> = <a class="el" href="structDGtal_1_1XorBoolFct2.html">XorBoolFct2</a>()<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The object function xor (2 bool args). </p>

<p>Definition at line <a class="el" href="BasicBoolFunctions_8h_source.html#l00159">159</a> of file <a class="el" href="BasicBoolFunctions_8h_source.html">BasicBoolFunctions.h</a>.</p>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu May 10 2012 16:09:56 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
