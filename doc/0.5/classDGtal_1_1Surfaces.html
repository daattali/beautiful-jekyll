<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>DGtal: DGtal::Surfaces&lt; TKSpace &gt; Class Template Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">DGtal
   &#160;<span id="projectnumber">0.5.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceDGtal.html">DGtal</a>      </li>
      <li class="navelem"><a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">DGtal::Surfaces&lt; TKSpace &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>&gt;</code></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae254510c81f339dbb5bd4b33ed9f5f3e"><td class="memItemLeft" align="right" valign="top">typedef TKSpace&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a></td></tr>
<tr class="memitem:a91dd49aa1b8c90ceaf595448ce30ebb3"><td class="memItemLeft" align="right" valign="top">typedef KSpace::Integer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a91dd49aa1b8c90ceaf595448ce30ebb3">Integer</a></td></tr>
<tr class="memitem:ab58accd9ff51d3cb85f7f4d7e7ed80c5"><td class="memItemLeft" align="right" valign="top">typedef KSpace::Point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a></td></tr>
<tr class="memitem:a6e02ccfe37b82b2d278d066161f4d1d2"><td class="memItemLeft" align="right" valign="top">typedef KSpace::Cell&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a></td></tr>
<tr class="memitem:a5eaebd043923d70cecb81470431be557"><td class="memItemLeft" align="right" valign="top">typedef KSpace::SCell&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a></td></tr>
<tr class="memitem:aea3655c1310aed70fc5fcedaef454d21"><td class="memItemLeft" align="right" valign="top">typedef KSpace::DirIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#aea3655c1310aed70fc5fcedaef454d21">DirIterator</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4a40685150ee27be46185eed33b49582"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a4a40685150ee27be46185eed33b49582">~Surfaces</a> ()</td></tr>
<tr class="memitem:a80771c760a6b1ae094343a2e8011dad3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a80771c760a6b1ae094343a2e8011dad3">selfDisplay</a> (std::ostream &amp;out) const </td></tr>
<tr class="memitem:a93d3b1bb0ae25b25a2f02b32096c8ea4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a93d3b1bb0ae25b25a2f02b32096c8ea4">isValid</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab7cb9762acdb10a8e91ac27f936c7ff9"><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr class="memitem:ab7cb9762acdb10a8e91ac27f936c7ff9"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#ab7cb9762acdb10a8e91ac27f936c7ff9">findABel</a> (const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const PointPredicate &amp;pp, unsigned int nbtries=1000)  throw (DGtal::InputException)</td></tr>
<tr class="memitem:a8108a13a0e55b8b218a4b94ba6b9bebf"><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr class="memitem:a8108a13a0e55b8b218a4b94ba6b9bebf"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a8108a13a0e55b8b218a4b94ba6b9bebf">findABel</a> (const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const PointPredicate &amp;pp, <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> x1, <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> x2)</td></tr>
<tr class="memitem:a24fcfb2a607d919c84250bc9965cb86b"><td class="memTemplParams" colspan="2">template&lt;typename SCellSet , typename PointPredicate &gt; </td></tr>
<tr class="memitem:a24fcfb2a607d919c84250bc9965cb86b"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a24fcfb2a607d919c84250bc9965cb86b">trackBoundary</a> (SCellSet &amp;surface, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr class="memitem:a997c3b0bfec1b627a9822d4a1352f4ba"><td class="memTemplParams" colspan="2">template&lt;typename SCellSet , typename SurfelPredicate &gt; </td></tr>
<tr class="memitem:a997c3b0bfec1b627a9822d4a1352f4ba"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a997c3b0bfec1b627a9822d4a1352f4ba">trackSurface</a> (SCellSet &amp;surface, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const SurfelPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr class="memitem:a08c4dba52a1b96479aec48d646f4d469"><td class="memTemplParams" colspan="2">template&lt;typename SCellSet , typename SurfelPredicate &gt; </td></tr>
<tr class="memitem:a08c4dba52a1b96479aec48d646f4d469"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a08c4dba52a1b96479aec48d646f4d469">trackClosedSurface</a> (SCellSet &amp;surface, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const SurfelPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr class="memitem:a4b4a4cd531b56d91d0ec1931f81b3884"><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr class="memitem:a4b4a4cd531b56d91d0ec1931f81b3884"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a4b4a4cd531b56d91d0ec1931f81b3884">track2DBoundary</a> (std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;aSCellContour2D, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr class="memitem:a0026ca2b0589575ec156784b5db60abf"><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr class="memitem:a0026ca2b0589575ec156784b5db60abf"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a0026ca2b0589575ec156784b5db60abf">track2DBoundary</a> (std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;aSCellContour2D, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> &amp;trackDir, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr class="memitem:aeea1a2dc0f7d5c3c86028f2643290486"><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr class="memitem:aeea1a2dc0f7d5c3c86028f2643290486"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#aeea1a2dc0f7d5c3c86028f2643290486">track2DBoundaryPoints</a> (std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &gt; &amp;aVectorOfPoints, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr class="memitem:a6b5d23e7d194d2c22d97de7853723d20"><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr class="memitem:a6b5d23e7d194d2c22d97de7853723d20"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a6b5d23e7d194d2c22d97de7853723d20">extractAllPointContours4C</a> (std::vector&lt; std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &gt; &gt; &amp;aVectPointContour2D, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; 2 &gt; &amp;aSAdj)</td></tr>
<tr class="memitem:a5565d229014c6d68ad32d64ad69e6eaf"><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr class="memitem:a5565d229014c6d68ad32d64ad69e6eaf"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a5565d229014c6d68ad32d64ad69e6eaf">extractAll2DSCellContours</a> (std::vector&lt; std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &gt; &amp;aVectSCellContour2D, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;aSurfelAdj, const PointPredicate &amp;pp)</td></tr>
<tr class="memitem:a7c70171234046344fa0b089373424171"><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr class="memitem:a7c70171234046344fa0b089373424171"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a7c70171234046344fa0b089373424171">extractAllConnectedSCell</a> (std::vector&lt; std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &gt; &amp;aVectConnectedSCell, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;aSurfelAdj, const PointPredicate &amp;pp, bool forceOrientCellExterior=<a class="el" href="namespaceDGtal.html#a3c1454fe50af31341c890919f93b76b6">false</a>)</td></tr>
<tr class="memitem:a29fc6a36477080451c0951082ec7a456"><td class="memTemplParams" colspan="2">template&lt;typename PointPredicate &gt; </td></tr>
<tr class="memitem:a29fc6a36477080451c0951082ec7a456"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a29fc6a36477080451c0951082ec7a456">orientSCellExterior</a> (std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;aVectOfSCell, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const PointPredicate &amp;pp)</td></tr>
<tr class="memitem:ae917f93333eb382dd285d660388c9ba7"><td class="memTemplParams" colspan="2">template&lt;typename SCellSet , typename PointPredicate &gt; </td></tr>
<tr class="memitem:ae917f93333eb382dd285d660388c9ba7"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#ae917f93333eb382dd285d660388c9ba7">trackClosedBoundary</a> (SCellSet &amp;surface, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;K, const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;surfel_adj, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;start_surfel)</td></tr>
<tr class="memitem:a77140694e5697b73346f9e7e0e1a52fa"><td class="memTemplParams" colspan="2">template&lt;typename CellSet , typename PointPredicate &gt; </td></tr>
<tr class="memitem:a77140694e5697b73346f9e7e0e1a52fa"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a77140694e5697b73346f9e7e0e1a52fa">uMakeBoundary</a> (CellSet &amp;aBoundary, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;aLowerBound, const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;aUpperBound)</td></tr>
<tr class="memitem:ad00979785283bbf3ac3767016f9f759f"><td class="memTemplParams" colspan="2">template&lt;typename SCellSet , typename PointPredicate &gt; </td></tr>
<tr class="memitem:ad00979785283bbf3ac3767016f9f759f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#ad00979785283bbf3ac3767016f9f759f">sMakeBoundary</a> (SCellSet &amp;aBoundary, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;aLowerBound, const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;aUpperBound)</td></tr>
<tr class="memitem:a051a425aad5367ebf261d774e2d8244a"><td class="memTemplParams" colspan="2">template&lt;typename OutputIterator , typename PointPredicate &gt; </td></tr>
<tr class="memitem:a051a425aad5367ebf261d774e2d8244a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a051a425aad5367ebf261d774e2d8244a">uWriteBoundary</a> (OutputIterator &amp;out_it, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;aLowerBound, const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;aUpperBound)</td></tr>
<tr class="memitem:aec4221c2c86b9a35cda45fa6da5a2de9"><td class="memTemplParams" colspan="2">template&lt;typename OutputIterator , typename PointPredicate &gt; </td></tr>
<tr class="memitem:aec4221c2c86b9a35cda45fa6da5a2de9"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#aec4221c2c86b9a35cda45fa6da5a2de9">sWriteBoundary</a> (OutputIterator &amp;out_it, const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;aKSpace, const PointPredicate &amp;pp, const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;aLowerBound, const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;aUpperBound)</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af256c2b3c2af32a9b20e011748382e1b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#af256c2b3c2af32a9b20e011748382e1b">Surfaces</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a8cab7368470487cee8c10921739f5f23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a8cab7368470487cee8c10921739f5f23">Surfaces</a> (const <a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a> &amp;other)</td></tr>
<tr class="memitem:a31d72cf1ccdf33632636c890e5816d1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDGtal_1_1Surfaces.html#a31d72cf1ccdf33632636c890e5816d1d">operator=</a> (const <a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a> &amp;other)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TKSpace&gt;<br/>
class DGtal::Surfaces&lt; TKSpace &gt;</h3>

<p>Aim: A utility class for constructing surfaces (i.e. set of (n-1)-cells). </p>
<p>Description of template class '<a class="el" href="classDGtal_1_1Surfaces.html" title="Aim: A utility class for constructing surfaces (i.e. set of (n-1)-cells).">Surfaces</a>' </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">TKSpace</td><td>the type of cellular grid space (e.g. a <a class="el" href="classDGtal_1_1KhalimskySpaceND.html" title="Aim: This class is a model of CCellularGridSpaceND. It represents the cubical grid as a cell complex...">KhalimskySpaceND</a>).</td></tr>
  </table>
  </dd>
</dl>
<p>Note that many methods requires a surfel adjacency so as to know how connected surfels are linked (first by the interior or first by the exterior). Secondly, many methods are parameterized by a PointPredicate which describes the shape as a characteristic function. This is to be more generic than a simple DigitalSet. With this approach, shapes can be defined implicitly.</p>
<p>Essentially a backport from <a href="https://gforge.liris.cnrs.fr/projects/imagene">ImaGene</a>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="topology_23dKSSurfaceExtraction_8cpp-example.html#_a2">topology/3dKSSurfaceExtraction.cpp</a>, <a class="el" href="topology_2ctopo-2-3d_8cpp-example.html#_a14">topology/ctopo-2-3d.cpp</a>, <a class="el" href="topology_2ctopo-2_8cpp-example.html#_a11">topology/ctopo-2.cpp</a>, <a class="el" href="topology_2volScanBoundary_8cpp-example.html#_a9">topology/volScanBoundary.cpp</a>, <a class="el" href="topology_2volToOFF_8cpp-example.html#_a12">topology/volToOFF.cpp</a>, and <a class="el" href="topology_2volTrackBoundary_8cpp-example.html#_a10">topology/volTrackBoundary.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="Surfaces_8h_source.html#l00078">78</a> of file <a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>.</p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a6e02ccfe37b82b2d278d066161f4d1d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KSpace::Cell <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Surfaces_8h_source.html#l00085">85</a> of file <a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>.</p>

</div>
</div>
<a class="anchor" id="aea3655c1310aed70fc5fcedaef454d21"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KSpace::DirIterator <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#aea3655c1310aed70fc5fcedaef454d21">DirIterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Surfaces_8h_source.html#l00087">87</a> of file <a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>.</p>

</div>
</div>
<a class="anchor" id="a91dd49aa1b8c90ceaf595448ce30ebb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KSpace::Integer <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a91dd49aa1b8c90ceaf595448ce30ebb3">Integer</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Surfaces_8h_source.html#l00083">83</a> of file <a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae254510c81f339dbb5bd4b33ed9f5f3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TKSpace <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Surfaces_8h_source.html#l00082">82</a> of file <a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab58accd9ff51d3cb85f7f4d7e7ed80c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KSpace::Point <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Surfaces_8h_source.html#l00084">84</a> of file <a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5eaebd043923d70cecb81470431be557"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KSpace::SCell <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Surfaces_8h_source.html#l00086">86</a> of file <a class="el" href="Surfaces_8h_source.html">Surfaces.h</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4a40685150ee27be46185eed33b49582"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::~<a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor. </p>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00056">56</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
}
</pre></div>
</div>
</div>
<a class="anchor" id="af256c2b3c2af32a9b20e011748382e1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor. Forbidden by default (protected to avoid g++ warnings). </p>

</div>
</div>
<a class="anchor" id="a8cab7368470487cee8c10921739f5f23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a>&lt; TKSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy constructor. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the object to clone. Forbidden by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5565d229014c6d68ad32d64ad69e6eaf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a5565d229014c6d68ad32d64ad69e6eaf">extractAll2DSCellContours</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>aVectSCellContour2D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSurfelAdj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extract all contours as a vector containing the set of contours composed of SCell. Each contour is represented by a vector of signed surfels whose elements represents a boundary component of a digital shape defined by the predicate [pp]. The algorithms tracks surfels along the boundary of the shape.</p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aSCellContour2D</td><td>(modified) a vector of contour represented by a vector of cells (which are all surfels), containing the ordered list of the boundary component of [spelset].</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space.</td></tr>
    <tr><td class="paramname">aSurfelAdj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00520">520</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  std::set&lt;SCell&gt; bdry;
  <a class="code" href="classDGtal_1_1Surfaces.html#ad00979785283bbf3ac3767016f9f759f">sMakeBoundary</a>( bdry, aKSpace, pp, 
                 aKSpace.lowerBound(), aKSpace.upperBound() );
  aVectSCellContour2D.clear();
  <span class="keywordflow">while</span>( ! bdry.empty() )
    {
      std::vector&lt;SCell&gt; aContour;
      <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> aCell = *(bdry.begin()); 
      <a class="code" href="classDGtal_1_1Surfaces.html#a4b4a4cd531b56d91d0ec1931f81b3884">track2DBoundary</a>( aContour, aKSpace, aSurfelAdj, pp, aCell );
      aVectSCellContour2D.push_back( aContour );
      <span class="comment">// removing cells from boundary;</span>
      <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; aContour.size(); i++ )
        {
          <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> sc = aContour.at(i);
          bdry.erase(sc);
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7c70171234046344fa0b089373424171"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a7c70171234046344fa0b089373424171">extractAllConnectedSCell</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>aVectConnectedSCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSurfelAdj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceOrientCellExterior</em> = <code><a class="el" href="namespaceDGtal.html#a3c1454fe50af31341c890919f93b76b6">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extract all surfel elements associated to each connected components of the given DigitalSet. The connected surfel set are given as result in a vector containing all components. The orientation of the resulting SCell indicates the exterior orientation according the positive axis.</p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aVectConnectedSCell</td><td>(modified) a vector containing for each connected components a vector of the sequence of connected SCells.</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space.</td></tr>
    <tr><td class="paramname">aSurfelAdj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape.</td></tr>
    <tr><td class="paramname">forceOrientCellExterior</td><td>if 'true', used to change the default cell orientation in order to get the direction of shape exterior (default =false). This is used only for displaying cells with <a class="el" href="classDGtal_1_1Viewer3D.html" title="Aim: Display 3D primitive (like PointVector, DigitalSetBySTLSet, Object ...). This class uses the lib...">Viewer3D</a>. This mechanism should evolve shortly. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00572">572</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  set&lt;SCell&gt; bdry;

  <a class="code" href="classDGtal_1_1Surfaces.html#ad00979785283bbf3ac3767016f9f759f">sMakeBoundary</a>( bdry, aKSpace, pp,
                 aKSpace.lowerBound(), aKSpace.upperBound() );
  aVectConnectedSCell.clear();
  <span class="keywordflow">while</span>(!bdry.empty()){
    set&lt;SCell&gt;  aConnectedSCellSet;
    <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> aCell = *(bdry.begin()); 
    <a class="code" href="classDGtal_1_1Surfaces.html#a24fcfb2a607d919c84250bc9965cb86b">trackBoundary</a>(aConnectedSCellSet, aKSpace, aSurfelAdj, pp, aCell );
    <span class="comment">//transform into vector&lt;SCell&gt;</span>
    vector&lt;SCell&gt; vCS;
    <span class="keywordflow">for</span>(<span class="keyword">typename</span> set&lt;SCell&gt;::iterator it = aConnectedSCellSet.begin(); it!= aConnectedSCellSet.end(); ++it){
      vCS.push_back(*it); 
      <span class="comment">// removing cells from boundary;      </span>
      bdry.erase(*it);
    }
    <span class="keywordflow">if</span>(forceOrientCellExterior){
      <a class="code" href="classDGtal_1_1Surfaces.html#a29fc6a36477080451c0951082ec7a456">orientSCellExterior</a>(vCS, aKSpace, pp);
    }
    aVectConnectedSCell.push_back(vCS);
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6b5d23e7d194d2c22d97de7853723d20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a6b5d23e7d194d2c22d97de7853723d20">extractAllPointContours4C</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>aVectPointContour2D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSAdj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extract all 4-connected contours as a vector containing the sequence of contour Points. Each contour is represented by a vector of points defined by the sequence of pointels extracted from the boundary surfels. Calls extractAll2DSCellContours.</p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aVectPointContour2D</td><td>(modified) a vector of contour represented by a vector of cells (which are all surfels), containing the ordered list of the boundary component of [pp].</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape.</td></tr>
    <tr><td class="paramname">aSAdj</td><td>the surfel adjacency chosen for the tracking. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00609">609</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  aVectPointContour2D.clear();
  
  std::vector&lt; std::vector&lt;SCell&gt; &gt; vectContoursBdrySCell;
  <a class="code" href="classDGtal_1_1Surfaces.html#a5565d229014c6d68ad32d64ad69e6eaf">extractAll2DSCellContours</a>( vectContoursBdrySCell,
                             aKSpace, aSAdj, pp );
  
  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt; vectContoursBdrySCell.size(); i++){
    std::vector&lt; Point &gt; aContour;
    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt; vectContoursBdrySCell.at(i).size(); j++){
      <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> sc = vectContoursBdrySCell.at(i).at(j);
      <span class="keywordtype">float</span> x = (float) 
        ( <a class="code" href="structDGtal_1_1NumberTraits.html" title="Aim: The traits class for all models of Cinteger.">NumberTraits&lt;typename TKSpace::Integer&gt;::castToInt64_t</a>( sc.myCoordinates[0] ) &gt;&gt; 1 );
      <span class="keywordtype">float</span> y = (float) 
        ( <a class="code" href="structDGtal_1_1NumberTraits.html" title="Aim: The traits class for all models of Cinteger.">NumberTraits&lt;typename TKSpace::Integer&gt;::castToInt64_t</a>( sc.myCoordinates[1] ) &gt;&gt; 1 );
      <span class="keywordtype">bool</span> xodd = ( sc.myCoordinates[ 0 ] &amp; 1 );
      <span class="keywordtype">bool</span> yodd = ( sc.myCoordinates[ 1 ] &amp; 1 );
      <span class="keywordtype">double</span> x0 = !xodd ? x  - 0.5 : (!aKSpace.sSign(sc)? x  - 0.5: x  + 0.5) ;
      <span class="keywordtype">double</span> y0 = !yodd ? y  - 0.5 : (!aKSpace.sSign(sc)? y  - 0.5: y + 0.5);
      <span class="keywordtype">double</span> x1 = !xodd ? x  - 0.5 : (aKSpace.sSign(sc)? x  - 0.5: x  + 0.5) ;
      <span class="keywordtype">double</span> y1 = !yodd ? y  - 0.5 : (aKSpace.sSign(sc)? y  - 0.5: y  + 0.5);      
      
      <a class="code" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> ptA((<span class="keyword">const</span> <span class="keywordtype">int</span>)(x0+0.5), (<span class="keyword">const</span> <span class="keywordtype">int</span>)(y0-0.5));
      <a class="code" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> ptB((<span class="keyword">const</span> <span class="keywordtype">int</span>)(x1+0.5), (<span class="keyword">const</span> <span class="keywordtype">int</span>)(y1-0.5)) ;
      aContour.push_back(ptA);
      <span class="keywordflow">if</span>(sc== vectContoursBdrySCell.at(i).at(vectContoursBdrySCell.at(i).size()-1)){
        aContour.push_back(ptB);
      }
    }
    aVectPointContour2D.push_back(aContour);
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab7cb9762acdb10a8e91ac27f936c7ff9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#ab7cb9762acdb10a8e91ac27f936c7ff9">findABel</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nbtries</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throw (<a class="el" href="classDGtal_1_1InputException.html">DGtal::InputException</a>)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find a bel in some digital set by random tries then dichotomy.</p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">K</td><td>any cellular grid space.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape, which should be at least partially included in the bounds of space [K].</td></tr>
    <tr><td class="paramname">nbries</td><td>the maximum number of random tries (default 1000).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>a signed surfel separating a digital point in [dset] from a face adjacent digital point outside [dset] or throws an <a class="el" href="classDGtal_1_1InputException.html">InputException</a> if none was found after [nbtries] iterations. </dd></dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00065">65</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  BOOST_CONCEPT_ASSERT(( <a class="code" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate&lt;PointPredicate&gt;</a> ));

  <a class="code" href="classDGtal_1_1InputException.html">DGtal::InputException</a> dgtalerror;
  <a class="code" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> sizes = K.upperBound() - K.lowerBound();
  <a class="code" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> x1 = K.lowerBound();
  <a class="code" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> x2;
  <span class="comment">// (1) Find two candidates in the space.</span>
  <span class="keywordtype">bool</span> val_v1 = pp( x1 ); <span class="comment">// dset.find( x1 ) != dset.end();</span>
  <span class="keywordtype">bool</span> found = <span class="keyword">false</span>;
  <a class="code" href="classDGtal_1_1Surfaces.html#a91dd49aa1b8c90ceaf595448ce30ebb3">Integer</a> r;
  <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; nbtries; ++j )
    {
      <span class="keywordflow">for</span> ( <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> i = 0; i &lt; K.dimension; ++i )
  {
    r = rand();
    x2[ i ] = ( r % sizes[ i ] ) + K.min( i );
  }
      <span class="keywordtype">bool</span> val_v2 = pp( x2 ); <span class="comment">// dset.find( x2 ) != dset.end();</span>
      <span class="keywordflow">if</span> ( val_v2 != val_v1 )
        {
          found = <span class="keyword">true</span>;
          <span class="keywordflow">break</span>;
        }
    }
  <span class="keywordflow">if</span> ( ! found ) <span class="keywordflow">throw</span> dgtalerror;
  <span class="keywordflow">return</span> <a class="code" href="classDGtal_1_1Surfaces.html#ab7cb9762acdb10a8e91ac27f936c7ff9">findABel</a>( K, pp, x1, x2 );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8108a13a0e55b8b218a4b94ba6b9bebf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#ab7cb9762acdb10a8e91ac27f936c7ff9">findABel</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a>&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a>&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find a bel in some digital set given two hints (one point inside, one point outside).</p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">K</td><td>any cellular grid space.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape, which should be at least partially included in the bounds of space [K].</td></tr>
    <tr><td class="paramname">x1</td><td>a point within the bounds of K and such that pp( x1 ) != pp( x2 ).</td></tr>
    <tr><td class="paramname">x2</td><td>a point within the bounds of K and such that pp( x1 ) != pp( x2 ).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>a signed surfel separating a digital point in [dset] from a face adjacent digital point outside [dset] or throws an <a class="el" href="classDGtal_1_1InputException.html">InputException</a> if none was found after [nbtries] iterations. </dd></dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00102">102</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  BOOST_CONCEPT_ASSERT(( <a class="code" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate&lt;PointPredicate&gt;</a> ));
  <span class="comment">// (1) Checks the two candidates in the space.</span>
  <span class="keywordtype">bool</span> val_v1 = pp( x1 ); <span class="comment">// dset.find( x1 ) != dset.end();</span>
  ASSERT( val_v1 != pp( x2 ) );
  <span class="comment">// (2) Find two candidates on the same axis.</span>
  <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> d = 0;
  <span class="keywordtype">bool</span> alreadyOnSameAxis = <span class="keyword">true</span>;
  <span class="keywordflow">for</span> ( <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> i = 0; i &lt; K.dimension; ++i )
    {
      <span class="keywordflow">if</span> ( x1[ i ] != x2[ i ] )
        {
          <span class="keywordflow">for</span> ( <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> j = i + 1; j &lt; K.dimension; ++j )
            {
              <span class="keywordflow">if</span> ( x1[ j ] != x2[ j ] )
                {
                  alreadyOnSameAxis = <span class="keyword">false</span>;
                  <a class="code" href="classDGtal_1_1Surfaces.html#a91dd49aa1b8c90ceaf595448ce30ebb3">Integer</a> c = x2[ j ];
                  x2[ j ] = x1[ j ];
                  <span class="keywordtype">bool</span> val_v2 = pp( x2 ); <span class="comment">// dset.find( x2 ) != dset.end();</span>
                  <span class="keywordflow">if</span> ( val_v2 != val_v1 )
                    { <span class="comment">// v2 is updated.</span>
                      d = i;
                    }
                  <span class="keywordflow">else</span>
                    { <span class="comment">// v1 is updated.</span>
                      x1 = x2;
                      x2[ j ] = c;
                      d = j;
                    }
                } <span class="comment">// if ( x1[ j ] != x2[ j ] )</span>
            } <span class="comment">// for ( Dimension j = i + 1; j &lt; K.dimension; ++j )</span>
          <span class="keywordflow">if</span> ( alreadyOnSameAxis )
            d = i;
        } <span class="comment">// if ( x1[ i ] != x2[ i ] )</span>
    } <span class="comment">// for ( Dimension i = 0; i &lt; K.dimension; ++i )</span>

  <span class="comment">// (3) Check result.</span>
  <span class="keywordflow">for</span> ( <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> i = 0; i &lt; K.dimension; ++i )
    {
      <span class="keywordflow">if</span> ( ( i == d ) &amp;&amp; ( x1[ i ] == x2[ i ] ) )
        std::cerr &lt;&lt; <span class="stringliteral">&quot;[DGtal::Surfaces::findABel] Error 1a along &quot;</span> 
                  &lt;&lt; i &lt;&lt; std::endl;
      <span class="keywordflow">if</span> ( ( i != d ) &amp;&amp; ( x1[ i ] != x2[ i ] ) )
        std::cerr &lt;&lt; <span class="stringliteral">&quot;[DGtal::Surfaces::findABel] Error 1b along &quot;</span>
                  &lt;&lt; i &lt;&lt; std::endl;
    }
  
  <span class="comment">// (4) Dichotomy</span>
  <a class="code" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> xmid = x1;
  <span class="keywordflow">while</span> ( <span class="keyword">true</span> )
    {
      xmid[ d ] = ( x1[ d ] + x2[ d ] ) / 2;
      <span class="keywordflow">if</span> ( ( xmid[ d ] == x1[ d ] ) || ( xmid[ d ] == x2[ d ] ) )
        <span class="keywordflow">break</span>;
      <span class="keywordtype">bool</span> val_mid = pp( xmid ); <span class="comment">// dset.find( xmid ) != dset.end();</span>
      <span class="keywordflow">if</span> ( val_mid != val_v1 )
        x2[ d ] = xmid[ d ];
      <span class="keywordflow">else</span>
        x1[ d ] = xmid[ d ];
    }
  
  <span class="comment">// (5) Check result.</span>
  <span class="keywordflow">for</span> ( <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> i = 0; i &lt; K.dimension; ++i )
    {
      <span class="comment">// std::cerr &lt;&lt; &quot;i=&quot; &lt;&lt; i &lt;&lt; &quot; x1=&quot; &lt;&lt; x1[ i ] &lt;&lt; &quot; x2=&quot; &lt;&lt; x2[ i ]</span>
      <span class="comment">//     &lt;&lt; std::endl;</span>
      <span class="keywordflow">if</span> ( ( i == d ) &amp;&amp; ( x1[ i ] != x2[ i ] - 1 ) )
        std::cerr &lt;&lt; <span class="stringliteral">&quot;[DGtal::Surfaces::findABel] Error 2a along &quot;</span> 
                  &lt;&lt; i &lt;&lt; std::endl;
      <span class="keywordflow">if</span> ( ( i != d ) &amp;&amp; ( x1[ i ] != x2[ i ] ) )
        std::cerr &lt;&lt; <span class="stringliteral">&quot;[DGtal::Surfaces::findABel] Error 2a along &quot;</span>
                  &lt;&lt; i &lt;&lt; std::endl;
    }

  <span class="comment">// (6) Computes bel.</span>
  <span class="keywordflow">if</span> ( val_v1 )
    <span class="keywordflow">return</span> K.sIncident( K.sSpel( x1, K.POS ), d, true );
  <span class="keywordflow">else</span>
    <span class="keywordflow">return</span> K.sIncident( K.sSpel( x1, K.NEG ), d, true );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a93d3b1bb0ae25b25a2f02b32096c8ea4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a93d3b1bb0ae25b25a2f02b32096c8ea4">isValid</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks the validity/consistency of the object. </p>
<dl class="section return"><dt>Returns:</dt><dd>'true' if the object is valid, 'false' otherwise. </dd></dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00888">888</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a31d72cf1ccdf33632636c890e5816d1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a>&amp; <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html">Surfaces</a>&lt; TKSpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assignment. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the object to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>a reference on 'this'. Forbidden by default. </dd></dl>

</div>
</div>
<a class="anchor" id="a29fc6a36477080451c0951082ec7a456"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a29fc6a36477080451c0951082ec7a456">orientSCellExterior</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aVectOfSCell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Orient the SCell positively in the direction of the exterior of the DigitalSet aShape. It simply check if the direct incident Cell in the first upper dimension (obtain with sDirectIncident) belongs to the DigitalSet or not.</p>
<p>This method is used to change the default cell orientation in order to get the direction of shape exterior (default =false). This is used only for displaying cells with <a class="el" href="classDGtal_1_1Viewer3D.html" title="Aim: Display 3D primitive (like PointVector, DigitalSetBySTLSet, Object ...). This class uses the lib...">Viewer3D</a>. This mechanism should evolve shortly.</p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aVectOfSCell</td><td>(modified) a vector containing the SCell to be oriented positively in the direction of the exterior.</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00550">550</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><pre class="fragment">                                                                                                    {
  <span class="keywordflow">for</span>( <span class="keyword">typename</span> vector&lt;SCell&gt;::iterator it = aVectOfSCell.begin();
       it!=aVectOfSCell.end(); it++){
    <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> incidUpperDim = aKSpace.sDirectIncident(*it, aKSpace.sOrthDir(*it)); 
    <span class="keywordflow">if</span>( pp( aKSpace.sCoords(incidUpperDim) )){
      aKSpace.sSetSign (*it, !aKSpace.sDirect(*it, aKSpace.sOrthDir(*it)) ); 
    }<span class="keywordflow">else</span>{
      aKSpace.sSetSign (*it, aKSpace.sDirect(*it, !aKSpace.sOrthDir(*it)) ); 
    }  
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a80771c760a6b1ae094343a2e8011dad3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a80771c760a6b1ae094343a2e8011dad3">selfDisplay</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes/Displays the object on an output stream. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream where the object is written. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00876">876</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  out &lt;&lt; <span class="stringliteral">&quot;[Surfaces]&quot;</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad00979785283bbf3ac3767016f9f759f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename SCellSet , typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#ad00979785283bbf3ac3767016f9f759f">sMakeBoundary</a> </td>
          <td>(</td>
          <td class="paramtype">SCellSet &amp;&#160;</td>
          <td class="paramname"><em>aBoundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aLowerBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aUpperBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a set of signed surfels whose elements represents all the boundary components of a digital shape described by the predicate [pp].</p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SCellSet</td><td>a model of a set of SCell (e.g., std::set&lt;SCell&gt;). </td></tr>
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aBoundary</td><td>(modified) a set of cells (which are all surfels), the boundary component of [aSpelSet].</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space. </td></tr>
    <tr><td class="paramname">aSurfelAdj</td><td>the surfel adjacency chosen for the tracking. </td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape.</td></tr>
    <tr><td class="paramname">aLowerBound</td><td>and </td></tr>
    <tr><td class="paramname">aUpperBound</td><td>points giving the bounds of the extracted boundary. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00730">730</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k;
  <span class="keywordtype">bool</span> in_here, in_further;
 
  <span class="keywordflow">for</span> ( k = 0; k &lt; aKSpace.dimension; ++k )
    {
      <a class="code" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> dir_low_uid = aKSpace.uSpel( aLowerBound );
      <a class="code" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> dir_up_uid = aKSpace.uGetDecr( aKSpace.uSpel( aUpperBound ), k);
      <a class="code" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> p = dir_low_uid;
      <span class="keywordflow">do</span> 
        {
          in_here = pp( aKSpace.uCoords(p) );
          in_further = pp( aKSpace.uCoords(aKSpace.uGetIncr( p, k )) );
          <span class="keywordflow">if</span> ( in_here != in_further ) <span class="comment">// boundary element</span>
            { <span class="comment">// add it to the set.</span>
              aBoundary.insert( aKSpace.sIncident( aKSpace.signs( p, in_here ),
                                                   k, true ));
            }
        }
      <span class="keywordflow">while</span> ( aKSpace.uNext( p, dir_low_uid, dir_up_uid ) );
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aec4221c2c86b9a35cda45fa6da5a2de9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename OutputIterator , typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#aec4221c2c86b9a35cda45fa6da5a2de9">sWriteBoundary</a> </td>
          <td>(</td>
          <td class="paramtype">OutputIterator &amp;&#160;</td>
          <td class="paramname"><em>out_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aLowerBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aUpperBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes on the output iterator <em>out_it</em> the signed surfels whose elements represents all the boundary elements of a digital shape described by the predicate [pp].</p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">OutputIterator</td><td>any output iterator (like std::back_insert_iterator&lt; std::vector&lt;SCell&gt; &gt;).</td></tr>
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out_it</td><td>any output iterator for writing the signed cells.</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space.</td></tr>
    <tr><td class="paramname">aSurfelAdj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape.</td></tr>
    <tr><td class="paramname">aLowerBound</td><td>and </td></tr>
    <tr><td class="paramname">aUpperBound</td><td>points giving the bounds of the extracted boundary. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00796">796</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>

<p>References <a class="el" href="3dvisu_8dox_source.html#l00353">DGtal::false</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> k;
  <span class="comment">// bool in_here, in_further;</span>
  <span class="keywordtype">bool</span> in_here, in_before;
  
  <span class="keyword">typedef</span> <span class="keyword">typename</span> KSpace::Space <a class="code" href="namespaceDGtal_1_1Z2i.html#a9b96ab8175cf9c54b1f451858ccd46a4">Space</a>;
  <span class="keyword">typedef</span> <a class="code" href="classDGtal_1_1HyperRectDomain.html" title="Aim: Parallelepidec region of a digital space, model of a &#39;CDomain&#39;.">HyperRectDomain&lt;Space&gt;</a> <a class="code" href="namespaceDGtal_1_1Z2i.html#aca523bebdae58eb19385aaefffff8bc5">Domain</a>;
  std::vector&lt; Dimension &gt; axes( aKSpace.dimension ); 
  <span class="keywordflow">for</span> ( k = 0; k &lt; aKSpace.dimension; ++k )
    axes[ k ] = k;
  <span class="comment">// We look for surfels in every direction.</span>
  <span class="keywordflow">for</span> ( k = 0; k &lt; aKSpace.dimension; ++k )
    {
      <span class="comment">// When looking for surfels, the visiting must follow the k-th</span>
      <span class="comment">// axis first so as to reuse the predicate &quot;pp( p )&quot;.</span>
      std::swap( axes[ 0 ], axes[ k ] );
      <a class="code" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> low = aLowerBound; ++low[ k ];
      <a class="code" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> up = aUpperBound;
      Domain domain( low, up );
      <a class="code" href="classDGtal_1_1Surfaces.html#a91dd49aa1b8c90ceaf595448ce30ebb3">Integer</a> x = low[ k ];
      <span class="keyword">typename</span> Domain::ConstSubRange range = domain.subRange( axes );
      <span class="keywordflow">for</span> ( <span class="keyword">typename</span> Domain::ConstSubRange::ConstIterator
              it = range.begin(), it_end = range.end();
            it != it_end; ++it )
        {
          <span class="keyword">const</span> <a class="code" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp; p = *it;
          <span class="keywordflow">if</span> ( p[ k ] == x)
            {
              in_here = pp( p );
              <a class="code" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> p2( p ); --p2[ k ];
              in_before = pp( p2 );
            }
          <span class="keywordflow">else</span>
            { 
              in_before = in_here;
              in_here = pp( p );
            }
          <span class="keywordflow">if</span> ( in_here != in_before ) <span class="comment">// boundary element</span>
            { <span class="comment">// writes it into the output iterator.</span>
              *out_it++ = aKSpace.sIncident( aKSpace.sSpel( p, in_here ),
                                             k, <a class="code" href="namespaceDGtal.html#a3c1454fe50af31341c890919f93b76b6">false</a> );
            }
        }
    }
  <span class="comment">// for ( k = 0; k &lt; aKSpace.dimension; ++k )</span>
  <span class="comment">//   {</span>
  <span class="comment">//     Cell dir_low_uid = aKSpace.uSpel( aLowerBound );</span>
  <span class="comment">//     Cell dir_up_uid = aKSpace.uGetDecr( aKSpace.uSpel( aUpperBound ), k);</span>
  <span class="comment">//     Cell p = dir_low_uid;</span>
  <span class="comment">//     do </span>
  <span class="comment">//       {</span>
  <span class="comment">//         in_here = pp( aKSpace.uCoords(p) );</span>
  <span class="comment">//         in_further = pp( aKSpace.uCoords(aKSpace.uGetIncr( p, k )) );</span>
  <span class="comment">//         if ( in_here != in_further ) // boundary element</span>
  <span class="comment">//           { // writes it into the output iterator.</span>
  <span class="comment">//             *out_it++ = aKSpace.sIncident( aKSpace.signs( p, in_here ),</span>
  <span class="comment">//                                            k, true );</span>
  <span class="comment">//           }</span>
  <span class="comment">//       }</span>
  <span class="comment">//     while ( aKSpace.uNext( p, dir_low_uid, dir_up_uid ) );</span>
  <span class="comment">//   }</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4b4a4cd531b56d91d0ec1931f81b3884"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a4b4a4cd531b56d91d0ec1931f81b3884">track2DBoundary</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSCellContour2D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a vector of signed surfels whose elements represents a 2D boundary component of a digital shape described by a PointPredicate. The algorithm tracks surfels along the boundary of the shape by starting from the given [start_surfel]. It only tracks the boundary of a 2D shape.</p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aSCellContour2D</td><td>(modified) a vector of cells (which are all surfels), containing the ordered list of the boundary component of [spelset] which touches [start_surfel].</td></tr>
    <tr><td class="paramname">K</td><td>any space of dimension 2.</td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape, which should be at least partially included in the bounds of space [K].</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel which should be between an element of [shape] and an element not in [shape]. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00345">345</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>

<p>References <a class="el" href="SurfelNeighborhood_8ih_source.html#l00350">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::getAdjacentOnPointPredicate()</a>, <a class="el" href="SurfelNeighborhood_8ih_source.html#l00087">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::init()</a>, and <a class="el" href="SurfelNeighborhood_8ih_source.html#l00103">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::setSurfel()</a>.</p>
<div class="fragment"><pre class="fragment">{
  BOOST_CONCEPT_ASSERT(( <a class="code" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate&lt;PointPredicate&gt;</a> ));
  ASSERT( K.dimension == 2 );

  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> b= start_surfel;  <span class="comment">// current surfel</span>
  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> bn; <span class="comment">// neighboring surfel</span>
  ASSERT( K.sIsSurfel( start_surfel ) );
  <span class="comment">// std::set&lt;SCell&gt; setSurface;</span>
  <span class="comment">// setSurface.insert(start_surfel);</span>
  aSCellContour2D.clear(); <span class="comment">// boundary being extracted.</span>
  aSCellContour2D.push_back(start_surfel);
  <a class="code" href="classDGtal_1_1SurfelNeighborhood.html">SurfelNeighborhood&lt;KSpace&gt;</a> SN;
  SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a917b5b927f28381e1d0f62715c91f519">init</a>( &amp;K, &amp;surfel_adj, start_surfel );
  SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a9d5728fe1d5ada79f5249f0dd189d1e1">setSurfel</a>( b );
  <span class="comment">// search along indirect orientation.</span>
  <span class="keywordtype">bool</span> hasPrevNeighbor =  <span class="keyword">true</span>;
  <span class="keywordflow">while</span> ( hasPrevNeighbor )
    {
      hasPrevNeighbor=<span class="keyword">false</span>;
      <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track_dir = *(K.sDirs( b ));
      SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a9d5728fe1d5ada79f5249f0dd189d1e1">setSurfel</a>( b );
      <span class="keywordflow">if</span> ( SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a635ea93c00eede9eaf8d85e9fd035e2f">getAdjacentOnPointPredicate</a>( bn, pp, track_dir,  
                                           ! K.sDirect( b, track_dir ) ) )
        {
          <span class="keywordflow">if</span> ( bn != start_surfel )
            <span class="comment">// if ( setSurface.find( bn ) == setSurface.end() )</span>
            {
              hasPrevNeighbor=<span class="keyword">true</span>;
              aSCellContour2D.push_back( bn );
              <span class="comment">// setSurface.insert(bn);</span>
            }
        }
      b = bn;
    }
  <span class="comment">// since the contour is not necessary closed we search in the other direction.</span>
  reverse(aSCellContour2D.begin(), aSCellContour2D.end());
  <span class="keywordflow">if</span> ( b != start_surfel )
    { <span class="comment">// the contour is necessarily open.</span>
      b = start_surfel; 
      <span class="keywordtype">bool</span> hasNextNeighbor =  <span class="keyword">true</span>;
      <span class="keywordflow">while</span> ( hasNextNeighbor )
        {
          hasNextNeighbor=<span class="keyword">false</span>;
          <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track_dir = *(K.sDirs( b ));
          SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a9d5728fe1d5ada79f5249f0dd189d1e1">setSurfel</a>( b );
          <span class="keywordflow">if</span> ( SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a635ea93c00eede9eaf8d85e9fd035e2f">getAdjacentOnPointPredicate</a>( bn, pp, track_dir, 
                                               K.sDirect( b, track_dir ) ) )
            {
              <span class="comment">// if ( setSurface.find( bn ) == setSurface.end() )</span>
              <span class="comment">// {</span>
              aSCellContour2D.push_back( bn );
              hasNextNeighbor=<span class="keyword">true</span>;
              <span class="comment">// setSurface.insert(bn);</span>
              <span class="comment">// }</span>
            }
          b=bn;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0026ca2b0589575ec156784b5db60abf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a4b4a4cd531b56d91d0ec1931f81b3884">track2DBoundary</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSCellContour2D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> &amp;&#160;</td>
          <td class="paramname"><em>trackDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a vector of signed surfels whose elements represents a 2D boundary component of a digital shape described by a PointPredicate. The algorithms tracks surfels along the boundary of the shape by starting from the given [start_surfel], along the direction specified by [trackDir]. More precisely, it is the boundary of the slice of the shape along directions [trackDir] and the orthogonal direction of [start_surfel].</p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aSCellContour2D</td><td>(modified) a vector of cells (which are all surfels), containing the ordered list of the boundary component of [spelset] which touches [start_surfel].</td></tr>
    <tr><td class="paramname">K</td><td>any space (dimension is arbitrary).</td></tr>
    <tr><td class="paramname">trackDir</td><td>the initial track direction at [start_surfel], should be different from the orthogonal direction of [start_surfel].</td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape, which should be at least partially included in the bounds of space [K].</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel which should be between an element of [shape] and an element not in [shape]. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00417">417</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>

<p>References <a class="el" href="SurfelNeighborhood_8ih_source.html#l00350">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::getAdjacentOnPointPredicate()</a>, <a class="el" href="SurfelNeighborhood_8ih_source.html#l00087">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::init()</a>, and <a class="el" href="SurfelNeighborhood_8ih_source.html#l00103">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::setSurfel()</a>.</p>
<div class="fragment"><pre class="fragment">{
  BOOST_CONCEPT_ASSERT(( <a class="code" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate&lt;PointPredicate&gt;</a> ));
  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> b= start_surfel;  <span class="comment">// current surfel</span>
  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> bn; <span class="comment">// neighboring surfel</span>
  ASSERT( K.sIsSurfel( start_surfel ) );
  <span class="comment">// std::set&lt;SCell&gt; setSurface;</span>
  <span class="comment">// setSurface.insert(start_surfel);</span>
  aSCellContour2D.clear(); <span class="comment">// boundary being extracted.</span>
  aSCellContour2D.push_back(start_surfel);
  <a class="code" href="classDGtal_1_1SurfelNeighborhood.html">SurfelNeighborhood&lt;KSpace&gt;</a> SN;
  SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a917b5b927f28381e1d0f62715c91f519">init</a>( &amp;K, &amp;surfel_adj, start_surfel );
  SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a9d5728fe1d5ada79f5249f0dd189d1e1">setSurfel</a>( b );
  <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> orthDir = K.sOrthDir( start_surfel );
  <span class="keywordtype">bool</span> hasPrevNeighbor =  <span class="keyword">true</span>;
  <span class="keywordflow">while</span> ( hasPrevNeighbor )
    {
      hasPrevNeighbor=<span class="keyword">false</span>;
      <span class="comment">// search a tracking direction compatible with track/orth direction</span>
      <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track_dir = K.sOrthDir( b ) == orthDir ? trackDir : orthDir;
      SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a9d5728fe1d5ada79f5249f0dd189d1e1">setSurfel</a>( b );
      <span class="keywordflow">if</span> ( SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a635ea93c00eede9eaf8d85e9fd035e2f">getAdjacentOnPointPredicate</a>( bn, pp, track_dir,
                                           !K.sDirect( b, track_dir ) ) )
        {
          <span class="keywordflow">if</span> ( bn != start_surfel )
            <span class="comment">//    if ( setSurface.find( bn ) == setSurface.end() )</span>
            {
              hasPrevNeighbor=<span class="keyword">true</span>;
              aSCellContour2D.push_back( bn );
              <span class="comment">// setSurface.insert(bn);</span>
            }
        }
      b = bn;
    }
  <span class="comment">// since the contour is not necessary closed we search in the other direction.</span>
  reverse(aSCellContour2D.begin(), aSCellContour2D.end());
  <span class="keywordflow">if</span> ( b != start_surfel )
    { <span class="comment">// the contour is necessarily open.</span>
      b = start_surfel; 
      <span class="keywordtype">bool</span> hasNextNeighbor =  <span class="keyword">true</span>;
      <span class="keywordflow">while</span> ( hasNextNeighbor )
        {
          hasNextNeighbor=<span class="keyword">false</span>;
          <span class="comment">// search a tracking direction compatible with constant direction</span>
          <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track_dir = K.sOrthDir( b ) == orthDir ? trackDir : orthDir;
          SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a9d5728fe1d5ada79f5249f0dd189d1e1">setSurfel</a>( b );
          <span class="keywordflow">if</span> ( SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a635ea93c00eede9eaf8d85e9fd035e2f">getAdjacentOnPointPredicate</a>( bn, pp, track_dir, 
                                               K.sDirect( b, track_dir ) ) )
            {
              <span class="comment">// if ( setSurface.find( bn ) == setSurface.end() )</span>
              <span class="comment">// {</span>
              aSCellContour2D.push_back( bn );
              <span class="comment">// setSurface.insert(bn);</span>
              hasNextNeighbor=<span class="keyword">true</span>;
              <span class="comment">// }</span>
            }
          b=bn;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aeea1a2dc0f7d5c3c86028f2643290486"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#aeea1a2dc0f7d5c3c86028f2643290486">track2DBoundaryPoints</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aVectorOfPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is only 2D.</p>
<p>This method uses random tries to find a first linel separating an interior pixel from an exterior one. It then follows direct orientations to extract the 4-connected set of points.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aVectorOfPoints</td><td>(returns) the sequence of points of the boundary component of the digitized shape containing [start_surfel].</td></tr>
    <tr><td class="paramname">K</td><td>any space of dimension 2.</td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape, which should be at least partially included in the bounds of space [K].</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel which should be between an element of [shape] and an element not in [shape]. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00489">489</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  aVectorOfPoints.clear();
  
  <span class="comment">// Getting the consecutive surfels of the 2D boundary</span>
  std::vector&lt;SCell&gt; vectBdrySCell;
  <a class="code" href="classDGtal_1_1Surfaces.html#a4b4a4cd531b56d91d0ec1931f81b3884">Surfaces&lt;KSpace&gt;::track2DBoundary</a>( vectBdrySCell,
                                     K, surfel_adj, pp, start_surfel );
  <span class="keyword">typedef</span> <span class="keyword">typename</span> std::vector&lt;SCell&gt;::const_iterator SCellConstIterator;
  <span class="keywordflow">for</span> ( SCellConstIterator it = vectBdrySCell.begin(),
          it_end = vectBdrySCell.end(); 
        it != it_end; ++it )
    {
      <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track = *( K.sDirs( *it ) );
      <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> pointel = K.sIndirectIncident( *it, track );
      aVectorOfPoints.push_back( K.sCoords( pointel ) );
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a24fcfb2a607d919c84250bc9965cb86b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename SCellSet , typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a24fcfb2a607d919c84250bc9965cb86b">trackBoundary</a> </td>
          <td>(</td>
          <td class="paramtype">SCellSet &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a set of signed surfels whose elements represents a boundary component of a digital shape described by a PointPredicate. The algorithms tracks surfels along the boundary of the shape.</p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SCellSet</td><td>a model of a set of SCell (e.g., std::set&lt;SCell&gt;).</td></tr>
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>(modified) a set of cells (which are all surfels), the boundary component of [spelset] which touches [start_surfel].</td></tr>
    <tr><td class="paramname">K</td><td>any space. </td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape, which should be at least partially included in the bounds of space [K].</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel which should be between an element of [shape] and an element not in [shape]. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00191">191</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>

<p>References <a class="el" href="SurfelNeighborhood_8ih_source.html#l00350">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::getAdjacentOnPointPredicate()</a>, <a class="el" href="SurfelNeighborhood_8ih_source.html#l00087">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::init()</a>, and <a class="el" href="SurfelNeighborhood_8ih_source.html#l00103">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::setSurfel()</a>.</p>
<div class="fragment"><pre class="fragment">{
  BOOST_CONCEPT_ASSERT(( <a class="code" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate&lt;PointPredicate&gt;</a> ));

  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> b;  <span class="comment">// current surfel</span>
  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> bn; <span class="comment">// neighboring surfel</span>
  ASSERT( K.sIsSurfel( start_surfel ) );
  surface.clear(); <span class="comment">// boundary being extracted.</span>

  <a class="code" href="classDGtal_1_1SurfelNeighborhood.html">SurfelNeighborhood&lt;KSpace&gt;</a> SN;
  SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a917b5b927f28381e1d0f62715c91f519">init</a>( &amp;K, &amp;surfel_adj, start_surfel );
  std::queue&lt;SCell&gt; qbels;
  qbels.push( start_surfel );
  surface.insert( start_surfel );
  <span class="comment">// For all pending bels</span>
  <span class="keywordflow">while</span> ( ! qbels.empty() )
    {
      b = qbels.front();
      qbels.pop();
      SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a9d5728fe1d5ada79f5249f0dd189d1e1">setSurfel</a>( b );
      <span class="keywordflow">for</span> ( <a class="code" href="classDGtal_1_1Surfaces.html#aea3655c1310aed70fc5fcedaef454d21">DirIterator</a> q = K.sDirs( b ); q != 0; ++q )
        {
          <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track_dir = *q;
          <span class="comment">// ----- 1st pass with positive orientation ------</span>
          <span class="keywordflow">if</span> ( SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a635ea93c00eede9eaf8d85e9fd035e2f">getAdjacentOnPointPredicate</a>( bn, pp, track_dir, <span class="keyword">true</span> ) )
            {
              <span class="keywordflow">if</span> ( surface.find( bn ) == surface.end() )
                {
                  surface.insert( bn );
                  qbels.push( bn );
                }
            }
          <span class="comment">// ----- 2nd pass with negative orientation ------</span>
          <span class="keywordflow">if</span> ( SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a635ea93c00eede9eaf8d85e9fd035e2f">getAdjacentOnPointPredicate</a>( bn, pp, track_dir, <span class="keyword">false</span> ) )
            {
              <span class="keywordflow">if</span> ( surface.find( bn ) == surface.end() )
                {
                  surface.insert( bn );
                  qbels.push( bn );
                }
            }
        } <span class="comment">// for ( DirIterator q = K.sDirs( b ); q != 0; ++q )</span>
    } <span class="comment">// while ( ! qbels.empty() )</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae917f93333eb382dd285d660388c9ba7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename SCellSet , typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#ae917f93333eb382dd285d660388c9ba7">trackClosedBoundary</a> </td>
          <td>(</td>
          <td class="paramtype">SCellSet &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a set of signed surfels whose elements represents a boundary component of a digital shape described by a PointPredicate. The algorithms tracks surfels along the boundary of the shape. It follows only direct orientations, so that it is faster than trackBoundary but requires the object to be fully inside the space. Follows the idea of Artzy, Frieder and Herman algorithm [Artzy:1981-cgip], but in nD.</p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SCellSet</td><td>a model of a set of SCell (e.g., std::set&lt;SCell&gt;).</td></tr>
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>(modified) a set of cells (which are all surfels), the boundary component of [spelset] which touches [start_surfel].</td></tr>
    <tr><td class="paramname">K</td><td>any space. </td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape, which should be at least partially included in the bounds of space [K].</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel which should be between an element of [shape] and an element not in [shape]. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00653">653</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>

<p>References <a class="el" href="SurfelNeighborhood_8ih_source.html#l00350">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::getAdjacentOnPointPredicate()</a>, <a class="el" href="SurfelNeighborhood_8ih_source.html#l00087">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::init()</a>, and <a class="el" href="SurfelNeighborhood_8ih_source.html#l00103">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::setSurfel()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> b;  <span class="comment">// current surfel</span>
  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> bn; <span class="comment">// neighboring surfel</span>
  ASSERT( K.sIsSurfel( start_surfel ) );
  surface.clear(); <span class="comment">// boundary being extracted.</span>

  <a class="code" href="classDGtal_1_1SurfelNeighborhood.html">SurfelNeighborhood&lt;KSpace&gt;</a> SN;
  SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a917b5b927f28381e1d0f62715c91f519">init</a>( &amp;K, &amp;surfel_adj, start_surfel );
  std::queue&lt;SCell&gt; qbels;
  qbels.push( start_surfel );
  surface.insert( start_surfel );
  <span class="comment">// For all pending bels</span>
  <span class="keywordflow">while</span> ( ! qbels.empty() )
    {
      b = qbels.front();
      qbels.pop();
      SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a9d5728fe1d5ada79f5249f0dd189d1e1">setSurfel</a>( b );
      <span class="keywordflow">for</span> ( <a class="code" href="classDGtal_1_1Surfaces.html#aea3655c1310aed70fc5fcedaef454d21">DirIterator</a> q = K.sDirs( b ); q != 0; ++q )
        {
          <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track_dir = *q;
          <span class="comment">// ----- One pass, look for direct orientation ------</span>
          <span class="keywordflow">if</span> ( SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a635ea93c00eede9eaf8d85e9fd035e2f">getAdjacentOnPointPredicate</a>( bn, pp, track_dir, 
                                               K.sDirect( b, track_dir ) ) )
            {
              <span class="keywordflow">if</span> ( surface.find( bn ) == surface.end() )
                {
                  surface.insert( bn );
                  qbels.push( bn );
                }
            }
        } <span class="comment">// for ( DirIterator q = K.sDirs( b ); q != 0; ++q )</span>
    } <span class="comment">// while ( ! qbels.empty() )</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a08c4dba52a1b96479aec48d646f4d469"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename SCellSet , typename SurfelPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a08c4dba52a1b96479aec48d646f4d469">trackClosedSurface</a> </td>
          <td>(</td>
          <td class="paramtype">SCellSet &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SurfelPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a set of signed surfels whose elements represents a boundary component of a digital surface described by a SurfelPredicate. The algorithms tracks surfels along the surface. This is an optimized version of trackSurface, which is valid only when the tracked surface is closed.</p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SCellSet</td><td>a model of a set of SCell (e.g., std::set&lt;SCell&gt;).</td></tr>
    <tr><td class="paramname">SurfelPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CSurfelPredicate.html" title="Aim: Defines a predicate on a surfel.">CSurfelPredicate</a> describing whether a surfel belongs or not to the surface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>(modified) a set of cells (which are all surfels), the boundary component of [spelset] which touches [start_surfel].</td></tr>
    <tr><td class="paramname">K</td><td>any space. </td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">sp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CSurfelPredicate.html" title="Aim: Defines a predicate on a surfel.">CSurfelPredicate</a>.</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel which should be part of the surface, ie. 'sp(start_surfel)==true'. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00298">298</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>

<p>References <a class="el" href="SurfelNeighborhood_8ih_source.html#l00414">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::getAdjacentOnSurfelPredicate()</a>, <a class="el" href="SurfelNeighborhood_8ih_source.html#l00087">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::init()</a>, and <a class="el" href="SurfelNeighborhood_8ih_source.html#l00103">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::setSurfel()</a>.</p>
<div class="fragment"><pre class="fragment">{
  BOOST_CONCEPT_ASSERT(( <a class="code" href="structDGtal_1_1CSurfelPredicate.html" title="Aim: Defines a predicate on a surfel.">CSurfelPredicate&lt;SurfelPredicate&gt;</a> ));

  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> b;  <span class="comment">// current surfel</span>
  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> bn; <span class="comment">// neighboring surfel</span>
  ASSERT( K.sIsSurfel( start_surfel ) );
  surface.clear(); <span class="comment">// boundary being extracted.</span>

  <a class="code" href="classDGtal_1_1SurfelNeighborhood.html">SurfelNeighborhood&lt;KSpace&gt;</a> SN;
  SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a917b5b927f28381e1d0f62715c91f519">init</a>( &amp;K, &amp;surfel_adj, start_surfel );
  std::queue&lt;SCell&gt; qbels;
  qbels.push( start_surfel );
  surface.insert( start_surfel );
  <span class="comment">// For all pending bels</span>
  <span class="keywordflow">while</span> ( ! qbels.empty() )
    {
      b = qbels.front();
      qbels.pop();
      SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a9d5728fe1d5ada79f5249f0dd189d1e1">setSurfel</a>( b );
      <span class="keywordflow">for</span> ( <a class="code" href="classDGtal_1_1Surfaces.html#aea3655c1310aed70fc5fcedaef454d21">DirIterator</a> q = K.sDirs( b ); q != 0; ++q )
        {
          <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track_dir = *q;
          <span class="comment">// ----- direct orientation ------</span>
          <span class="keywordflow">if</span> ( SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a32f584693393aaa95c6ca3329dc4e3a7">getAdjacentOnSurfelPredicate</a>( bn, sp, track_dir, 
                                                K.sDirect( b, track_dir ) ) )
            {
              <span class="keywordflow">if</span> ( surface.find( bn ) == surface.end() )
                {
                  surface.insert( bn );
                  qbels.push( bn );
                }
            }
        } <span class="comment">// for ( DirIterator q = K.sDirs( b ); q != 0; ++q )</span>
    } <span class="comment">// while ( ! qbels.empty() )</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a997c3b0bfec1b627a9822d4a1352f4ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename SCellSet , typename SurfelPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a997c3b0bfec1b627a9822d4a1352f4ba">trackSurface</a> </td>
          <td>(</td>
          <td class="paramtype">SCellSet &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1SurfelAdjacency.html">SurfelAdjacency</a>&lt; KSpace::dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>surfel_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SurfelPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> &amp;&#160;</td>
          <td class="paramname"><em>start_surfel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a set of signed surfels whose elements represents a boundary component of a digital surface described by a SurfelPredicate. The algorithms tracks surfels along the surface.</p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">SCellSet</td><td>a model of a set of SCell (e.g., std::set&lt;SCell&gt;).</td></tr>
    <tr><td class="paramname">SurfelPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CSurfelPredicate.html" title="Aim: Defines a predicate on a surfel.">CSurfelPredicate</a> describing whether a surfel belongs or not to the surface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>(modified) a set of cells (which are all surfels), the boundary component of [spelset] which touches [start_surfel].</td></tr>
    <tr><td class="paramname">K</td><td>any space. </td></tr>
    <tr><td class="paramname">surfel_adj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">sp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CSurfelPredicate.html" title="Aim: Defines a predicate on a surfel.">CSurfelPredicate</a>.</td></tr>
    <tr><td class="paramname">start_surfel</td><td>a signed surfel which should be part of the surface, ie. 'sp(start_surfel)==true'. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00244">244</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>

<p>References <a class="el" href="SurfelNeighborhood_8ih_source.html#l00414">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::getAdjacentOnSurfelPredicate()</a>, <a class="el" href="SurfelNeighborhood_8ih_source.html#l00087">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::init()</a>, and <a class="el" href="SurfelNeighborhood_8ih_source.html#l00103">DGtal::SurfelNeighborhood&lt; TKSpace &gt;::setSurfel()</a>.</p>
<div class="fragment"><pre class="fragment">{
  BOOST_CONCEPT_ASSERT(( <a class="code" href="structDGtal_1_1CSurfelPredicate.html" title="Aim: Defines a predicate on a surfel.">CSurfelPredicate&lt;SurfelPredicate&gt;</a> ));

  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> b;  <span class="comment">// current surfel</span>
  <a class="code" href="classDGtal_1_1Surfaces.html#a5eaebd043923d70cecb81470431be557">SCell</a> bn; <span class="comment">// neighboring surfel</span>
  ASSERT( K.sIsSurfel( start_surfel ) );
  surface.clear(); <span class="comment">// boundary being extracted.</span>

  <a class="code" href="classDGtal_1_1SurfelNeighborhood.html">SurfelNeighborhood&lt;KSpace&gt;</a> SN;
  SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a917b5b927f28381e1d0f62715c91f519">init</a>( &amp;K, &amp;surfel_adj, start_surfel );
  std::queue&lt;SCell&gt; qbels;
  qbels.push( start_surfel );
  surface.insert( start_surfel );
  <span class="comment">// For all pending bels</span>
  <span class="keywordflow">while</span> ( ! qbels.empty() )
    {
      b = qbels.front();
      qbels.pop();
      SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a9d5728fe1d5ada79f5249f0dd189d1e1">setSurfel</a>( b );
      <span class="keywordflow">for</span> ( <a class="code" href="classDGtal_1_1Surfaces.html#aea3655c1310aed70fc5fcedaef454d21">DirIterator</a> q = K.sDirs( b ); q != 0; ++q )
        {
          <a class="code" href="namespaceDGtal.html#a8fbe8c8d47ca5c36ced14284ac62613d">Dimension</a> track_dir = *q;
          <span class="comment">// ----- 1st pass with positive orientation ------</span>
          <span class="keywordflow">if</span> ( SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a32f584693393aaa95c6ca3329dc4e3a7">getAdjacentOnSurfelPredicate</a>( bn, sp, track_dir, <span class="keyword">true</span> ) )
            {
              <span class="keywordflow">if</span> ( surface.find( bn ) == surface.end() )
                {
                  surface.insert( bn );
                  qbels.push( bn );
                }
            }
          <span class="comment">// ----- 2nd pass with negative orientation ------</span>
          <span class="keywordflow">if</span> ( SN.<a class="code" href="classDGtal_1_1SurfelNeighborhood.html#a32f584693393aaa95c6ca3329dc4e3a7">getAdjacentOnSurfelPredicate</a>( bn, sp, track_dir, <span class="keyword">false</span> ) )
            {
              <span class="keywordflow">if</span> ( surface.find( bn ) == surface.end() )
                {
                  surface.insert( bn );
                  qbels.push( bn );
                }
            }
        } <span class="comment">// for ( DirIterator q = K.sDirs( b ); q != 0; ++q )</span>
    } <span class="comment">// while ( ! qbels.empty() )</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a77140694e5697b73346f9e7e0e1a52fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename CellSet , typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a77140694e5697b73346f9e7e0e1a52fa">uMakeBoundary</a> </td>
          <td>(</td>
          <td class="paramtype">CellSet &amp;&#160;</td>
          <td class="paramname"><em>aBoundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aLowerBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aUpperBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a set of unsigned surfels whose elements represents all the boundary components of a digital shape described by the predicate [pp].</p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">CellSet</td><td>a model of a set of Cell (e.g., std::set&lt;Cell&gt;). </td></tr>
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aBoundary</td><td>(modified) a set of cells (which are all surfels), the boundary component of [aSpelSet].</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space. </td></tr>
    <tr><td class="paramname">aSurfelAdj</td><td>the surfel adjacency chosen for the tracking. </td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape.</td></tr>
    <tr><td class="paramname">aLowerBound</td><td>and </td></tr>
    <tr><td class="paramname">aUpperBound</td><td>points giving the bounds of the extracted boundary. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00697">697</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k;
  <span class="keywordtype">bool</span> in_here, in_further;
  <span class="keywordflow">for</span> ( k = 0; k &lt; aKSpace.dimension; ++k )
    {
      <a class="code" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> dir_low_uid = aKSpace.uSpel( aLowerBound );
      <a class="code" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> dir_up_uid = aKSpace.uGetDecr( aKSpace.uSpel( aUpperBound ), k);
      <a class="code" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> p = dir_low_uid;
      <span class="keywordflow">do</span> 
        {
          in_here = pp( aKSpace.uCoords(p) );
          in_further = pp( aKSpace.uCoords(aKSpace.uGetIncr( p, k )) );
          <span class="keywordflow">if</span> ( in_here != in_further ) <span class="comment">// boundary element</span>
            { <span class="comment">// add it to the set.</span>
              aBoundary.insert( aKSpace.uIncident( p, k, <span class="keyword">true</span> ));
            }
        }
      <span class="keywordflow">while</span> ( aKSpace.uNext( p, dir_low_uid, dir_up_uid ) );
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a051a425aad5367ebf261d774e2d8244a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKSpace &gt; </div>
<div class="memtemplate">
template&lt;typename OutputIterator , typename PointPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDGtal_1_1Surfaces.html">DGtal::Surfaces</a>&lt; TKSpace &gt;::<a class="el" href="classDGtal_1_1Surfaces.html#a051a425aad5367ebf261d774e2d8244a">uWriteBoundary</a> </td>
          <td>(</td>
          <td class="paramtype">OutputIterator &amp;&#160;</td>
          <td class="paramname"><em>out_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ae254510c81f339dbb5bd4b33ed9f5f3e">KSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>aKSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointPredicate &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aLowerBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDGtal_1_1Surfaces.html#ab58accd9ff51d3cb85f7f4d7e7ed80c5">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>aUpperBound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes on the output iterator <em>out_it</em> the unsigned surfels whose elements represents all the boundary elements of a digital shape described by the predicate [pp].</p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">OutputIterator</td><td>any output iterator (like std::back_insert_iterator&lt; std::vector&lt;Cell&gt; &gt;).</td></tr>
    <tr><td class="paramname">PointPredicate</td><td>a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a> describing the inside of a digital shape, meaning a functor taking a Point and returning 'true' whenever the point belongs to the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out_it</td><td>any output iterator for writing the cells.</td></tr>
    <tr><td class="paramname">aKSpace</td><td>any space.</td></tr>
    <tr><td class="paramname">aSurfelAdj</td><td>the surfel adjacency chosen for the tracking.</td></tr>
    <tr><td class="paramname">pp</td><td>an instance of a model of <a class="el" href="structDGtal_1_1CPointPredicate.html" title="Aim: Defines a predicate on a point.">CPointPredicate</a>, for instance a <a class="el" href="structDGtal_1_1SetPredicate.html" title="Aim: The predicate returning true iff the point is in the domain given at construction.">SetPredicate</a> for a digital set representing a shape.</td></tr>
    <tr><td class="paramname">aLowerBound</td><td>and </td></tr>
    <tr><td class="paramname">aUpperBound</td><td>points giving the bounds of the extracted boundary. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Surfaces_8ih_source.html#l00764">764</a> of file <a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k;
  <span class="keywordtype">bool</span> in_here, in_further;
  <span class="keywordflow">for</span> ( k = 0; k &lt; aKSpace.dimension; ++k )
    {
      <a class="code" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> dir_low_uid = aKSpace.uSpel( aLowerBound );
      <a class="code" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> dir_up_uid = aKSpace.uGetDecr( aKSpace.uSpel( aUpperBound ), k);
      <a class="code" href="classDGtal_1_1Surfaces.html#a6e02ccfe37b82b2d278d066161f4d1d2">Cell</a> p = dir_low_uid;
      <span class="keywordflow">do</span> 
        {
          in_here = pp( aKSpace.uCoords(p) );
          in_further = pp( aKSpace.uCoords(aKSpace.uGetIncr( p, k )) );
          <span class="keywordflow">if</span> ( in_here != in_further ) <span class="comment">// boundary element</span>
            { <span class="comment">// writes it into the output iterator.</span>
              *out_it++ = aKSpace.uIncident( p, k, <span class="keyword">true</span> );
            }
        }
      <span class="keywordflow">while</span> ( aKSpace.uNext( p, dir_low_uid, dir_up_uid ) );
    }
}
</pre></div>
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Surfaces_8h_source.html">Surfaces.h</a></li>
<li><a class="el" href="Surfaces_8ih_source.html">Surfaces.ih</a></li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu May 10 2012 16:10:14 for DGtal by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
